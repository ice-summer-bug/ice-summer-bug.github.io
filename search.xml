<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>mysql InnoDB 锁</title>
      <link href="/2019/07/01/%E6%8A%80%E6%9C%AF/mysql/msyql-innodb-locking/"/>
      <url>/2019/07/01/%E6%8A%80%E6%9C%AF/mysql/msyql-innodb-locking/</url>
      <content type="html"><![CDATA[<h2 id="InnoDB-支持的锁"><a href="#InnoDB-支持的锁" class="headerlink" title="InnoDB 支持的锁"></a>InnoDB 支持的锁</h2><ol><li>共享锁(S)和排它锁(X)</li><li>意向锁</li><li>行锁</li><li>间隙锁（GAP 锁）</li><li>Next-Key Locks</li><li>插入意向锁</li><li>自增长字段锁</li><li>Predicate Locks for Spatial Indexes</li></ol><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>行级锁，实质上是锁定在一个索引记录上，<code>select ... for update</code> 会加锁, <code>delete</code>, <code>update</code> 也会加锁</p><h2 id="GAP-锁"><a href="#GAP-锁" class="headerlink" title="GAP 锁"></a>GAP 锁</h2><p>间隙锁也是作用在索引记录上，但是不同的是， GAP 锁锁定的是两条索引记录之间的间隙，而没有锁定索引记录本身</p><h2 id="Next-Key-锁"><a href="#Next-Key-锁" class="headerlink" title="Next-Key 锁"></a>Next-Key 锁</h2><p><code>Next-Key 锁</code>是行级锁和 GAP 锁的集合，它会锁定命中的索引记录以及这个索引记录前的间隙。</p>]]></content>
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Elastic Search 集群管理之动态扩容收缩</title>
      <link href="/2019/03/16/%E6%8A%80%E6%9C%AF/elastic-search/elastic-search%E9%9B%86%E7%BE%A4%E5%88%9D%E8%AF%86/"/>
      <url>/2019/03/16/%E6%8A%80%E6%9C%AF/elastic-search/elastic-search%E9%9B%86%E7%BE%A4%E5%88%9D%E8%AF%86/</url>
      <content type="html"><![CDATA[<h1 id="Elastic-Search-集群简单介绍"><a href="#Elastic-Search-集群简单介绍" class="headerlink" title="Elastic Search 集群简单介绍"></a><code>Elastic Search</code> 集群简单介绍</h1><h2 id="Elastic-Search-节点重启"><a href="#Elastic-Search-节点重启" class="headerlink" title="Elastic Search 节点重启"></a><code>Elastic Search</code> 节点重启</h2><p><strong><em>注意：本人使用的是 <code>Elastic Search</code> 的版本是 <code>5.6.x</code>, 不同版本的操作 API 可能不一致</em></strong></p><ol><li>禁止分配分片</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT <span class="string">"localhost:9200/_cluster/settings"</span> -H <span class="string">'Content-Type: application/json'</span> -d<span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  "transient": &#123;</span></span><br><span class="line"><span class="string">    "cluster.routing.allocation.enable": "none"</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></table></figure><ol start="2"><li>停止不必要的索引的创建，并发出同步刷新请求（非必要步骤）</li></ol><p><strong><em>在重启节点的过程中，可以不停止索引的创建；但是如果你停止不必要的索引的创建，并发出同步刷新请求的话，分片的回复将会更加快速</em></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST <span class="string">"localhost:9200/_flush/synced"</span></span><br></pre></td></tr></table></figure><p><strong><em>同步刷新操作只能是尽最大努力执行成功，如果有挂起的索引操作，这个操作将会失败，建议多次执行同步刷新请求</em></strong></p><ol start="3"><li>修改节点配置，重启节点</li></ol><p>重启完节点之后可以查看节点是否重启成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET <span class="string">"localhost:9200/_cat/nodes"</span></span><br></pre></td></tr></table></figure><ol start="4"><li>恢复节点分配</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT <span class="string">"localhost:9200/_cluster/settings"</span> -H <span class="string">'Content-Type: application/json'</span> -d<span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  "transient": &#123;</span></span><br><span class="line"><span class="string">    "cluster.routing.allocation.enable": "all"</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></table></figure><ol start="5"><li>等待节点回复</li></ol><p>使用如下指令查看集群状态，知道集群状态从 <code>yellow</code> 变为 <code>green</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET <span class="string">"localhost:9200/_cat/health"</span></span><br></pre></td></tr></table></figure><ol start="6"><li>重复上述步骤，重启其他需要重启的节点</li></ol><h2 id="Elastic-Search-集群动态新增节点"><a href="#Elastic-Search-集群动态新增节点" class="headerlink" title="Elastic Search 集群动态新增节点"></a><code>Elastic Search</code> 集群动态新增节点</h2><h3 id="1-准备在新的机器启动-Elastic-Search-节点"><a href="#1-准备在新的机器启动-Elastic-Search-节点" class="headerlink" title="1. 准备在新的机器启动 Elastic Search 节点"></a>1. 准备在新的机器启动 <code>Elastic Search</code> 节点</h3><h4 id="1-1-从原有节点上拷贝文件到新机器上"><a href="#1-1-从原有节点上拷贝文件到新机器上" class="headerlink" title="1.1 从原有节点上拷贝文件到新机器上"></a>1.1 从原有节点上拷贝文件到新机器上</h4><h4 id="1-2-修改如下配置"><a href="#1-2-修改如下配置" class="headerlink" title="1.2 修改如下配置"></a>1.2 修改如下配置</h4><p>示例如下：将 <code>discovery.zen.minimum_master_nodes</code> 加一，在 <code>discovery.zen.ping.unicast.hosts:</code> 中新增 host <code>new.ip.3</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">discovery.zen.minimum_master_nodes:</span> <span class="number">3</span></span><br><span class="line"><span class="string">discovery.zen.ping.unicast.hosts:</span> <span class="string">["ip1","ip2",</span> <span class="string">"new.ip.3"</span><span class="string">]</span></span><br></pre></td></tr></table></figure><h4 id="1-3-启动此节点"><a href="#1-3-启动此节点" class="headerlink" title="1.3 启动此节点"></a>1.3 启动此节点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch -d</span><br></pre></td></tr></table></figure><h4 id="1-4-查看节点启动情况"><a href="#1-4-查看节点启动情况" class="headerlink" title="1.4 查看节点启动情况"></a>1.4 查看节点启动情况</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET <span class="string">"localhost:9200/_cat/nodes"</span></span><br></pre></td></tr></table></figure><h4 id="1-5-等待集群回复"><a href="#1-5-等待集群回复" class="headerlink" title="1.5 等待集群回复"></a>1.5 等待集群回复</h4><p>使用如下指令查看集群状态，知道集群状态从 <code>yellow</code> 变为 <code>green</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET <span class="string">"localhost:9200/_cat/health"</span></span><br></pre></td></tr></table></figure><h3 id="2-逐个重启其他节点"><a href="#2-逐个重启其他节点" class="headerlink" title="2. 逐个重启其他节点"></a>2. 逐个重启其他节点</h3><p>具体步骤见上述重启步骤，重启 <code>步骤3</code> 中修改 <code>config/elasticsearch.yml</code> 文件</p><p>将 <code>discovery.zen.minimum_master_nodes</code> 加一，在 <code>discovery.zen.ping.unicast.hosts:</code> 中新增 host <code>new.ip.3</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">discovery.zen.minimum_master_nodes:</span> <span class="number">3</span></span><br><span class="line"><span class="string">discovery.zen.ping.unicast.hosts:</span> <span class="string">["ip1","ip2",</span> <span class="string">"new.ip.3"</span><span class="string">]</span></span><br></pre></td></tr></table></figure><h2 id="Elastic-Search-集群动态下线节点"><a href="#Elastic-Search-集群动态下线节点" class="headerlink" title="Elastic Search 集群动态下线节点"></a><code>Elastic Search</code> 集群动态下线节点</h2><h3 id="1-告知集群分配分配的时候排除待下线节点"><a href="#1-告知集群分配分配的时候排除待下线节点" class="headerlink" title="1. 告知集群分配分配的时候排除待下线节点"></a>1. 告知集群分配分配的时候排除待下线节点</h3><p>示例：排除 ip <code>10.0.0.1</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT localhost:9200/_cluster/settings -H <span class="string">'Content-Type: application/json'</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">  "transient" :&#123;</span></span><br><span class="line"><span class="string">      "cluster.routing.allocation.exclude._ip" : "10.0.0.1"</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">&#125;'</span>;<span class="built_in">echo</span></span><br></pre></td></tr></table></figure><h3 id="2-查看分片分配情况"><a href="#2-查看分片分配情况" class="headerlink" title="2. 查看分片分配情况"></a>2. 查看分片分配情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$curl</span> -XGET <span class="string">'http://localhost:9200/_nodes/NODE_NAME/stats/indices?pretty'</span></span><br></pre></td></tr></table></figure><p>执行上述指令得到</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_nodes"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"cluster_name"</span>: <span class="string">"CLUSTER_NAME"</span>,</span><br><span class="line">  <span class="attr">"nodes"</span>: &#123;</span><br><span class="line">    <span class="attr">"H447JUPgRSKZKQdzQ6H0gg"</span>: &#123;</span><br><span class="line">      <span class="attr">"timestamp"</span>: <span class="number">1551617699642</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"e93d15417"</span>,</span><br><span class="line">      <span class="attr">"transport_address"</span>: <span class="string">"IP:9300"</span>,</span><br><span class="line">      <span class="attr">"host"</span>: <span class="string">"IP"</span>,</span><br><span class="line">      <span class="attr">"ip"</span>: <span class="string">"IP:9300"</span>,</span><br><span class="line">      <span class="attr">"roles"</span>: [</span><br><span class="line">        <span class="string">"master"</span>,</span><br><span class="line">        <span class="string">"data"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"indices"</span>: &#123;</span><br><span class="line">        <span class="attr">"docs"</span>: &#123;</span><br><span class="line">          <span class="attr">"count"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"deleted"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"store"</span>: &#123;</span><br><span class="line">          <span class="attr">"size_in_bytes"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"throttle_time_in_millis"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"indexing"</span>: &#123;</span><br><span class="line">          <span class="attr">"index_total"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"index_time_in_millis"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"index_current"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"index_failed"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"delete_total"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"delete_time_in_millis"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"delete_current"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"noop_update_total"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"is_throttled"</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">"throttle_time_in_millis"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"get"</span>: &#123;</span><br><span class="line">          <span class="attr">"total"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"time_in_millis"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"exists_total"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"exists_time_in_millis"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"missing_total"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"missing_time_in_millis"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"current"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"search"</span>: &#123;</span><br><span class="line">          <span class="attr">"open_contexts"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"query_total"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"query_time_in_millis"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"query_current"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"fetch_total"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"fetch_time_in_millis"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"fetch_current"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"scroll_total"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"scroll_time_in_millis"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"scroll_current"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"suggest_total"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"suggest_time_in_millis"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"suggest_current"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"merges"</span>: &#123;</span><br><span class="line">          <span class="attr">"current"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"current_docs"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"current_size_in_bytes"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"total"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"total_time_in_millis"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"total_docs"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"total_size_in_bytes"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"total_stopped_time_in_millis"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"total_throttled_time_in_millis"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"total_auto_throttle_in_bytes"</span>: <span class="number">4320133120</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"refresh"</span>: &#123;</span><br><span class="line">          <span class="attr">"total"</span>: <span class="number">641</span>,</span><br><span class="line">          <span class="attr">"total_time_in_millis"</span>: <span class="number">66</span>,</span><br><span class="line">          <span class="attr">"listeners"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"flush"</span>: &#123;</span><br><span class="line">          <span class="attr">"total"</span>: <span class="number">237</span>,</span><br><span class="line">          <span class="attr">"total_time_in_millis"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"warmer"</span>: &#123;</span><br><span class="line">          <span class="attr">"current"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"total"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"total_time_in_millis"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"query_cache"</span>: &#123;</span><br><span class="line">          <span class="attr">"memory_size_in_bytes"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"total_count"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"hit_count"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"miss_count"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"cache_size"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"cache_count"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"evictions"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"fielddata"</span>: &#123;</span><br><span class="line">          <span class="attr">"memory_size_in_bytes"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"evictions"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"completion"</span>: &#123;</span><br><span class="line">          <span class="attr">"size_in_bytes"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"segments"</span>: &#123;</span><br><span class="line">          <span class="attr">"count"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"memory_in_bytes"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"terms_memory_in_bytes"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"stored_fields_memory_in_bytes"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"term_vectors_memory_in_bytes"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"norms_memory_in_bytes"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"points_memory_in_bytes"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"doc_values_memory_in_bytes"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"index_writer_memory_in_bytes"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"version_map_memory_in_bytes"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"fixed_bit_set_memory_in_bytes"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"max_unsafe_auto_id_timestamp"</span>: <span class="number">-9223372036854775808</span>,</span><br><span class="line">          <span class="attr">"file_sizes"</span>: &#123;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"translog"</span>: &#123;</span><br><span class="line">          <span class="attr">"operations"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"size_in_bytes"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"request_cache"</span>: &#123;</span><br><span class="line">          <span class="attr">"memory_size_in_bytes"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"evictions"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"hit_count"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"miss_count"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"recovery"</span>: &#123;</span><br><span class="line">          <span class="attr">"current_as_source"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"current_as_target"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"throttle_time_in_millis"</span>: <span class="number">90997</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到查询结果中 <code>indices</code> 大部分都是0 ，这是因为步骤 1 排除了当前节点后触发了分配的重新分配</p><h3 id="3-查看集群健康情况"><a href="#3-查看集群健康情况" class="headerlink" title="3. 查看集群健康情况"></a>3. 查看集群健康情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">'http://127.0.0.1:9200/_cluster/health?pretty'</span></span><br></pre></td></tr></table></figure><p>确保集群集状态是 <code>green</code></p><h3 id="4-重启现有节点"><a href="#4-重启现有节点" class="headerlink" title="4. 重启现有节点"></a>4. 重启现有节点</h3><h4 id="4-1-禁止分配分片"><a href="#4-1-禁止分配分片" class="headerlink" title="4.1 禁止分配分片"></a>4.1 禁止分配分片</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT <span class="string">"localhost:9200/_cluster/settings"</span> -H <span class="string">'Content-Type: application/json'</span> -d<span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  "transient": &#123;</span></span><br><span class="line"><span class="string">    "cluster.routing.allocation.enable": "none"</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></table></figure><h4 id="4-2-停止不必要的索引的创建，并发出同步刷新请求（非必要步骤）"><a href="#4-2-停止不必要的索引的创建，并发出同步刷新请求（非必要步骤）" class="headerlink" title="4.2 停止不必要的索引的创建，并发出同步刷新请求（非必要步骤）"></a>4.2 停止不必要的索引的创建，并发出同步刷新请求（非必要步骤）</h4><p><strong><em>在重启节点的过程中，可以不停止索引的创建；但是如果你停止不必要的索引的创建，并发出同步刷新请求的话，分片的回复将会更加快速</em></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST <span class="string">"localhost:9200/_flush/synced"</span></span><br></pre></td></tr></table></figure><h4 id="4-3-修改节点配置，重启节点"><a href="#4-3-修改节点配置，重启节点" class="headerlink" title="4.3 修改节点配置，重启节点"></a>4.3 修改节点配置，重启节点</h4><p>修改 <code>config/elasticsearch.yml</code> 文件</p><p>示例如下：将 <code>discovery.zen.minimum_master_nodes</code> 减一，在 <code>discovery.zen.ping.unicast.hosts:</code> 中去除 host <code>new.ip.3</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">discovery.zen.minimum_master_nodes:</span> <span class="number">2</span></span><br><span class="line"><span class="string">discovery.zen.ping.unicast.hosts:</span> <span class="string">["ip1","ip2"]</span></span><br></pre></td></tr></table></figure><p>重启完节点之后可以查看节点是否重启成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET <span class="string">"localhost:9200/_cat/nodes"</span></span><br></pre></td></tr></table></figure><h4 id="4-4-恢复节点分配"><a href="#4-4-恢复节点分配" class="headerlink" title="4.4 恢复节点分配"></a>4.4 恢复节点分配</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT <span class="string">"localhost:9200/_cluster/settings"</span> -H <span class="string">'Content-Type: application/json'</span> -d<span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  "transient": &#123;</span></span><br><span class="line"><span class="string">    "cluster.routing.allocation.enable": "all",</span></span><br><span class="line"><span class="string">    "cluster.routing.allocation.exclude._ip" : "new.ip.3"</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></table></figure><h4 id="4-5-等待节点回复"><a href="#4-5-等待节点回复" class="headerlink" title="4.5 等待节点回复"></a>4.5 等待节点回复</h4><p>使用如下指令查看集群状态，直到集群状态从 <code>yellow</code> 变为 <code>green</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET <span class="string">"localhost:9200/_cat/health"</span></span><br></pre></td></tr></table></figure><h4 id="4-6-重复上述步骤，逐步重启其他线上节点"><a href="#4-6-重复上述步骤，逐步重启其他线上节点" class="headerlink" title="4.6 重复上述步骤，逐步重启其他线上节点"></a>4.6 重复上述步骤，逐步重启其他线上节点</h4><h3 id="5-下线节点"><a href="#5-下线节点" class="headerlink" title="5. 下线节点"></a>5. 下线节点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep elasticsearch</span><br><span class="line"><span class="built_in">kill</span> PID</span><br></pre></td></tr></table></figure><h3 id="6-修改分片分配配置"><a href="#6-修改分片分配配置" class="headerlink" title="6. 修改分片分配配置"></a>6. 修改分片分配配置</h3><p>删除配置  <code>&quot;cluster.routing.allocation.exclude._ip&quot; : &quot;new.ip.3&quot;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT <span class="string">"localhost:9200/_cluster/settings"</span> -H <span class="string">'Content-Type: application/json'</span> -d<span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  "transient": &#123;</span></span><br><span class="line"><span class="string">    "cluster.routing.allocation.exclude._ip" : null</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>排除分配分片的节点时候除了指定 <code>ip</code> 还可以指定节点名称 <code>name</code> 以及  <code>host</code></p><p>还可以指定ip 匹配规则</p><p>如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT localhost:9200/_cluster/settings -H <span class="string">'Content-Type: application/json'</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">  "transient" :&#123;</span></span><br><span class="line"><span class="string">      "cluster.routing.allocation.exclude._ip" : "10.0.0.*"</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">&#125;'</span>;<span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line">curl -XPUT localhost:9200/_cluster/settings -H <span class="string">'Content-Type: application/json'</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">  "transient" :&#123;</span></span><br><span class="line"><span class="string">      "cluster.routing.allocation.exclude._name" : "NODE_NAME"</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">&#125;'</span>;<span class="built_in">echo</span></span><br></pre></td></tr></table></figure><h6 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h6><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/rolling-upgrades.html" title="Rolling upgrades" target="_blank" rel="noopener">Rolling upgrades</a><br><a href="https://stackoverflow.com/questions/17268495/how-to-remove-node-from-elasticsearch-cluster-on-runtime-without-down-time" title="How to remove node from elasticsearch cluster on runtime without down time" target="_blank" rel="noopener">How to remove node from elasticsearch cluster on runtime without down time</a><br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/allocation-filtering.html" title="Shard Allocation Filtering" target="_blank" rel="noopener">Shard Allocation Filtering</a><br><a href="https://stackoverflow.com/questions/33520384/elasticsearch-how-to-delete-a-cluster-setting" title="Elasticsearch: HOW-TO delete a (cluster) setting" target="_blank" rel="noopener">Elasticsearch: HOW-TO delete a (cluster) setting</a></p>]]></content>
      
      <categories>
          
          <category> elastic-search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elastic search </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何修改jar包中文件</title>
      <link href="/2019/03/01/%E6%8A%80%E6%9C%AF/java/jar%E5%8C%85%E4%B8%AD%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9/"/>
      <url>/2019/03/01/%E6%8A%80%E6%9C%AF/java/jar%E5%8C%85%E4%B8%AD%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9/</url>
      <content type="html"><![CDATA[<h2 id="修改jar-包中的文件"><a href="#修改jar-包中的文件" class="headerlink" title="修改jar 包中的文件"></a>修改jar 包中的文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.列出jar包中的文件清单</span></span><br><span class="line">jar tf genesys_data_etl-0.0.1-SNAPSHOT.jar</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.提取出内部jar包的指定文件</span></span><br><span class="line">jar xf genesys_data_etl-0.0.1-SNAPSHOT.jar BOOT-INF/classes/realtime/t_ivr_data_bj.json</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.然后可以修改文件</span></span><br><span class="line">vim BOOT-INF/classes/realtime/t_ivr_data_bj.json</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.更新配置文件到内部jar包.(存在覆盖，不存在就新增)</span></span><br><span class="line">jar uf genesys_data_etl-0.0.1-SNAPSHOT.jar BOOT-INF/classes/realtime/t_ivr_data_bj.json      </span><br><span class="line"></span><br><span class="line"><span class="comment">#4.1更新内部jar包到jar文件</span></span><br><span class="line">jar uf genesys_data_etl-0.0.1-SNAPSHOT.jar 内部jar包.jar     </span><br><span class="line"></span><br><span class="line"><span class="comment">#5.可以查看验证是否已经更改</span></span><br><span class="line">vim genesys_data_etl-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> jar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jar </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Flink 探究之路 ———— Flink Job 重启策略</title>
      <link href="/2019/01/26/%E6%8A%80%E6%9C%AF/flink/flink%E4%B9%8B%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5/"/>
      <url>/2019/01/26/%E6%8A%80%E6%9C%AF/flink/flink%E4%B9%8B%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<h1 id="Flink-Job-重启策略"><a href="#Flink-Job-重启策略" class="headerlink" title="Flink Job 重启策略"></a>Flink Job 重启策略</h1><p>flink 提供多种重启策略，可以在 <code>flink-conf.yaml</code> 中通过配置 <code>restart-strategy</code> 参数设置默认使用的重启策略，也可以在 <code>job</code> 中指定重启策略。</p><p>flink 提供如下重启策略</p><ol><li>固定延时重启(Fixed delay)</li><li>故障率重启(Failure rate)</li><li>不重启(No restart)</li></ol><p>当 <code>job</code> 没有开启 <code>checkpoint</code> 的时候，一定是使用 <code>不重启</code> 策略，如果 <code>job</code> 开启了 <code>checkpoint</code> 但是没有设置重启策略的时候，将使用 <code>固定延时重启策略</code></p><h3 id="固定延时重启-Fixed-delay"><a href="#固定延时重启-Fixed-delay" class="headerlink" title="固定延时重启(Fixed delay)"></a>固定延时重启(Fixed delay)</h3><p><code>job</code> 发生故障后，尝试重启 n 次，每次重启间隔固定时间 t，n 次之后失败。</p><ol><li>在 <code>flink-conf.yaml</code> 中设置重启策略</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">restart-strategy: fixed-delay</span><br><span class="line">restart-strategy.fixed-delay.attempts: <span class="number">3</span> <span class="comment">// 故障发生后尝试重启次数</span></span><br><span class="line">restart-strategy.fixed-delay.delay: <span class="number">10</span> s <span class="comment">// 重启的间隔时间</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>job</code> 中直接指定重启策略</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.setRestartStrategy(RestartStrategies.fixedDelayRestart(</span><br><span class="line">  <span class="number">3</span>, <span class="comment">// number of restart attempts</span></span><br><span class="line">  Time.of(<span class="number">10</span>, TimeUnit.SECONDS) <span class="comment">// delay</span></span><br><span class="line">));</span><br></pre></td></tr></table></figure><h3 id="故障率重启-Failure-rate"><a href="#故障率重启-Failure-rate" class="headerlink" title="故障率重启(Failure rate)"></a>故障率重启(Failure rate)</h3><p>故障率重启策略在 <code>job</code> 发生故障后尝试重启，但是当在固定时间<code>failure rate interval</code> 内故障次数超过 <code>failure rate</code> 次后，<code>job</code> 被认定为故障。</p><p>举例说明：<code>job</code> 故障停止运行之后，在 5min 内重试 3次，每次间隔10s，如果3次之后依旧失败，则认定为故障</p><ol><li>在 <code>flink-conf.yaml</code> 中设置重启策略</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">restart-strategy: failure-rate</span><br><span class="line">restart-strategy.failure-rate.max-failures-per-interval: <span class="number">3</span>  <span class="comment">// 故障后尝试重启次数</span></span><br><span class="line">restart-strategy.failure-rate.failure-rate-interval: <span class="number">5</span> min  <span class="comment">// 故障后检查故障率的时间间隔</span></span><br><span class="line">restart-strategy.failure-rate.delay: <span class="number">10</span> s   <span class="comment">// 故障后两次尝试重启的间隔时间</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>job</code> 中直接指定重启策略</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.setRestartStrategy(RestartStrategies.failureRateRestart(</span><br><span class="line">  <span class="number">3</span>, <span class="comment">// max failures per interval</span></span><br><span class="line">  Time.of(<span class="number">5</span>, TimeUnit.MINUTES), <span class="comment">//time interval for measuring failure rate</span></span><br><span class="line">  Time.of(<span class="number">10</span>, TimeUnit.SECONDS) <span class="comment">// delay</span></span><br><span class="line">));</span><br></pre></td></tr></table></figure><h3 id="不重启策略-No-Restart"><a href="#不重启策略-No-Restart" class="headerlink" title="不重启策略(No Restart)"></a>不重启策略(No Restart)</h3><ol><li>在 <code>flink-conf.yaml</code> 中设置重启策略</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restart-strategy: none</span><br></pre></td></tr></table></figure><ol start="2"><li><code>job</code> 中直接指定重启策略</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.setRestartStrategy(RestartStrategies.noRestart());</span><br></pre></td></tr></table></figure><h6 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h6><p><a href="https://ci.apache.org/projects/flink/flink-docs-stable/dev/restart_strategies.html" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-stable/dev/restart_strategies.html</a></p><p>本人 flink 小白一枚，如有错漏之处，敬请斧正！</p>]]></content>
      
      <categories>
          
          <category> flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flink </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Flink 探究之路 ———— State</title>
      <link href="/2019/01/26/%E6%8A%80%E6%9C%AF/flink/flink%E4%B9%8Bstate/"/>
      <url>/2019/01/26/%E6%8A%80%E6%9C%AF/flink/flink%E4%B9%8Bstate/</url>
      <content type="html"><![CDATA[<h1 id="Flink-中的-state-状态"><a href="#Flink-中的-state-状态" class="headerlink" title="Flink 中的 state(状态)"></a>Flink 中的 <code>state</code>(状态)</h1><p><code>flink</code> 提供了完善的数据保存机制，那就是 <code>state</code>，flink 中的 <code>Function</code> 和 <code>Operator</code> 在处理输入的过程中，将计算结果或存储到 <code>state</code> 中</p><h2 id="state-的分类"><a href="#state-的分类" class="headerlink" title="state 的分类"></a><code>state</code> 的分类</h2><p><code>flink</code> 中的 <code>state</code> 分为两种类型： <code>Key State</code> 和 <code>Operater State</code>。</p><h2 id="Key-State"><a href="#Key-State" class="headerlink" title="Key State"></a><code>Key State</code></h2><p><code>Key State</code> 总是和 <code>key</code> 相关联，只有 <code>KeyedStream</code> 中的 <code>Funciton</code> 和 <code>Operator</code> 能使用它。</p><p>你可以将 <code>Key State</code> 看作是已经被分割的 <code>Operator State</code>，而且每个 state 分区将对应一个 <code>key</code>，每一个 <code>Key State</code> 在逻辑上绑定一个唯一的结构复杂的 <code>key</code>，这个 <code>key</code> 的组成是 <code>&lt;parallel-operator-instance, key&gt;</code>，这里的 <code>key</code> 可以在代码中自有指定生成方法；而且因为每一个 <code>key</code> 都“属于”一个 <code>keyed-operaotr</code> 的并行实例（也可称为 sub-task）；我们可以将这个 <code>key</code> 的机构简化成 <code>&lt;operator, key&gt;</code>。</p><p><code>Key State</code> 可以更进一步被组织成 <code>Key Groups</code>, <code>Key Group</code> 是 flink 重新分配 <code>Key State</code> 的最小单位；<code>Key Group</code> 的数量和定义的最大并行度的数量一致（PS: 这里的最大并行度是当前 Operator 的并行度吗？还是当前运行环境中的最大并行度？），在运行时的 <code>keyed-operator</code> 的每一个并行实例会和 <code>key</code> 一起为一个或多个 <code>Key Group</code> 工作。</p><p><strong>*对于任何一个支持并行的 <code>Operator</code>，key 相同的事件，将被同一个并行实例处理，也只会出现在同一个 <code>task slot</code> 中，<code>Flink</code> 将 <code>Key State</code> 组织成 <code>Key Groups</code>，每个 <code>Key</code> 及其对应的 <code>Key State</code> 永久和一个特定的 <code>Key group</code> 相绑定，并且，每一个 <code>task slot</code> 负责处理一个或者多个 <code>Key group</code> 中的 key。 当 <code>Flink job</code> 被重新调节时候，<code>Operator</code> 的并行度发生变化，需要对 <code>state</code> 进行重新分配，<code>Flink</code> 承诺 <code>state</code> 的重新分配，将按照 <code>Key group</code> 为最小单位进行重新分配 *</strong></p><h2 id="Operator-State"><a href="#Operator-State" class="headerlink" title="Operator State"></a><code>Operator State</code></h2><p>每一个 <code>Operator State</code> 都会和一个 <code>Operator</code> 的并行实例绑定，<code>Kafka Consumer</code> 就是一个很好的使用flink 的 <code>Operator State</code> 的示例，每一个 <code>Kafka Consumer</code> 的并行实例都维护了一个 Map 类型的 <code>Operator State</code>，Map 的构成是 Kafka 的 <code>Topic Partition</code> 对应的 <code>Offset</code>。</p><p><code>Operator State</code> 接口支持当并行度发生变化的时候，在并行示例之间进行重新分配，这里有多种不同的重新分配的方法。</p><pre><code>疑问：`Key State` 和 `Operator State` 在多个并行实例中是共享的？还是各自维护</code></pre><h2 id="Raw-and-Managed-State（原生和托管的状态"><a href="#Raw-and-Managed-State（原生和托管的状态" class="headerlink" title="Raw and Managed State（原生和托管的状态)"></a>Raw and Managed State（原生和托管的状态)</h2><p><code>Key State</code> 和 <code>Operator State</code> 有两种存在方式 <code>Raw State</code>(原生状态) 和 <code>Managed State</code>(托管状态)。</p><p><code>Manager State</code>（托管状态）：托管状态有flink 运行时控制的数据结构表示，比如内部哈希表或者 <code>RocksDB</code>，举例说明，<code>ListState</code>(List 结构的状态)、<code>MapState</code>（Map 结构的状态），flink 运行是将对状态进行编码并写入到 <code>checkpoint</code> 中。</p><p><code>Raw State</code>(原生状态)：原生状态将被 <code>Operator</code> 保存在它本身的数据结构中，当 <code>checkpoint</code> 被触发的时候，原生状态将以字节队列的形式写入到 <code>checkpoint</code> 中，flink 不知道原生状态的数据结构，仅能看到原生的字节数组。</p><p>所有数据流函数都能使用托管状态，但是只有实现 <code>operators</code> 才能使用原生状态。推荐使用托管状态，因为当并行度发生变化的时候，flink 可以重新分配托管状态，同时还能更好的管理内存。</p><h2 id="使用托管的-Key-State"><a href="#使用托管的-Key-State" class="headerlink" title="使用托管的 Key State"></a>使用托管的 <code>Key State</code></h2><p>托管的 <code>Key State</code> 接口支持方位当前输入元素的 <code>Key</code> 范围内的不同类型的状态， 这意味着 <code>Key State</code> 只能在 <code>KeyedStream</code> 上使用，通过调用 <code>keyBy(...)</code> 方法获得 <code>KeyedStream</code>。</p><p>下面是各种类型的 <code>Key State</code> 的介绍，然后再看在程序中该如何使用它们。</p><ul><li><p><code>ValueState&lt;T&gt;</code>：这里维护了单个 <code>T</code> 类型的可更新、可查看的状态值（由于上述输入元素的 <code>key</code> 的限定，每个 <code>key</code> 对应一个值），使用 <code>update(T t)</code> 方法更新状态， 使用 <code>value()</code> 方法获取状态值。</p></li><li><p><code>ListState&lt;T&gt;</code>：这里维护一个 <code>T</code> 类型的状态数组，通过 <code>update(List&lt;T&gt; list)</code> 更新整个状态数组，通过 <code>add(T t)</code> 来追加状态，通过 <code>addAll(List&lt;T&gt; list)</code> 来追加多个状态，通过 <code>get()</code> 来获取整个状态数组。</p></li><li><p><code>ReduceState&lt;T&gt;</code>：维护一个 <code>T</code> 类型的聚合状态值，聚合通过 <code>add(T t)</code> 方法添加的所有状态值，状态值的聚合通过自定义 <code>ReduceFunction</code> 来实现，通过 <code>get()</code> 来获取聚合状态值</p><pre><code>org.apache.flink.api.common.functions.ReduceFunction&lt;T&gt;T ReduceFunction#reduce(T value1, T value2): 将两个 value 值进行合并，返回合并结果</code></pre></li></ul><ul><li><p><code>AggregatingState&lt;IN, OUT&gt;</code>：通过 <code>add(IN in)</code> 方法添加状态输入值，通过 自定义的 <code>AggregateFunction&lt;IN, ACC, OUT&gt;</code> 对输入值进行合并之后返回 <code>OUT</code> 类型的状态值，<code>AggregatingState</code> 和 <code>ReduceState</code> 类似，区别在于 <code>AggregatingState</code> 合并操作的输入数据类型和查询结果的数据类型可以不一致。</p><pre><code>org.apache.flink.api.common.functions.AggregateFunction&lt;IN, ACC, OUT&gt;&lt;IN&gt;：输入类型&lt;ACC&gt;：自定义累计计数器的类型&lt;OUT&gt;：累计结果的类型ACC createAccumulator()：创建一个累计计数器，开始合并数据ACC add(IN value, ACC accumulator)：将输入数据累加到累计计数器上OUT getResult(ACC accumulator)：查询累计计数结果ACC merge(ACC a, ACC b)：合并两个累计计数器的数据</code></pre></li><li><p><code>MapState&lt;UK, UV&gt;</code>：维护 map 类型的状态集合，支持 map 类型数据结构的基本操作，支持 <code>put(UK k, UV v)</code>，<code>putAll(Map&lt;UK, UV&gt;)</code>，<code>get(UK k)</code>，<code>entries()</code>，<code>keys()</code>，<code>values()</code> 等操作。</p></li></ul><p><strong><em>上述所有 State 都支持 通过 clear() 方法类清除已经保存的状态数据</em></strong></p><p>需要注意的是：</p><ol><li>上述数据对象都是用来和状态数据交互的，无论状态数据是在内存中还是在硬盘中，或者其他存储介质中。</li><li><code>Key State</code> 中，所有状态数据都和 <code>key</code> 关联，状态数据查询结果取决于输入数据的<code>key</code>，所以在用户自定义函数（UDF, User Defined Function）中查询状态数据的时候，如果输入数据的 <code>key</code> 不一致，查询的状态数据结果也会不一致。</li></ol><p>在创建上述类型的 <code>Key Stated</code> 的时候需要用到 <code>StateDescriptor</code>，<code>StateDescriptor</code> 包含了状态的 <code>名称</code>，<code>状态值数据类型</code>，有时候还会包含一个 <code>UDF</code>，例如 <code>ReduceFunction</code>。</p><p>我们可以在 <code>RichFunction</code> 中通过 <code>RuntimeContext</code> 访问状态数据。<code>RuntimeContext</code> 提供如下方法创建各种类型的状态数据。</p><ul><li>ValueState<t> getState(ValueStateDescriptor<t>)</t></t></li><li>ReducingState<t> getReducingState(ReducingStateDescriptor<t>)</t></t></li><li>ListState<t> getListState(ListStateDescriptor<t>)</t></t></li><li>AggregatingState&lt;IN, OUT&gt; getAggregatingState(AggregatingStateDescriptor&lt;IN, ACC, OUT&gt;)</li><li>MapState&lt;UK, UV&gt; getMapState(MapStateDescriptor&lt;UK, UV&gt;)</li></ul><h3 id="状态生存时间-State-Time-To-Live-TTL"><a href="#状态生存时间-State-Time-To-Live-TTL" class="headerlink" title="状态生存时间(State Time-To-Live, TTL)"></a>状态生存时间(State Time-To-Live, TTL)</h3><p>每一个 <code>Key State</code> 都可以设置一个生存时间，如果一个状态数据设置了生存时间，当状态数据过期的时候，转态数据将被清除。</p><p>所有类型的状态数据都支持 <code>生存时间(Time-To-Live)</code>，对于 <code>List</code> 和 <code>Map</code> 类型的状态数据，<code>生存时间</code> 的粒度为集合中的单个数据。</p><p>我们通过 <code>StateTtlConfig</code> 来配置 状态数据的生存时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.StateTtlConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.ValueStateDescriptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.time.Time;</span><br><span class="line"></span><br><span class="line">StateTtlConfig ttlConfig = StateTtlConfig</span><br><span class="line">    .newBuilder(Time.seconds(<span class="number">1</span>))</span><br><span class="line">    .setUpdateType(StateTtlConfig.UpdateType.OnCreateAndWrite)</span><br><span class="line">    .setStateVisibility(StateTtlConfig.StateVisibility.NeverReturnExpired)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">ValueStateDescriptor&lt;String&gt; stateDescriptor = <span class="keyword">new</span> ValueStateDescriptor&lt;&gt;(<span class="string">"text state"</span>, String.class);</span><br><span class="line">stateDescriptor.enableTimeToLive(ttlConfig);</span><br></pre></td></tr></table></figure><p><code>StateDescriptor</code> 默认是不支持设置状态生存时间的，通过 <code>enableTimeToLive(StateTtlConfig ttlConfig)</code> 方法来设置状态生存时间。</p><p><code>StateTtlConfig</code> 中提供如下属性</p><ul><li><p><code>StateTtlConfig.UpdateType</code>： 配置状态生存时间的 <code>上次访问时间</code> 的计算方式，<code>当前时间</code>和<code>上次访问时间</code>的时间间隔决定状态是否过期，取值如下：</p><ol><li><code>Disabled</code>：不设置状态生存时间</li><li><code>OnCreateAndWrite</code>：将创建或者写入时间作为 <code>上次访问时间</code>，默认使用该选项</li><li><code>OnReadAndWrite</code>：将读取或者写入时间作为 <code>上次访问时间</code></li></ol></li><li><p><code>StateTtlConfig.StateVisibility</code>：配置失效状态数据的可见性，决定当获取的状态数据已经失效时，返回什么？配置项取值如下：</p><ol><li><code>NeverReturnExpired</code> 不返回任何过期的状态数据，默认使用该选项</li><li><code>ReturnExpiredIfNotCleanedUp</code> 返回过期但是没有被清除的状态数据</li></ol></li><li><p><code>StateTtlConfig.TimeCharacteristic</code>：配置状态数据生存时间使用的时间类型，目前只支持 <code>ProcessingTime</code></p></li></ul><pre><code>注意：  1. `State backends` 将状态数据的最后修改时间戳和用户状态数据一起存储，这意味着`状态生存时间` 这一特性将增加状态存储的资源消耗。  堆存储的 `State backends` 在内存中存储一个的额外的 java 对象，它包含一个long 类型的时间戳和一个用户状态数据对象。  而 `RocksDB` 存储的`State backend` 则是为每一个状态数据（包含List或Map中的单个数据）额外存储 8 bytes 长度的时间戳数据  2. 目前状态生存时间只支持 `ProcessingTime` 时间类型  3. 当恢复状态的时候，如果状态数据之前没有设置状态生存时间，现在改为设置了状态生存时间；  或者于此相反的情况下，将出现 `兼容性错误`，抛出 `StateMigrationException`  4. 状态生存时间的配置数据，不是 `checkpoint` 和 `savepoint` 的一部分。但是它决定了当前运行任务如何对待 `checkpoint` 或者 `savepoint`。  5. 声明生存时间的 map 类型的状态数据支持可序列话的null 类型的状态数据。如果 null 数据不支持序列化，可以使用 `NullableSerializer` 来包装数据，代价是在 `Serialized from` 增加额外的字节。</code></pre><h3 id="状态数据的清除"><a href="#状态数据的清除" class="headerlink" title="状态数据的清除"></a>状态数据的清除</h3><p>目前状态数据只有通过 <code>ValueState#value()</code> 方法被读取的状态数据会被删除，也就是说，如果状态数据一直没有被读取，就不会被删除！！！当然这个问题后期应该会被修复。目前的API 只支持在获取完成状态快照的时候清理状态数据的大小（也就是这时候清除过期的状态数据），具体配置方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.StateTtlConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.time.Time;</span><br><span class="line"></span><br><span class="line">StateTtlConfig ttlConfig = StateTtlConfig</span><br><span class="line">    .newBuilder(Time.seconds(<span class="number">1</span>))</span><br><span class="line">    .cleanupFullSnapshot()</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>但是需要注意的是，当我们使用增量型 checkpoint，不支持<code>cleanupFullSnapshot()</code>！</p><p><strong><em>问题：8 bytes 不够存储时间戳吧？？？</em></strong></p><h2 id="使用托管的-Operator-State"><a href="#使用托管的-Operator-State" class="headerlink" title="使用托管的 Operator State"></a>使用托管的 <code>Operator State</code></h2><p>想要使用托管的 <code>Operator State</code>，<code>Operator</code> 或者 <code>Function</code> 需要实现 <code>CheckpointedFunction</code> 接口，或者 <code>ListCheckPointed&lt;T extend Serializable&gt;</code> 接口。</p><h3 id="CheckpointedFunction"><a href="#CheckpointedFunction" class="headerlink" title="CheckpointedFunction"></a><code>CheckpointedFunction</code></h3><p><code>CheckpointedFunction</code> 提供以下两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每次需要生成的时候调用该方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">snapshotState</span><span class="params">(FunctionSnapshotContext context)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当用户自定义函数(User-Defined-Function,UDF) 初始化的时候调用此方法</span></span><br><span class="line"><span class="comment"> * 分为两种被调用的场景</span></span><br><span class="line"><span class="comment"> * 1. 自定义函数第一次被初始化的时候被调用</span></span><br><span class="line"><span class="comment"> * 2. 从历史 checkpoint 中恢复数据的时候会被调用</span></span><br><span class="line"><span class="comment"> * 因此此方法被用于初始化状态数据或者从checkpoint中恢复状态数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initializeState</span><span class="params">(FunctionInitializationContext context)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><p>现在 <code>Operator State</code> 只支持 list 类型的状态数据，其中保存的都必须是可序列化的状态数据，而且list 中的数据相互独立，这意味着 <code>Operator State</code> 支持重新分配。不同的 <code>Operator State</code> 访问方法决定了不同的重新分配的方式：</p><ol><li><p>Even-split redistribution：每个算子返回一个状态数据的list集合。 当从 checkpoint 中恢复状态数据或者进行重新分配的时候，List 类型的状态数据将被切割成和并行示例数量一致的子链表，每个算子获得一个子链表，子链表可能为空，也可能包含一个或多个数据。例如，当一个并行度为1 算子，拥有一个 ListState，其中包含数据 e1、e2，当算子的并行改成 2 的时候，发生重新分配，ListState 被切分成两个子链，算子的并行实例1 获得包含 e1 的ListState, 并行实例2 获得包含 e2 的ListState。</p></li><li><p>Union redistribution：每个算子返回一个状态数据的 List 集合，包含所理由的状态数据。当发生重新分配或者从 checkpoint 中恢复状态数据的时候，每个算子都将获取到全部的状态数据。</p></li></ol><p><code>Operator State</code> 的使用方法和 <code>Key State</code> 类似，都是通过 <code>StateDescriptor</code> 来初始化状态数据，下面这个例子使用了 <code>Even-split redistribution</code> 类型的重新分配模式的 <code>Operator State</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferingSink</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">SinkFunction</span>&lt;<span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt;,</span></span><br><span class="line"><span class="class">                   <span class="title">CheckpointedFunction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ListState&lt;Tuple2&lt;String, Integer&gt;&gt; checkpointedState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Tuple2&lt;String, Integer&gt;&gt; bufferedElements;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferingSink</span><span class="params">(<span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">        <span class="keyword">this</span>.bufferedElements = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Tuple2&lt;String, Integer&gt; value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        bufferedElements.add(value);</span><br><span class="line">        <span class="keyword">if</span> (bufferedElements.size() == threshold) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Tuple2&lt;String, Integer&gt; element: bufferedElements) &#123;</span><br><span class="line">                <span class="comment">// send it to the sink</span></span><br><span class="line">            &#125;</span><br><span class="line">            bufferedElements.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">snapshotState</span><span class="params">(FunctionSnapshotContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        checkpointedState.clear();</span><br><span class="line">        <span class="keyword">for</span> (Tuple2&lt;String, Integer&gt; element : bufferedElements) &#123;</span><br><span class="line">            checkpointedState.add(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initializeState</span><span class="params">(FunctionInitializationContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ListStateDescriptor&lt;Tuple2&lt;String, Integer&gt;&gt; descriptor =</span><br><span class="line">            <span class="keyword">new</span> ListStateDescriptor&lt;&gt;(</span><br><span class="line">                <span class="string">"buffered-elements"</span>,</span><br><span class="line">                TypeInformation.of(<span class="keyword">new</span> TypeHint&lt;Tuple2&lt;String, Integer&gt;&gt;() &#123;&#125;));</span><br><span class="line"></span><br><span class="line">        checkpointedState = context.getOperatorStateStore().getListState(descriptor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 当从历史 checkpoint 中恢复状态数据的时候，需要读取保存历史状态数据</span></span><br><span class="line"><span class="comment">        * isRestored 方法可以查询当前是否缓存了历史状态数据</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (context.isRestored()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Tuple2&lt;String, Integer&gt; element : checkpointedState.get()) &#123;</span><br><span class="line">                bufferedElements.add(element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取 <code>Operator State</code> 的入口是 <code>OperatorStateStore</code> 提供的方法，这些方法的命名能够见名之意，如果要使用 <code>Union redistribution</code> 重新分配模式的 <code>Operator State</code>，我们将使用 <code>getUnionListState(StateDescriptor stateDescriptor)</code> 访问状态数据。如果只是使用 <code>Even-split redistribution</code> 重新分配模式的 <code>Operaotor State</code>，调用 <code>getListState(StateDescriptor stateDescriptor)</code> 方法。</p><p>顺便说一句，<code>Key State</code> 也可以在 <code>initializeState</code> 方法中被初始化。</p><h3 id="ListCheckpointed"><a href="#ListCheckpointed" class="headerlink" title="ListCheckpointed"></a><code>ListCheckpointed</code></h3><p>相对于 <code>CheckpointedFunction</code> 接口，<code>ListCheckPointed</code> 接口只支持 <code>Even-split redistribution</code>（偶切分重新分配模式）的 ListState。<code>ListCheckpointed</code> 接口包含如下两个接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个状态数据的 List 用于生成 checkpoint，</span></span><br><span class="line"><span class="comment">* 如果状态数据保证不会被重新分区，可以永远返回 `Collections.singletonList(MY_STATE)`</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">snapshotState</span><span class="params">(<span class="keyword">long</span> checkpointId, <span class="keyword">long</span> timestamp)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 重历史 checkpoint 恢复历史状态数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">restoreState</span><span class="params">(List&lt;T&gt; state)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><h2 id="CheckpointListener"><a href="#CheckpointListener" class="headerlink" title="CheckpointListener"></a><code>CheckpointListener</code></h2><p>如果生成 <code>checkpoint</code> 的时候需要周知其他服务，可以使用 <code>CheckpointListener</code>。</p><p><strong><em>待补充</em></strong></p><h2 id="广播状态-Broadcast-State"><a href="#广播状态-Broadcast-State" class="headerlink" title="广播状态(Broadcast State)"></a>广播状态(Broadcast State)</h2><p>关于广播状态，简而言之，就是一个输入数据对下游的所有处理流程都有影响，需要周知所有下游处理算子。例如一个低流速数据处理规则输入流是高流速的数据数据流，规则输入流需要广播给处理数据的所有算子。</p><p>广播状态与其他 <code>Operator State</code> 之间有三个主要区别。与其余的 operator state 相反，广播状态：</p><ul><li>Map 的格式</li><li>每个算子只能有一条广播的输入流和一个非广播输入流</li><li>算子可以有多个不同名字的广播状态</li></ul><h3 id="广播状态相关-API"><a href="#广播状态相关-API" class="headerlink" title="广播状态相关 API"></a>广播状态相关 <code>API</code></h3><p>对于广播状态的使用<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/stream/state/broadcast_state.html" title="广播状态" target="_blank" rel="noopener">待补充</a>，这里重点突出如下注意事项。</p><h3 id="重要注意事项"><a href="#重要注意事项" class="headerlink" title="重要注意事项"></a>重要注意事项</h3><p>在使用广播状态时要记住以下4个重要事项：</p><ul><li><p>使用广播状态，<code>Operator Task</code> 之间不会相互通信<br><br>这也是为什么只有状态广播方 <code>(Keyed)-BroadcastProcessFunction</code> 能修改广播状态数据的内容；此外，用户需要保证所有并发实例上对于广播状态的输入源的处理逻辑是幂等的，否则不同的并发实例将拥有不一致的广播状态，导致处理结果等数据不一致。</p></li><li><p>不同的 <code>Operator Task</code> 中的广播状态的顺序可能不一致<br><br>虽然 <code>Flink</code>  保证广告状态都会下发给所有算子，不会丢失，但是并不保证广播状态的顺序一致性。因此对于广播状态不能依赖于输入数据的顺序。</p></li></ul><ul><li><p>所有并行实例都会快照一份广播状态数据<br><br>虽然所有并行实例中的广播状态都是一致的（正常使用的情况下），但是每个并行实例都会快找一份自己的广播数据，而不是只快照一份。这种设计是为了避免多个并行示例在恢复期间从单个文件读取数据而造成热点问题。但是也导致了随着并行度的增大，<code>checkpoint</code> 数据大小也会膨胀。<code>Flink</code> 保证数据恢复/扩容的时候不会产生重复的数据，也不会丢失数据。在以相同或者更小的并行度恢复时，每个 <code>task</code> 读取对应的 <code>checkpoint</code>，在以更大的并行度恢复时，每个 <code>task</code> 读取自己的 <code>checkpoint</code>，剩余新增的 <code>task</code> 会循环读取 <code>checkpoint</code>。</p></li><li><p><code>RocksDB state backend</code> 不支持广播状态<br><br>广播状态目前在运行时保存在内存中。因为当前，<code>RocksDB state backends</code>还不支持广播状态。</p></li></ul><p>这里谨期望广播状态能够进一步优化。</p><h6 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h6><p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/stream/state/" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/stream/state/</a><br><br><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/stream/state/state.html" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/stream/state/state.html</a><br><a href="https://stackoverflow.com/questions/45738021/flink-state-backend-keys-atomicy-and-distribution" target="_blank" rel="noopener">https://stackoverflow.com/questions/45738021/flink-state-backend-keys-atomicy-and-distribution</a><br></p><p>本人 flink 小白一枚，如有错漏之处，敬请斧正！</p>]]></content>
      
      <categories>
          
          <category> flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flink </tag>
            
            <tag> state </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Flink 探究之路 ———— 容错机制，Checkpoint 和 Savepoint</title>
      <link href="/2019/01/26/%E6%8A%80%E6%9C%AF/flink/flink%E4%B9%8Bsavepoints%E5%92%8Ccheckpoints/"/>
      <url>/2019/01/26/%E6%8A%80%E6%9C%AF/flink/flink%E4%B9%8Bsavepoints%E5%92%8Ccheckpoints/</url>
      <content type="html"><![CDATA[<h1 id="Flink-的容错机制"><a href="#Flink-的容错机制" class="headerlink" title="Flink 的容错机制"></a>Flink 的容错机制</h1><p><code>Flink</code> 最吸引使用者的地方就是它提供的容错机制保证数据流应用程序的<code>状态</code>的持续性恢复。<code>Flink</code> 保证即使在失败的情况下，数据流中的每一条数据最终也能确保只会对状态数据响应一次（<code>exactly once</code>）。<code>响应一次</code> 的机制可以手动降级到 <code>至少响应一次</code>(<code>at least once</code>)。</p><p><code>容错机制</code> 对分布式流式数据持续性的产生<code>快照</code>(<code>snapshot</code>)并存储。对于持有小型数据状态的数据流应用来说，产生 <code>快照</code> 的过程是很轻量级的，对于数据流的正常处理过程的影响微乎其微。数据流应用的 <code>状态</code> 数据可以存储到一个可配置的环境(<code>Master</code>节点中，或者 <code>HDFS</code> 中）。</p><p>当程序失败（机器、网络或者软件故障）的时候，<code>Flink</code> 将停止分布式数据流应用。然后再从最后一次成功的 <code>checkpoint</code> 中保存的 <code>状态</code>(<code>state</code>) 数据中恢复应用的所有 <code>算子</code>（<code>Operator</code>）。输入数据也被重置到最后一次成功的<code>快照</code>数据中保存的位置 。 <code>Flink</code> 保证并行数据流在重启之后处理的所有数据都不会是最近一次成功的 <code>checkpoint</code> 之前的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">1. `checkpointing` 功能默认是关闭的，需要手动配置，指定开启 `checkpointing`</span><br><span class="line">2. 在 `Flink` 完成保证的基础上，数据流输入源 (`streaming source`)需要保障能回退到指定的最近一个位置。</span><br></pre></td></tr></table></figure><h1 id="Checkpointing"><a href="#Checkpointing" class="headerlink" title="Checkpointing"></a><code>Checkpointing</code></h1><p><code>Flink</code> 的 <code>容错机制</code> 简而言之就是持续不断的对 <code>分布式数据流</code> 和 <code>算子状态(Operator state)</code> 产生 <code>一致性</code> 的 <code>快照</code> 数据。这些 <code>快照</code> 数据系统遇到故障时，用于从错误状态中恢复的 <code>检查点</code> (<code>checkpoints</code>)。 <code>Flink</code> 产生 <code>快照</code> 数据的机制的详细描述如下： <a href="http://arxiv.org/abs/1506.08603" title="Lightweight Asynchronous Snapshots for Distributed Dataflows" target="_blank" rel="noopener">Lightweight Asynchronous Snapshots for Distributed Dataflows</a>，该算法是在参考 <a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/chandy.pdf" title="Chandy-Lamport algorithm" target="_blank" rel="noopener">Chandy-Lamport algorithm</a> 算法的基础上进行改进的，并针对 <code>Flink 执行模型</code> 进行量身定做。</p><h2 id="Barriers-栅栏"><a href="#Barriers-栅栏" class="headerlink" title="Barriers (栅栏)"></a><code>Barriers</code> (<code>栅栏</code>)</h2><p><code>Flink</code> 的分布式快照的核心组成部分就是 <code>Barriers(栅栏)</code>，这些 <code>Barriers(栅栏)</code> 被插入到数据流中，和数据一起往下流。<code>Barriers(栅栏)</code> 不会影响数据流中数据的顺序，数据流保证严格有序。<code>Barriers(栅栏)</code> 将数据切分成两部分，前一部分的数据进入当前的快照数据(<code>snapshot</code>)中，后一部分的数据进入下一快照数据。每个 <code>Barriers(栅栏)</code> 都有一个 <code>ID</code>，这个 <code>ID</code> 就是 <code>Barriers(栅栏)</code> 前一个 <code>snapshot</code> 的 <code>ID</code>。<code>Barriers(栅栏)</code> 不会影响数据流的处理，所以非常轻量级。多个不同 <code>快照</code> 的多个 <code>Barriers(栅栏)</code> 可以在数据流中同时存在，即多个 <code>快照</code> 可以同时创建。</p><p><strong><em>问题：数据流中的数据也会进入 <code>快照</code> ？？？不应该是只包含状态数据吗？</em></strong></p><p><img src="https://segmentfault.com/img/remote/1460000008129555" alt="Barriers" title="Barriers"></p><p><code>Barriers(栅栏)</code> 被插入到 <code>数据源</code>的并行数据流中。为快照 <code>n</code> 产生的 <code>Barriers</code> 注入的位置 S<sub>n</sub> 就是在源数据中包含这些快照数据的位置。例如，在 <code>Apache Kafka</code> 中这个位置就是在分区(<code>partition</code>) 中最后一条已消费数据的偏移位置。 这个位置 S<sub>n</sub> 将被上报给检查点协调器(<code>checkpoint coordinator</code>)，也就是 Flink 的 <code>Job Manager</code>。</p><p>然后 <code>Barriers(栅栏)</code> 流向下游数据流，当中间的<code>算子(Operator)</code> 从所有的上游输入流都接收到了 <code>快照 n</code> 的 <code>栅栏</code> 之后，向所有下游算子下发 <code>快照 n</code> 的 <code>栅栏</code>。当 <code>输出算子(sink operator)</code> （flink 有向无环图[DAG] 的尾节点）从它的所有上游输入流都接收到了 <code>快照 n</code> 的 <code>栅栏</code> 之后会检查点协调器发起 ACK 确认已接收到 <code>快照 n</code>。当所有的 <code>输出算子(sink operator)</code> 都发出了ACK 确认之后，<code>快照 n</code> 的数据被认为已经被处理完成了。</p><p>当 <code>快照 n</code> 已经被确认处理完成了，当前任务不会再向输入流请求获取 <code>快照 n</code> 之前的数据，因此这些数据将已经完成通过真个拓扑数据流。</p><p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.7/fig/stream_aligning.svg" alt title="stream barriers aligning"></p><p>接收多个输入流的算子需要在快照的栅栏上对齐输入流，上图描述了如下特性：</p><ul><li><p>当算子接收到其中一个上游输入流的 <code>快照 n</code> 的栅栏的时候，算子不会处理这个栅栏之后的任何数据，直到它从剩下的所有输入流都接收到 <code>快照 n</code> 的栅栏。否则  <code>快照 n</code> 和  <code>快照 n+1</code> 的数据将被混合在一起。</p></li><li><p>数据流向检查点协调器报告栅栏的时候会被缓存并搁置，这个数据流的数据不会被处理，而是放置到输入缓存中。</p></li><li><p>一旦从最后一个流收到了<code>barrier n</code>，这个算子会发送所有积压的记录（个人注：将barrier之前的数据都发送出去），然后发送快照n的barrier。</p></li><li><p>然后，它继续处理从所有输入流中的数据，先处理输入缓存中的数据，然后处理流中的数据。</p></li></ul><h2 id="状态-State"><a href="#状态-State" class="headerlink" title="状态 State"></a>状态 <code>State</code></h2><p>如果一个算子包含<code>状态</code>，那这个<code>状态</code>数据一定是 <code>快照</code> 的一部分，算子状态有不停的形式：</p><ul><li><p><code>自定义状态</code>：通过转化函数（如 <code>map()</code> 或 <code>filter()</code>）来创建和修改状态数据，详见 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/stream/state/index.html" title="State in Streaming Applications" target="_blank" rel="noopener">State in Streaming Applications</a></p></li><li><p><code>系统状态</code>：这种状态时指的是算子计算过程中的一部分缓存数据。典型的例子就是 <code>窗口缓存</code>，系统收集窗口对应的数据到缓存，直到窗口计算或者发射。</p></li></ul><p>算子在接收到所有上游输入流的栅栏之后，在向所有输出流发射栅栏之前对状态数据进行快照。此时栅栏之前的数据对状态的更改已经生效，并且栅栏之后的数据对状态的修改不会发生。由于快照的状态的数据可能会比较大，它可以存储到一个可配置的状态后端存储系统中。默认状态下，状态数据存储在 <code>JobManager</code> 的内存中，但是在生产环境还是需要配置成一个 <code>可靠</code> 的分布式存储系统（例如 <code>HDFS</code>）. 状态被存储之后，算子会确认其检查点完成，将 <code>快照</code> 的 <code>栅栏</code> 的数据发送给下游。</p><p>现在我们可以看一下 <code>快照</code> 中包含的数据。</p><ul><li>对于并行的输入数据源，快照建立时数据流的偏移位置。</li><li>对于算子，快照包含了一个指向装填实际存储位置的指针。</li></ul><p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.7/fig/checkpointing.svg" alt title="checkpointing"></p><h2 id="Exactly-Once-vs-At-Least-Once-只响应一次还是还是至少响应一次"><a href="#Exactly-Once-vs-At-Least-Once-只响应一次还是还是至少响应一次" class="headerlink" title="Exactly Once vs. At Least Once 只响应一次还是还是至少响应一次"></a>Exactly Once vs. At Least Once 只响应一次还是还是至少响应一次</h2><p>对齐操作可能会增大数据流应用的延时，一般来说，对齐产生的额外延时只有几毫秒的数量级，但是我们也发现过延迟显著增加的异常情况。对于要求延时非常低（几毫秒）的数据流应用，flink 提供在产生检查点的时候关闭对齐的开关。如果关闭对齐步骤，算子会在接收到一个上游的栅栏的时候就会产生一个快照，而不是等到其他上游的栅栏都到齐了再来生成快照。</p><p>当对齐被关闭的时候，算子在收到栅栏的时候也会持续的处理输入数据。也就是说：算子在会在产生 <code>检查点 n</code> 的时候，会处理属于 <code>检查点 n+1</code> 的数据。所以当故障恢复的时候，这部分数据会被重复处理，因为这些数据都属于 <code>检查点 n</code> 的快照数据，同时在 <code>检查点 n</code> 之后也会被回放而被再次处理。</p><pre><code>注意：对齐操作只会发生在多输入运算（join）或者多输出的算子（例如重分区，分流）的场景下。因此，对于普通的并行数据流操作（`map()`, `flatMap()`, fliter() 等），及时在 `至少响应一次（at least once）` 的模式下，也会保证 `只响应一次（exactly once）`</code></pre><h2 id="Asynchronous-State-Snapshots-异步状态快照"><a href="#Asynchronous-State-Snapshots-异步状态快照" class="headerlink" title="Asynchronous State Snapshots 异步状态快照"></a>Asynchronous State Snapshots 异步状态快照</h2><p>上面所述的机制表明算子在存储快照数据到后端存储系统的时候会停止处理输入数据，这种同步产生状态快照的模式每次产生的快照的时候都会引入额外的延时。</p><p>我们完全可以让算子在快照数据的同时继续处理输入数据，让快照的存储在后台异步进行。为了做到异步状态快照，算子必须能保证产生一个状态数据对象被存储之后，后续对状态的修改不会影响这个状态数据对象。例如 <code>RocksDB</code> 中使用的 <code>写时复制（ copy-on-write ）</code> 类型的数据结构。</p><p>接收到输入数据的栅栏的时候，算子开始异步的快照复制出它的状态。算子立即向输出发射栅栏，并继续处理输入数据。当后台异步快照完成时，算子会向 <code>检查点协调器</code>（<code>checkpoints coordinator</code>, 也就是 <code>Job Manager</code>）确认检查点完成，现在检查点完成的充分条件是：所有的 <code>输出算子（sink）</code> 都接收到了栅栏，而且所有有状态的算子确认完成了状态数据的备份（这个确认操作可能会晚于栅栏到达 <code>输出算子（sink）</code>）。</p><p>详细的状态快照见： <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/ops/state/state_backends.html" title="State Backends" target="_blank" rel="noopener">State Backends</a></p><h2 id="故障恢复-Recovery"><a href="#故障恢复-Recovery" class="headerlink" title="故障恢复(Recovery)"></a><code>故障恢复(Recovery)</code></h2><p>这种机制下的故障恢复就很简单：当发生故障的时候，<code>Flink</code> 选择最新完成的<code>检查点 k</code>。然后系统重新部署整个分布式数据流，给所有的算子提供快照在检查点中的状态数据用于恢复。输入流的读取位置被设置到从 S<sub>k</sub> 开始读取，对于 <code>Apache Kafka</code> 来说就是通知 <code>consumer</code> 从偏移位置 S<sub>k</sub> 开始消费消息。</p><h2 id="算子快照的实现"><a href="#算子快照的实现" class="headerlink" title="算子快照的实现"></a>算子快照的实现</h2><p>算子产生快照的过程分为两个部分：<code>同步部分</code> 和 <code>异步部分</code>。</p><p>算子和状态后端存储系统(<code>State Backends</code>) 提供 <code>Java FutureTask</code> 用于快照。这个任务包含同步部分已经完成，异步部分还在等待的状态，检查点的异步部分在后台线程中被执行。</p><p>完成同步的算子仅仅返回一个已经完成的 <code>FutureTask</code>。如果需要异步执行，<code>FutureTask</code> 中的 <code>run()</code> 方法将被会调用。</p><p>这些 <code>FutureTask</code> 是可以取消的，这样就可以释放流和其他资源的消耗。</p><h1 id="比较一下-Checkpoint-和-Savepoint"><a href="#比较一下-Checkpoint-和-Savepoint" class="headerlink" title="比较一下 Checkpoint 和 Savepoint"></a>比较一下 <code>Checkpoint</code> 和 <code>Savepoint</code></h1><p><code>Checkpoint</code> 和 <code>Savepoint</code> 都是 flink 提供的容错恢复机制，两个不管是命名还是使用方式都很类似，这里分别对两个进行一个简单的介绍并且对二者进行对比。</p><h2 id="保存点-Savepoint"><a href="#保存点-Savepoint" class="headerlink" title="保存点(Savepoint)"></a><code>保存点(Savepoint)</code></h2><p>保存点是通过 <code>Flink</code> 的 <code>检查点机制(checkpointing mechanism)</code> 创建的，包含数据流任务的运行状态的一个一致性的快照数据。你可以用保存点去停止并重启任务、复制任务或者更新任务。</p><p>保存点由两个部分组成</p><ol><li>存储在一个稳定的存储介质（<code>HDFS</code>、<code>S3</code>等）上的，一般来说比较大的包含二进制文件的文件夹。这些二进制文件纯粹的保存任务的运行状态的快照数据。</li><li>一个元数据文件（一般来说比较小），文件中保存了指向存储在稳定存储介质上的保存点的所有文件的指针（文件路径）。</li></ol><h2 id="算子命名的重要性"><a href="#算子命名的重要性" class="headerlink" title="算子命名的重要性"></a>算子命名的重要性</h2><p>保存点中维护了一个 map 格式的数据</p><pre><code>Operator ID | State------------+------------------------source-id   | State of StatefulSourcemapper-id   | State of StatefulMapper</code></pre><p>通过算子的ID 能够获取到起对应的状态数据，在新增、删除算子或者修改算子的顺序的时候如果没有自定义命名，而是使用 flink 的默认命名方式，算子的数量和顺序的改变会影响重新启动的算子的ID，可能会导致算子ID 的状态数据匹配错误。强烈建议给每个算子设置一个  <code>ID</code>。</p><h2 id="从保存点重启任务的时候算子修改会有什么结果"><a href="#从保存点重启任务的时候算子修改会有什么结果" class="headerlink" title="从保存点重启任务的时候算子修改会有什么结果?"></a>从保存点重启任务的时候算子修改会有什么结果?</h2><h3 id="新增一个有状态的节点"><a href="#新增一个有状态的节点" class="headerlink" title="新增一个有状态的节点"></a>新增一个有状态的节点</h3><p>When you add a new operator to your job it will be initialized without any state. Savepoints contain the state of each stateful operator. Stateless operators are simply not part of the savepoint. The new operator behaves similar to a stateless operator.</p><p>新增的有状态的算子在重启的时候变现的和无状态的算子一样，因为保存点中没有这个算子对应的装填数据。</p><h3 id="删除一个有状态的节点"><a href="#删除一个有状态的节点" class="headerlink" title="删除一个有状态的节点"></a>删除一个有状态的节点</h3><p>默认情况下删除一个有状态的节点会导致重启失败，因为这个过程默认需要确保所有状态数据都要对应一个算子。如果你真的需要删除一个状态的节点，你需要在启动参数中加上参数 <code>--allowNonRestoredState (short: -n)</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/flink run -s :savepointPath -n [:runArgs]</span><br></pre></td></tr></table></figure><h3 id="重新排序有状态的节点-amp-amp-删除或者重新排序无状态的节点"><a href="#重新排序有状态的节点-amp-amp-删除或者重新排序无状态的节点" class="headerlink" title="重新排序有状态的节点 &amp;&amp; 删除或者重新排序无状态的节点"></a>重新排序有状态的节点 &amp;&amp; 删除或者重新排序无状态的节点</h3><p>算子指定ID 的情况下没问题，否则可能会导致状态数据匹配错误而重启失败</p><h3 id="修改算子的并行度"><a href="#修改算子的并行度" class="headerlink" title="修改算子的并行度"></a>修改算子的并行度</h3><p><code>flink 1.2</code> 以上版本并且没有使用任何 <code>State</code> 相关的 <code>过时API</code> 没有问题。<br>如果保存点是在 <code>flink 1.2</code> 以下版本或者使用了 <code>State</code> 相关的 <code>过时API</code> 的代码中生成的，你需要升级 flink 版本并且替换 <code>State</code> 相关的 <code>过时API</code>，详见 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/ops/upgrading.html" title="upgrading jobs and Flink versions guide." target="_blank" rel="noopener">upgrading jobs and Flink versions guide</a></p><h2 id="保存点-Savepoint-和-检查点-Checkpoint-的区别"><a href="#保存点-Savepoint-和-检查点-Checkpoint-的区别" class="headerlink" title="保存点(Savepoint) 和 检查点(Checkpoint) 的区别"></a><code>保存点(Savepoint)</code> 和 <code>检查点(Checkpoint)</code> 的区别</h2><p>从在概念上说，<code>保存点(Savepoint)</code> 和 <code>检查点(Checkpoint)</code> 的不同比较像备份不同于传统数据库从日志恢复。</p><p>下面是他们的不同点：</p><table><thead><tr><th></th><th>检查点</th><th>保存点</th></tr></thead><tbody><tr><td>目的</td><td>为出现异常情况 Flink 任务提供一个恢复机制确保任务能从部分故障中恢复</td><td>用户手动维护任务的时候触发应用重启等操作</td></tr><tr><td>设计要求</td><td>作为一个用于恢复的，被周期调用的方法，它的实现要求:<br> 1. 创建过程很轻量级 <br> 2. 可以快速的从检查点恢复故障</td><td>保存点的设计要求更着重于备份数据的便携性，而不是很关注创建过程的轻量级和快速恢复。</td></tr><tr><td>生命周期</td><td>flink 直接管理检查点的生命周期，从创建到释放都不需要维护人用手动触发</td><td>维护人员手动触发保存点的创建和删除，所有者是维护人员。</td></tr><tr><td>删除</td><td>用户停止任务之后被删除（除非编码或配置声明保留）</td><td>维护人员手动删除</td></tr><tr><td>具体实现</td><td>虽然目前保存点和检查点的代码实现和产生的文件格式都是一样的，但是使用 RocksDB 的检查点使用的保存格式不是flink 定义的，而是 RocksDB 自定义的格式，而且 RocksDB 的检查点支持增量检查点<br><span style="color:red">不支持 rescaling </span></td><td>不支持增量，支持 rescaling</td></tr></tbody></table><p><strong>* rescaling 的翻译存疑，猜测是改变并行度*</strong></p><h6 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h6><p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/internals/stream_checkpointing.html" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-release-1.7/internals/stream_checkpointing.html</a><br><br><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/ops/state/checkpoints.html" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-release-1.7/ops/state/checkpoints.html</a><br><br><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/ops/state/savepoints.html" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-release-1.7/ops/state/savepoints.html</a><br></p><p>本人 flink 小白萌新一枚，如有错漏之处，敬请斧正！</p>]]></content>
      
      <categories>
          
          <category> flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flink </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mogilefs 基础介绍</title>
      <link href="/2019/01/10/%E6%8A%80%E6%9C%AF/mogifs/mogilefs-base-desc/"/>
      <url>/2019/01/10/%E6%8A%80%E6%9C%AF/mogifs/mogilefs-base-desc/</url>
      <content type="html"><![CDATA[<h1 id="mogilefs"><a href="#mogilefs" class="headerlink" title="mogilefs"></a><code>mogilefs</code></h1><h2 id="mogilefs-介绍"><a href="#mogilefs-介绍" class="headerlink" title="mogilefs 介绍"></a><code>mogilefs</code> 介绍</h2><p>MogileFS是一个开源的分布式文件存储系统，由LiveJournal旗下的DangaInteractive公司开发。Danga团队开发了包括 Memcached、MogileFS、Perlbal 等多个知名的开源项目。目前使用MogileFS 的公司非常多，如日本排名先前的几个互联公司及国内的yupoo(又拍)、digg、豆瓣、1号店、大众点评、搜狗和安居客等，分别为所在的组织或公司管理着海量的图片。</p><h2 id="mogilefs-基本概念"><a href="#mogilefs-基本概念" class="headerlink" title="mogilefs 基本概念"></a><code>mogilefs</code> 基本概念</h2><h3 id="mogilefs-组成架构"><a href="#mogilefs-组成架构" class="headerlink" title="mogilefs 组成架构"></a><code>mogilefs</code> 组成架构</h3><p><code>tracker节点</code>: <code>tracker节点</code> 是应用程序 <code>mogilefsd</code>，通过数据库来保存元数据，提供API 响应客户端 <br><br><code>storage节点</code>: <code>storage节点</code> 是应用程序 <code>mogstored</code>，本质上是一个 <code>WebDAV</code> 服务，默认监听 <code>7500</code> 端口，接受客户端的文件存储请求 <br><br><code>database</code>: 用于存储元数据的 <code>mysql</code> 数据库 <br></p><p><img src="https://s1.51cto.com/images/20171204/1512393806362708.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt title="mogilefs 结构图"></p><h3 id="mogilefs-数据存储相关概念"><a href="#mogilefs-数据存储相关概念" class="headerlink" title="mogilefs 数据存储相关概念"></a><code>mogilefs</code> 数据存储相关概念</h3><p><code>domain</code>: <code>mogilefs</code> 划分数据存储的容器，每一个 domain 中的数据的  key 不能重复，但是不同 domain 中数据的 key 可以重复；domain 的划分可以按照数据类型划分，也可以按照业务类型划分。<br><br><code>host</code>: <code>mogilefs</code> 的每一个存储节点被称为一个 <code>host</code>，每个 <code>host</code> 有自己的 ID<br><br><code>device</code>: 每个存储节点可以挂靠多个 <code>device</code>， 每个 <code>device</code> 对应一个时间存储数据的存储设备（硬盘），每个 <code>device</code> 有自己的ID<br><br><code>class</code>: 对于存储在mogilefs 上的文件进行分类，同一 <code>domain</code> 下的文件可以分类不同类型，但是key 不同重复，上传文件时，可指定 <code>class</code>， 默认为 <code>default</code> <br> </p><h2 id="mogilefs-基本操作"><a href="#mogilefs-基本操作" class="headerlink" title="mogilefs 基本操作"></a><code>mogilefs</code> 基本操作</h2><h3 id="mogadm"><a href="#mogadm" class="headerlink" title="mogadm"></a><code>mogadm</code></h3><h4 id="mogadm-check"><a href="#mogadm-check" class="headerlink" title="mogadm check"></a><code>mogadm check</code></h4><p>检查 <code>mogilefs</code> 集群状态</p><pre><code>$mogadm checkChecking trackers...127.0.0.1:7001 ... OKChecking hosts...[ 1] storage1 ... OKChecking devices...host device         size(G)    used(G)    free(G)   use%   ob state   I/O%---- ------------ ---------- ---------- ---------- ------ ---------- -----[ 1] dev1           374.702     29.018    345.684   7.74%  writeable   0.0---- ------------ ---------- ---------- ---------- ------     total:   374.702     29.018    345.684   7.74%</code></pre><h4 id="mogadm-domain"><a href="#mogadm-domain" class="headerlink" title="mogadm domain"></a><code>mogadm domain</code></h4><p><code>mogilefs</code> 集群 <code>domain</code> 管理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mogadm domain add domain1 <span class="comment"># 新增 domain</span></span><br><span class="line">mogadm domain delete domain1 <span class="comment"># 删除 domain</span></span><br><span class="line">mogadm domain list <span class="comment"># 列出所有 domain</span></span><br></pre></td></tr></table></figure><h4 id="mogadm-host"><a href="#mogadm-host" class="headerlink" title="mogadm host"></a><code>mogadm host</code></h4><p><code>mogilefs</code> 集群 <code>host</code> 管理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新增 host</span></span><br><span class="line">mogadm --trackers=127.0.0.1:7001 host add host1 --ip=[<span class="variable">$ip</span>] --port=7500 --status=alive </span><br><span class="line">mogadm host delete host1 <span class="comment"># 删除 host, 不指定tracker 的时候默认使用本机 `127.0.0.1:7001`</span></span><br><span class="line">mogadm host list <span class="comment"># 列出所有 host</span></span><br></pre></td></tr></table></figure><h4 id="mogadm-device"><a href="#mogadm-device" class="headerlink" title="mogadm device"></a><code>mogadm device</code></h4><p><code>mogilefs</code> 集群 <code>device</code> 管理</p><h5 id="device-列出"><a href="#device-列出" class="headerlink" title="device 列出"></a><code>device</code> 列出</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mogadm device list <span class="comment"># 列出所有 host</span></span><br></pre></td></tr></table></figure><h5 id="新增-device"><a href="#新增-device" class="headerlink" title="新增 device"></a>新增 <code>device</code></h5><p>下面的例子中新增 <code>device</code></p><ol><li><p>进入 <code>/etc/mogilefs/mogstored.conf</code> 文件中配置的 <code>docroot</code>，例如 <code>cd /home1/mogdata</code></p></li><li><p>如果待挂载的 <code>device</code>（ID 命名为 dev2） 所在的硬盘和 <code>/home1</code> 所在硬盘不一致(例如 <code>/home2</code>)，需要在 <code>/home2</code> 中新建目录 <code>/home2/mogdata/dev2</code>，并在 <code>/home1/mogdata</code> 中创建软链</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -pv /home2/mogdata/dev2;</span><br><span class="line"><span class="built_in">cd</span> /home1/mogdata;</span><br><span class="line">ln -s /home2/mogdata/dev2 dev2;</span><br><span class="line">mogadm --trackers=127.0.0.1:7001 device add host1 dev2</span><br></pre></td></tr></table></figure><h5 id="device-状态修改"><a href="#device-状态修改" class="headerlink" title="device 状态修改"></a><code>device</code> 状态修改</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dev2 磁盘故障</span></span><br><span class="line">mogadm --trackers=127.0.0.1:7001 device mark host1 dev2 dead <span class="comment"># 将 dev2 置为死亡，不可用</span></span><br><span class="line"><span class="comment"># dev2 磁盘故障恢复，无法直接从 dead 更换到 alive，需先过渡到 down 状态</span></span><br><span class="line">mogadm --trackers=127.0.0.1:7001 device mark host1 dev2 down <span class="comment"># 将 dev2 置为 down 状态</span></span><br><span class="line">mogadm --trackers=127.0.0.1:7001 device mark host1 dev2 alive <span class="comment"># 将 dev2 置为 alive 状态</span></span><br></pre></td></tr></table></figure><h5 id="device-列表状态查询"><a href="#device-列表状态查询" class="headerlink" title="device 列表状态查询"></a><code>device</code> 列表状态查询</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mogadm --trackers=127.0.0.1:7001 device summary</span><br></pre></td></tr></table></figure><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mogupload --trackers=<span class="string">"127.0.0.1:7001"</span> --domain=[<span class="variable">$&#123;domain&#125;</span>] --key=[<span class="variable">$&#123;key&#125;</span>] --file=[<span class="variable">$&#123;file&#125;</span>] --class=[<span class="variable">$&#123;class&#125;</span>]</span><br></pre></td></tr></table></figure><p><code>--domain</code>: 指定上传文件的 <code>domain</code><br><code>--key</code>: 指定上传文件的 <code>key</code><br><code>--file</code>: 指定上传文件的路径<br><code>--class</code>: 指定上传文件的 <code>class</code>，可选项，默认值为 <code>default</code></p><h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mogfetch --trackers=host --domain=[<span class="variable">$&#123;domain&#125;</span>] --key=[<span class="variable">$&#123;key&#125;</span>] --file=[<span class="variable">$&#123;file&#125;</span>]</span><br></pre></td></tr></table></figure><p><code>--domain</code>: 指定上传文件的 <code>domain</code><br><code>--key</code>: 指定上传文件的 <code>key</code><br><code>--file</code>: 指定下载文件的路径及名称</p><h3 id="文件查看"><a href="#文件查看" class="headerlink" title="文件查看"></a>文件查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mogfileinfo  --trackers=<span class="string">"127.0.0.1:7001"</span> --domain=[<span class="variable">$&#123;domain&#125;</span>] --key=[<span class="variable">$&#123;key&#125;</span>]</span><br></pre></td></tr></table></figure><p><code>--domain</code>: 指定上传文件的 <code>domain</code><br><code>--key</code>: 指定上传文件的 <code>key</code></p><p>输出结果：</p><pre><code>- file: [$file]class:                   defaultdevcount:                    1domain:                 [$domain]fid:                   30key:      [$key]length:                  608- http://127.0.0.1:7500/dev1/0/000/000/0000000030.fid</code></pre>]]></content>
      
      <categories>
          
          <category> mogilefs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mogilefs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Flink DateStream API</title>
      <link href="/2018/11/19/%E6%8A%80%E6%9C%AF/flink/Flink-DateStream-API-Desc/"/>
      <url>/2018/11/19/%E6%8A%80%E6%9C%AF/flink/Flink-DateStream-API-Desc/</url>
      <content type="html"><![CDATA[<h1 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h1><p><em>Chandy Lamport algorithm</em></p><h2 id="barrier"><a href="#barrier" class="headerlink" title="barrier"></a>barrier</h2><h2 id="checkpoint-configurations"><a href="#checkpoint-configurations" class="headerlink" title="checkpoint configurations"></a>checkpoint configurations</h2><h3 id="checkpoint-mode"><a href="#checkpoint-mode" class="headerlink" title="checkpoint mode"></a>checkpoint mode</h3><ol><li>exactly-once</li><li>at-least-once</li></ol><p><span style="color:red">是否可以给单个算子指定 <code>exactly-once</code> 或者 <code>at-least-once</code> </span></p><h3 id="checkpoint-interval"><a href="#checkpoint-interval" class="headerlink" title="checkpoint interval"></a>checkpoint interval</h3><h3 id="checkpoint-timeout"><a href="#checkpoint-timeout" class="headerlink" title="checkpoint timeout"></a>checkpoint timeout</h3><h3 id="minimum-time-between-checkpoints"><a href="#minimum-time-between-checkpoints" class="headerlink" title="minimum time between checkpoints"></a>minimum time between checkpoints</h3><h3 id="number-of-concurrent-checkpoints"><a href="#number-of-concurrent-checkpoints" class="headerlink" title="number of concurrent checkpoints"></a>number of concurrent checkpoints</h3><h3 id="externalized-checkpoints"><a href="#externalized-checkpoints" class="headerlink" title="externalized checkpoints"></a>externalized checkpoints</h3><ol><li><code>ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION</code>: 当 flink job 被取消的时候保存 <code>checkpoint</code>，也就是说当我们主动取消 job 的时候需要我手动删除</li><li><code>ExternalizedCheckpointCleanup.DELETE_ON_CANCELLATION</code>: 当 flink job 被取消的时候删除 <code>checkpoint</code>， 只有 job 状态是故障失败时 <code>checkpoint</code> 才会被保存。</li></ol><h4 id="retain-state-checkpoint"><a href="#retain-state-checkpoint" class="headerlink" title="retain state checkpoint"></a>retain state checkpoint</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">state.checkpoints.dir:</span> <span class="attr">hdfs:///checkpoints/</span></span><br></pre></td></tr></table></figure><h1 id="state"><a href="#state" class="headerlink" title="state"></a>state</h1><h2 id="keyed-state"><a href="#keyed-state" class="headerlink" title="keyed state"></a>keyed state</h2><p><code>Keyed Stream</code> 的状态</p><h3 id="ListState"><a href="#ListState" class="headerlink" title="ListState"></a>ListState</h3><p>List 类型的状态集合</p><h3 id="ValueState"><a href="#ValueState" class="headerlink" title="ValueState"></a>ValueState</h3><p>单个状态</p><h3 id="MapState"><a href="#MapState" class="headerlink" title="MapState"></a>MapState</h3><p>Map 类型的状态集合</p><h3 id="ReducingState"><a href="#ReducingState" class="headerlink" title="ReducingState"></a>ReducingState</h3><p>合并统一类型的多个状态数据到一个状态数据</p><h3 id="AggregatingState"><a href="#AggregatingState" class="headerlink" title="AggregatingState"></a>AggregatingState</h3><h2 id="operator-state"><a href="#operator-state" class="headerlink" title="operator state"></a>operator state</h2><p><code>org.apache.flink.api.common.state.OperatorStateStore</code> 用于注册 operator state</p><p><code>getUnionListState</code>: 获取分布式集群中的 <code>ListState</code></p><p><code>getListState</code>: 获取单点的 <code>ListState</code></p><h1 id="state-backend"><a href="#state-backend" class="headerlink" title="state backend"></a>state backend</h1><ol><li>asynchronus</li><li>synchronus</li></ol><h2 id="memory-state-backends"><a href="#memory-state-backends" class="headerlink" title="memory state backends"></a>memory state backends</h2><p>缺点</p><ol><li>每个 <code>state</code> 大小限制是 5M</li><li><code>state</code> 的大小不能超过 <code>akka frame size</code></li><li><code>aggregate state</code> 必须存放在 <code>Job Manager</code> 的内存中</li></ol><h2 id="fs-state-backends"><a href="#fs-state-backends" class="headerlink" title="fs state backends"></a>fs state backends</h2><p>该模式需要配置文件系统URL，支持 <code>hdfs(hdfs://namenode:40010/flink/checkpoints)</code> 或 <code>本地文件(file:///data/flink/checkpoints)</code><br>将未完成的数据存储在 <code>TaskManager</code> 的内存中，而将 <code>state snapshot</code> 写入到文件系统或者文件夹中，最小化元数据被保存在JobManager的内存中（在高可用模式下，被保存在元数据checkpoint中）。<br>该模式默认 <code>异步</code> 写入 <code>state backend</code>，也可以改为 <code>同步</code> 写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new FsStateBackend(path, false); // true: 异步，false：同步</span><br></pre></td></tr></table></figure><h2 id="rocksdb-state-backends"><a href="#rocksdb-state-backends" class="headerlink" title="rocksdb state backends"></a>rocksdb state backends</h2><p>该模式需要配置文件系统URL，支持 <code>hdfs(hdfs://namenode:40010/flink/checkpoints)</code> 或 <code>本地文件(file:///data/flink/checkpoints)</code><br>将未完成的数据存储在 <code>rocksDB</code> 中，而将 <code>state snapshot</code> 写入配置的文件系统或者文件夹中，最小化元数据被保存在JobManager的内存中（在高可用模式下，被保存在元数据checkpoint中）。</p><p><code>RocksDBStateBackend</code> 只支持异步快照模式</p><p>缺点：</p><ol><li>因为RocksDB的JNI的API基于byte[]，状态中每个key和每个value所支持的最大值各为2^31字节。</li></ol><p><strong><em>注意：state使用了RocksDB的合并算子（如ListState），状态的大小很容易累积超过2^31字节，下一次状态恢复就会失败。这是当前RocksDB JNI的局限性。</em></strong></p><p><strong><em>RocksDBStateBackend是当前唯一一种提供增量checkpoint的state backend.</em></strong></p><h2 id="restart-strategies（重启策略）"><a href="#restart-strategies（重启策略）" class="headerlink" title="restart strategies（重启策略）"></a>restart strategies（重启策略）</h2><h1 id="Event-Time"><a href="#Event-Time" class="headerlink" title="Event Time"></a>Event Time</h1><h2 id="Processing-time"><a href="#Processing-time" class="headerlink" title="Processing time"></a>Processing time</h2><p><code>flink</code> 开始处理事件的时间</p><h2 id="Event-time"><a href="#Event-time" class="headerlink" title="Event time"></a>Event time</h2><p>时间发生的原始时间，由<code>事件发生器</code>自主设置</p><h2 id="Ingestion-time"><a href="#Ingestion-time" class="headerlink" title="Ingestion time"></a>Ingestion time</h2><p><code>Flink Source</code> 接收到事件的时间</p><h1 id="operator"><a href="#operator" class="headerlink" title="operator"></a>operator</h1><h2 id="operator-lifecycle"><a href="#operator-lifecycle" class="headerlink" title="operator lifecycle"></a>operator lifecycle</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// initialization phase</span><br><span class="line">OPERATOR::setup</span><br><span class="line">    UDF::setRuntimeContext</span><br><span class="line">OPERATOR::initializeState</span><br><span class="line">OPERATOR::open</span><br><span class="line">    UDF::open</span><br><span class="line"></span><br><span class="line">// processing phase (called on every element/watermark)</span><br><span class="line">OPERATOR::processElement</span><br><span class="line">    UDF::run</span><br><span class="line">OPERATOR::processWatermark</span><br><span class="line"></span><br><span class="line">// checkpointing phase (called asynchronously on every checkpoint)</span><br><span class="line">OPERATOR::snapshotState</span><br><span class="line"></span><br><span class="line">// termination phase</span><br><span class="line">OPERATOR::close</span><br><span class="line">    UDF::close</span><br><span class="line">OPERATOR::dispose</span><br></pre></td></tr></table></figure><p><strong><em>注意：<code>initializeState()</code>包含operator state的初始化（例如register keyed state），也包含任务失败后从checkpoint中恢复state的逻辑。</em></strong></p>]]></content>
      
      <categories>
          
          <category> flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flink </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Flink 基本概念入门</title>
      <link href="/2018/11/19/%E6%8A%80%E6%9C%AF/flink/flink%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/"/>
      <url>/2018/11/19/%E6%8A%80%E6%9C%AF/flink/flink%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h1 id="Flink-基本概念"><a href="#Flink-基本概念" class="headerlink" title="Flink 基本概念"></a>Flink 基本概念</h1><h2 id="基本名词"><a href="#基本名词" class="headerlink" title="基本名词"></a>基本名词</h2><h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a><code>Job</code></h3><p>以 <code>jar</code> 包的形式在 <code>flink</code> 中提交的可运行程序</p><h3 id="task"><a href="#task" class="headerlink" title="task"></a><code>task</code></h3><h3 id="stream"><a href="#stream" class="headerlink" title="stream"></a><code>stream</code></h3><p><code>flink</code> 作为一个流数据处理的引擎，就是针对一个或多个 <code>stream</code> 进行流计算处理，再输出到一个或多个 <code>stream</code> 中去，这里的 <code>stream</code> 可以使 mq，也可以是文件、也可以直接是控制台输入\输出。</p><h3 id="operator-amp-amp-task"><a href="#operator-amp-amp-task" class="headerlink" title="operator &amp;&amp; task"></a><code>operator</code> &amp;&amp; <code>task</code></h3><p><code>flink</code> 流处理流程中的每个操作(如 <code>map</code>, <code>keyBy</code>, <code>sink</code>, <code>source</code>等)都是 <code>operator</code></p><h3 id="operator-subtask"><a href="#operator-subtask" class="headerlink" title="operator subtask"></a><code>operator subtask</code></h3><p>每个 <code>operator</code> 可以分成多个 <code>operator subtask</code>，一个 <code>operator</code> 的并行度就是 <code>operator subtask</code> 的数量</p><h3 id="operator-chain"><a href="#operator-chain" class="headerlink" title="operator chain"></a><code>operator chain</code></h3><p><code>flink</code> 作为分布式运行系统，会将多个 <code>operator subtask</code> 关联成一个 <code>operator task</code>，这个过程就是 <code>operator chain</code>。</p><p>两个 <code>operator subtask</code> 能否关联起来，需要满足下列要求</p><ol><li>上下游的并行度一致</li><li>下游节点的入度为1 （也就是说下游节点没有来自其他节点的输入）</li><li>上下游节点都在同一个 slot group 中（下面会解释 slot group）</li><li>下游节点的 chain 策略为 ALWAYS（可以与上下游链接，map、flatmap、filter等默认是ALWAYS）</li><li>上游节点的 chain 策略为 ALWAYS 或 HEAD（只能与下游链接，不能与上游链接，Source默认是HEAD）</li><li>两个节点间数据分区方式是 forward（参考理解数据流的分区）<br>用户没有禁用 chain</li></ol><h2 id="分布式运行时环境"><a href="#分布式运行时环境" class="headerlink" title="分布式运行时环境"></a>分布式运行时环境</h2><h3 id="JobManager"><a href="#JobManager" class="headerlink" title="JobManager"></a><code>JobManager</code></h3><p><code>flink</code> 集群服务的 master 节点，用来协调分布式计算，负责进行任务调度，协调 checkpoints，协调错误恢复等等。一个集群中至少有一个 <code>JobManager</code>，如果有多个 <code>JobManager</code>，其中一个作为 <code>leader</code>，其余处于备用的状态。</p><h3 id="TaskManager"><a href="#TaskManager" class="headerlink" title="TaskManager"></a><code>TaskManager</code></h3><p><code>flink</code> 集群的 worker 节点，真正执行 dataflow 中的 tasks，并且对 streams 进行缓存和交换，集群中至少需要一个 <code>TaskManager</code>，每个 <code>TaskManager</code> 是一个 JVM 进程。</p><h3 id="Clients"><a href="#Clients" class="headerlink" title="Clients"></a><code>Clients</code></h3><p>连接 <code>flink 集群</code> 的客户端，向 <code>flink 集群</code> 提交计算任务</p><h3 id="Task-Slots"><a href="#Task-Slots" class="headerlink" title="Task Slots"></a><code>Task Slots</code></h3><p>每个 <code>TaskManager</code> 都是一个 JVM 进程，可以在不同的线程运行一个或多个线程，每个 <code>TaskManager</code> 通过 <code>Task Slots</code> 来控制可以接收多少个tasks。<br>每个 <code>Task Slots</code> 代表 <code>TaskManager</code> 中一个固定的资源子集，如果 1 个 <code>TaskManager</code> 有 3 个 <code>Task Slots</code>，它会将他的内存资源划分为 3 份分配给每个 slot。<br>通过调整 <code>Task Slots</code> 的数量而调整 subtasks 之间的隔离方式。当每个 <code>TaskManager</code> 只有一个 <code>Task Slot</code> 的时候，意味着每个 <code>task group</code> 运行在独立的的JVM 中。当一个 <code>TaskManager</code> 有多个 <code>slot</code> 的时候，意味着多个 在同一 JVM 进程中的 task 将共享 TCP 链接和心跳信息，他们也能共享。</p><p>DateStream API</p><p><code>source</code>: 数据来源</p><p><code>sink</code>: 处理结果输出</p><p><code>window</code>: 窗口</p>]]></content>
      
      <categories>
          
          <category> flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flink </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>yarn 集群日常问题汇总</title>
      <link href="/2018/11/19/%E6%8A%80%E6%9C%AF/flink/yarn%E9%9B%86%E7%BE%A4%E7%BB%B4%E6%8A%A4%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2018/11/19/%E6%8A%80%E6%9C%AF/flink/yarn%E9%9B%86%E7%BE%A4%E7%BB%B4%E6%8A%A4%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<h1 id="yarn-日志"><a href="#yarn-日志" class="headerlink" title="yarn 日志"></a>yarn 日志</h1><h2 id="如何确定-yarn-日志位置"><a href="#如何确定-yarn-日志位置" class="headerlink" title="如何确定 yarn 日志位置"></a>如何确定 yarn 日志位置</h2><ol><li>当 <code>yarn.log-aggregation-enable = true</code> 时，<code>yarn</code> 集群中的 <code>application</code> 的日志将被聚合到 <code>yarn.nodemanager.remote-app-log-dir</code> 指向的目录中去，保留时间为 <code>yarn.log-aggregation.retain-seconds</code><br></li></ol><p><strong><em><code>yarn.nodemanager.remote-app-log-dir</code> 指向的目录是 hdfs 目录</em></strong></p><ol start="2"><li>当 <code>yarn.log-aggregation-enable = false</code> 时，<code>yarn</code> 集群中的 <code>application</code> 的日志将被存储到 <code>yarn.nodemanager.log-dirs</code> 属性指向的在 <code>nodemanager nodes</code> 上的文件夹中，保留时间为 <code>yarn.nodemanager.log.retain-seconds</code></li></ol><h2 id="为什么会有-application-没有日志"><a href="#为什么会有-application-没有日志" class="headerlink" title="为什么会有 application 没有日志"></a>为什么会有 application 没有日志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn application does not have any log files.</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> yarn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> yarn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Flink 安装和运行</title>
      <link href="/2018/11/19/%E6%8A%80%E6%9C%AF/flink/flink%E5%AE%89%E8%A3%85%E5%92%8C%E8%BF%90%E8%A1%8C/"/>
      <url>/2018/11/19/%E6%8A%80%E6%9C%AF/flink/flink%E5%AE%89%E8%A3%85%E5%92%8C%E8%BF%90%E8%A1%8C/</url>
      <content type="html"><![CDATA[<h1 id="Flink-安装和运行"><a href="#Flink-安装和运行" class="headerlink" title="Flink 安装和运行"></a><code>Flink</code> 安装和运行</h1><h2 id="单点安装"><a href="#单点安装" class="headerlink" title="单点安装"></a>单点安装</h2><h3 id="下载-flink-安装包"><a href="#下载-flink-安装包" class="headerlink" title="下载 flink 安装包"></a>下载 flink 安装包</h3><p>在 <a href="https://flink.apache.org/downloads.html" title="官网下载地址" target="_blank" rel="noopener">官网下载地址</a> 选择适当版本的flink 安装包，这里我选择 <code>Apache Flink 1.6.2 only</code>；下载安装包到 <code>/path/to/flink-1.6.2</code> 中</p><h3 id="解压运行-flink"><a href="#解压运行-flink" class="headerlink" title="解压运行 flink"></a>解压运行 flink</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/</span><br><span class="line">tar -xvf flink-1.6.2.tgz</span><br><span class="line"><span class="built_in">cd</span> flink-1.6.2</span><br><span class="line">sh ./bin/start-cluster.sh</span><br></pre></td></tr></table></figure><p>到这里我们就已经把 <code>单机版flink</code> 成功的运行起来了，我们可以访问 <code>localhost:8081</code> 看到 <code>flink</code> 管理页面</p><p><img src="/assets/picture/flink.single.png" alt="图片" title="单机版flink运行"></p><h2 id="flink-集群搭建准备工作"><a href="#flink-集群搭建准备工作" class="headerlink" title="flink 集群搭建准备工作"></a><code>flink</code> 集群搭建准备工作</h2><h3 id="JAVA-环境配置"><a href="#JAVA-环境配置" class="headerlink" title="JAVA 环境配置"></a>JAVA 环境配置</h3><p><strong><em>这里不赘述如何配置 JAVA 环境，只需要注意使用 JAVA 1.8+ 即可</em></strong></p><h3 id="集群机器互信"><a href="#集群机器互信" class="headerlink" title="集群机器互信"></a>集群机器互信</h3><p>不管是 <code>standalone</code> 部署模式还是依赖 <code>hadoop yarn</code> 搭建集群，都需要在集群机器之间设置互信，实现 <code>ssh</code> 相互免密登录</p><ol><li>生成<code>公钥/秘钥</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa  <span class="comment">#一直回车即可</span></span><br></pre></td></tr></table></figure><p>生成了 <code>~/.ssh/id_rsa.pub</code> 和 <code>~/.ssh/id_rsa</code></p><ol start="2"><li>公钥认证</li></ol><p>将机器A 上面的 <code>~/.ssh/id_rsa.pub</code> 追加到机器B 的公钥认证文件 <code>~/.ssh/authorized_keys</code> 里面去；<br>再将机器B 上面的 <code>~/.ssh/id_rsa.pub</code> 追加到机器A 的公钥认证文件 <code>~/.ssh/authorized_keys</code> 里面去</p><p>这样我们就可以在机器A、B之间互相免密码登陆了</p><h2 id="flink-on-yarn-集群搭建"><a href="#flink-on-yarn-集群搭建" class="headerlink" title="flink on yarn 集群搭建"></a><code>flink on yarn</code> 集群搭建</h2><p>在 <code>10.0.0.1</code>，<code>10.0.0.2</code>，<code>10.0.0.3</code> 三台机器上尝试搭建 <code>flink</code> 集群</p><h3 id="hadoop-yarn-安装配置"><a href="#hadoop-yarn-安装配置" class="headerlink" title="hadoop yarn 安装配置"></a><code>hadoop yarn</code> 安装配置</h3><h4 id="下载解压-hadoop-安装包"><a href="#下载解压-hadoop-安装包" class="headerlink" title="下载解压 hadoop 安装包"></a>下载解压 <code>hadoop</code> 安装包</h4><p>这里我用的 <code>cdh</code> 版本的 <code>hadoop</code>，可以在<a href="http://archive-primary.cloudera.com/cdh5/cdh/5/" title="hadoop cdh" target="_blank" rel="noopener">这里</a>下载，然后解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf hadoop-2.6.0-cdh5.11.0.tar.gz</span><br></pre></td></tr></table></figure><h4 id="配置-hadoop"><a href="#配置-hadoop" class="headerlink" title="配置 hadoop"></a>配置 <code>hadoop</code></h4><p>在 <code>/path/to/hadoop-2.6.0-cdh5.11.0/etc/hadoop/</code> 文件夹下配置如下七个文件 <code>hadoop-env.sh</code>，<code>yarn-env.sh</code>，<code>slaves</code>，<code>core-site.xml</code>，<code>hdfs-site.xml</code>，<code>mapred-site.xml</code>，<code>yarn-site.xml</code></p><h5 id="在-hadoop-env-sh"><a href="#在-hadoop-env-sh" class="headerlink" title="在 hadoop-env.sh"></a>在 <code>hadoop-env.sh</code></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/path/to/java/home</span><br></pre></td></tr></table></figure><h5 id="在-yarn-env-sh-中配置-JAVA-HOME"><a href="#在-yarn-env-sh-中配置-JAVA-HOME" class="headerlink" title="在 yarn-env.sh 中配置 JAVA_HOME"></a>在 <code>yarn-env.sh</code> 中配置 <code>JAVA_HOME</code></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/path/to/java/home</span><br></pre></td></tr></table></figure><h5 id="在-slaves-中配置-slave-节点的ip-或者host"><a href="#在-slaves-中配置-slave-节点的ip-或者host" class="headerlink" title="在 slaves 中配置 slave 节点的ip 或者host"></a>在 <code>slaves</code> 中配置 slave 节点的ip 或者host</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10.0.0.2</span><br><span class="line">10.0.0.3</span><br></pre></td></tr></table></figure><h5 id="修改-core-site-xml"><a href="#修改-core-site-xml" class="headerlink" title="修改 core-site.xml"></a>修改 <code>core-site.xml</code></h5><p>配置 <code>hadoop</code> 集群文件系统主机和端口、<code>hadoop</code> 临时目录</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- hadoop文件系统主机和端口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://10.0.0.1:9000/<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置 hadoop 临时目录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/path/to/hadoop-2.6.0-cdh5.11.0/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="修改-hdfs-site-xml"><a href="#修改-hdfs-site-xml" class="headerlink" title="修改 hdfs-site.xml"></a>修改 <code>hdfs-site.xml</code></h5><p>配置 <code>hadoop</code> 集群文件系统主机和端口、<code>hadoop</code> 临时目录</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- hadoop文件系统主机和端口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://10.0.0.1:9000/<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置 hadoop 临时目录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/path/to/hadoop-2.6.0-cdh5.11.0/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="standalone-部署模式集群搭建"><a href="#standalone-部署模式集群搭建" class="headerlink" title="standalone 部署模式集群搭建"></a><code>standalone</code> 部署模式集群搭建</h2><p>举例说明，搭建</p><h3 id="下载、解压安装包"><a href="#下载、解压安装包" class="headerlink" title="下载、解压安装包"></a>下载、解压安装包</h3><h3 id="修改-flink-conf-yaml-文件配置"><a href="#修改-flink-conf-yaml-文件配置" class="headerlink" title="修改 flink-conf.yaml 文件配置"></a>修改 <code>flink-conf.yaml</code> 文件配置</h3><p>修改 <code>/path/to/flink-1.6.2/conf</code> 文件中的 <code>flink-conf.yaml</code> 文件，参数说明如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># java安装路径，如果没有指定则默认使用系统的$JAVA_HOME环境变量。建议设置此值，因为之前我曾经在standalone模式中启动flink集群，报找不到JAVA_HOME的错误。config.sh中（Please specify JAVA_HOME. Either in Flink config ./conf/flink-conf.yaml or as system-wide JAVA_HOME.）</span></span><br><span class="line"><span class="string">env.java.home:</span> <span class="string">/path/to/java/home</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定制JVM选项，在Flink启动脚本中执行。需要单独执行JobManager和TaskManager的选项。</span></span><br><span class="line"><span class="string">env.java.opts:</span> <span class="bullet">-DXms=1024MB</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行jobManager的JVM选项。在Yarn Client环境下此参数无效。</span></span><br><span class="line"><span class="string">env.java.opts.jobmanager:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行taskManager的JVM选项。在Yarn Client环境下此参数无效。</span></span><br><span class="line"><span class="string">env.java.opts.taskmanager:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Jobmanager的IP地址，即master地址。默认是localhost，此参数在HA环境下或者Yarn下无效，仅在local和无HA的standalone集群中有效。</span></span><br><span class="line"><span class="string">jobmanager.rpc.address:</span> <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JobMamanger的端口，默认是6123。</span></span><br><span class="line"><span class="string">jobmanager.rpc.port:</span> <span class="number">6123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JobManager的堆大小（单位是MB）。当长时间运行operator非常多的程序时，需要增加此值。具体设置多少只能通过测试不断调整。</span></span><br><span class="line"><span class="string">jobmanager.heap.mb:</span> <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每一个TaskManager的堆大小（单位是MB），由于每个taskmanager要运行operator的各种函数（Map、Reduce、CoGroup等，包含sorting、hashing、caching），因此这个值应该尽可能的大。如果集群仅仅跑Flink的程序，建议此值等于机器的内存大小减去1、2G，剩余的1、2GB用于操作系统。如果是Yarn模式，这个值通过指定tm参数来分配给container，同样要减去操作系统可以容忍的大小（1、2GB）。</span></span><br><span class="line"><span class="string">taskmanager.heap.mb:</span> <span class="number">8196</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个TaskManager的并行度。一个slot对应一个core，默认值是1.一个并行度对应一个线程。总的内存大小要且分给不同的线程使用。</span></span><br><span class="line"><span class="string">taskmanager.numberOfTaskSlots:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个operator的默认并行度。默认是1.如果程序中对operator设置了setParallelism，或者提交程序时指定了-p参数，则会覆盖此参数。如果只有一个Job运行时，此值可以设置为taskManager的数量 * 每个taskManager的slots数量。即NumTaskManagers  * NumSlotsPerTaskManager 。</span></span><br><span class="line"><span class="string">parallelism.default:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认的文件系统模式。默认值是file:///即本地文件系统根目录。如果指定了hdfs://localhost:9000/，则程序中指定的文件/user/USERNAME/in.txt，即指向了hdfs://localhost:9000/user/USERNAME/in.txt。这个值仅仅当没有其他schema被指定时生效。一般hadoop中core-site.xml中都会配置fs.default.name。</span></span><br><span class="line"><span class="string">fs.default-scheme:</span> <span class="attr">hdfs://localhost:9000/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HDFS的配置路径。例如：/home/flink/hadoop/hadoop-2.6.0/etc/hadoop。如果配置了这个值，用户程序中就可以简写hdfs路径如：hdfs:///path/to/files。而不用写成：hdfs://address:port/path/to/files这种格式。配置此参数后，Flink就可以找到此路径下的core-site.xml和hdfs-site.xml了。建议配置此参数。</span></span><br><span class="line"><span class="string">fs.hdfs.hadoopconf:</span> <span class="string">/home/flink/hadoop/hadoop-2.6.0/etc/hadoop</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># flink 服务的 http 端口</span></span><br><span class="line"><span class="string">rest.port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure><h2 id="flink-on-Yarn"><a href="#flink-on-Yarn" class="headerlink" title="flink on Yarn"></a>flink on Yarn</h2><h3 id="启动-yarn-session-运行-flink-job"><a href="#启动-yarn-session-运行-flink-job" class="headerlink" title="启动 yarn session 运行 flink job"></a>启动 yarn session 运行 flink job</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/yarn-session.sh -n 4 -jm 1024 -tm 4096 -s 32</span><br></pre></td></tr></table></figure><h4 id="yarn-session-sh-使用说明"><a href="#yarn-session-sh-使用说明" class="headerlink" title="yarn-session.sh 使用说明"></a><code>yarn-session.sh</code> 使用说明</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">   Required</span><br><span class="line">     -n,--container &lt;arg&gt;   Number of YARN container to allocate (=Number of Task Managers)</span><br><span class="line">   Optional</span><br><span class="line">     -D &lt;property=value&gt;             use value for given property</span><br><span class="line">     -d,--detached                   If present, runs the job in detached mode</span><br><span class="line">     -h,--help                       Help for the Yarn session CLI.</span><br><span class="line">     -id,--applicationId &lt;arg&gt;       Attach to running YARN session</span><br><span class="line">     -j,--jar &lt;arg&gt;                  Path to Flink jar file</span><br><span class="line">     -jm,--jobManagerMemory &lt;arg&gt;    Memory for JobManager Container with optional unit (default: MB)</span><br><span class="line">     -m,--jobmanager &lt;arg&gt;           Address of the JobManager (master) to which to connect. Use this flag to connect to a different JobManager than the one specified in the configuration.</span><br><span class="line">     -n,--container &lt;arg&gt;            Number of YARN container to allocate (=Number of Task Managers)</span><br><span class="line">     -nl,--nodeLabel &lt;arg&gt;           Specify YARN node label for the YARN application</span><br><span class="line">     -nm,--name &lt;arg&gt;                Set a custom name for the application on YARN</span><br><span class="line">     -q,--query                      Display available YARN resources (memory, cores)</span><br><span class="line">     -qu,--queue &lt;arg&gt;               Specify YARN queue.</span><br><span class="line">     -s,--slots &lt;arg&gt;                Number of slots per TaskManager</span><br><span class="line">     -sae,--shutdownOnAttachedExit   If the job is submitted in attached mode, perform a best-effort cluster shutdown when the CLI is terminated abruptly, e.g., in response to a user interrupt, such</span><br><span class="line">                                     as typing Ctrl + C.</span><br><span class="line">     -st,--streaming                 Start Flink in streaming mode</span><br><span class="line">     -t,--ship &lt;arg&gt;                 Ship files in the specified directory (t for transfer)</span><br><span class="line">     -tm,--taskManagerMemory &lt;arg&gt;   Memory per TaskManager Container with optional unit (default: MB)</span><br><span class="line">     -yd,--yarndetached              If present, runs the job in detached mode (deprecated; use non-YARN specific option instead)</span><br><span class="line">     -z,--zookeeperNamespace &lt;arg&gt;   Namespace to create the Zookeeper sub-paths for high availability mode</span><br></pre></td></tr></table></figure><h4 id="yarn-会话管理"><a href="#yarn-会话管理" class="headerlink" title="yarn 会话管理"></a><code>yarn</code> 会话管理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$yarn</span> application --<span class="built_in">help</span></span><br><span class="line">usage: application</span><br><span class="line"> -appStates &lt;States&gt;             Works with -list to filter applications</span><br><span class="line">                                 based on input comma-separated list of</span><br><span class="line">                                 application states. The valid application</span><br><span class="line">                                 state can be one of the following:</span><br><span class="line">                                 ALL,NEW,NEW_SAVING,SUBMITTED,ACCEPTED,RUN</span><br><span class="line">                                 NING,FINISHED,FAILED,KILLED</span><br><span class="line"> -appTypes &lt;Types&gt;               Works with -list to filter applications</span><br><span class="line">                                 based on input comma-separated list of</span><br><span class="line">                                 application types.</span><br><span class="line"> -<span class="built_in">help</span>                           Displays <span class="built_in">help</span> <span class="keyword">for</span> all commands.</span><br><span class="line"> -<span class="built_in">kill</span> &lt;Application ID&gt;          Kills the application.</span><br><span class="line"> -list                           List applications. Supports optional use</span><br><span class="line">                                 of -appTypes to filter applications based</span><br><span class="line">                                 on application <span class="built_in">type</span>, and -appStates to</span><br><span class="line">                                 filter applications based on application</span><br><span class="line">                                 state.</span><br><span class="line"> -movetoqueue &lt;Application ID&gt;   Moves the application to a different</span><br><span class="line">                                 queue.</span><br><span class="line"> -queue &lt;Queue Name&gt;             Works with the movetoqueue <span class="built_in">command</span> to</span><br><span class="line">                                 specify <span class="built_in">which</span> queue to move an</span><br><span class="line">                                 application to.</span><br><span class="line"> -status &lt;Application ID&gt;        Prints the status of the application.</span><br></pre></td></tr></table></figure><h3 id="直接提交-flink-job-到-yarn-集群"><a href="#直接提交-flink-job-到-yarn-集群" class="headerlink" title="直接提交 flink job 到 yarn 集群"></a>直接提交 flink job 到 yarn 集群</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/flink run -m yarn-cluster -yn 2 -yjm 1024 -ytm 1024 ./examples/batch/WordCount.jar</span><br></pre></td></tr></table></figure><h4 id="yarn-日常维护"><a href="#yarn-日常维护" class="headerlink" title="yarn 日常维护"></a><code>yarn</code> 日常维护</h4><h5 id="查看-yarn-session-中的-flink-job"><a href="#查看-yarn-session-中的-flink-job" class="headerlink" title="查看 yarn session 中的 flink job"></a>查看 <code>yarn session</code> 中的 flink job</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/flink list -m yarn-cluster -yid &lt;Yarn Application Id&gt; -r</span><br></pre></td></tr></table></figure><h5 id="yarn-日志查看"><a href="#yarn-日志查看" class="headerlink" title="yarn 日志查看"></a><code>yarn</code> 日志查看</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn logs -applicationId &lt;applicationId&gt;</span><br></pre></td></tr></table></figure><h5 id="yarn-application-下线"><a href="#yarn-application-下线" class="headerlink" title="yarn application 下线"></a><code>yarn application</code> 下线</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn application -<span class="built_in">kill</span> &lt;applicationId&gt;</span><br></pre></td></tr></table></figure><h5 id="触发-savepoints-取消-flink-job"><a href="#触发-savepoints-取消-flink-job" class="headerlink" title="触发 savepoints 取消 flink job"></a>触发 <code>savepoints</code> 取消 flink job</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/flink cancel -s [savepointDirectory] &lt;jobID&gt;</span><br></pre></td></tr></table></figure><p>执行上述指令将得到如下提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cancelling job &lt;jobID&gt; with savepoint to &lt;savepointDirectory&gt;.</span><br><span class="line">Cancelled job &lt;jobID&gt;. Savepoint stored in &lt;savepointDirectory&gt;/&lt;savepointID&gt;.</span><br></pre></td></tr></table></figure><h5 id="从-savepoints-恢复启动-flink-job"><a href="#从-savepoints-恢复启动-flink-job" class="headerlink" title="从 savepoints 恢复启动 flink job"></a>从 <code>savepoints</code> 恢复启动 flink job</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/flink run -s &lt;savepointDirectory&gt;/&lt;savepointID&gt; -m yarn-cluster -yn 2 -yjm 1024 -ytm 1024 ./examples/batch/WordCount.jar</span><br></pre></td></tr></table></figure><p><strong><em>这里 <code>-s</code> 参数值是执行<code>cancel</code> 指令的时候得到的 savepoint 保存地址&lt;savepointDirectory&gt;/&lt;savepointID&gt;</em></strong></p><h4 id="flink-run-指令"><a href="#flink-run-指令" class="headerlink" title="flink run 指令"></a><code>flink run</code> 指令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">$./bin/flink run --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Action <span class="string">"run"</span> compiles and runs a program.</span><br><span class="line"></span><br><span class="line">  Syntax: run [OPTIONS] &lt;jar-file&gt; &lt;arguments&gt;</span><br><span class="line">  <span class="string">"run"</span> action options:</span><br><span class="line">     -c,--class &lt;classname&gt;               当 flink job 的 jar包中没有指定 mainfest 时，通过这个                                   </span><br><span class="line">                                          参数来指定包含 main() 方法，或者 getPlan() 方法的主类。</span><br><span class="line">     -C,--classpath &lt;url&gt;                 新增 flink 类加载器的</span><br><span class="line">                                          Adds a URL to each user code</span><br><span class="line">                                          classloader  on all nodes <span class="keyword">in</span> the</span><br><span class="line">                                          cluster. The paths must specify a</span><br><span class="line">                                          protocol (e.g. file://) and be</span><br><span class="line">                                          accessible on all nodes (e.g. by means</span><br><span class="line">                                          of a NFS share). You can use this</span><br><span class="line">                                          option multiple <span class="built_in">times</span> <span class="keyword">for</span> specifying</span><br><span class="line">                                          more than one URL. The protocol must</span><br><span class="line">                                          be supported by the &#123;@link</span><br><span class="line">                                          java.net.URLClassLoader&#125;.</span><br><span class="line">     -d,--detached                        以后台模式运行 flink job</span><br><span class="line">     -n,--allowNonRestoredState           Allow to skip savepoint state that</span><br><span class="line">                                          cannot be restored. You need to allow</span><br><span class="line">                                          this <span class="keyword">if</span> you removed an operator from</span><br><span class="line">                                          your program that was part of the</span><br><span class="line">                                          program when the savepoint was</span><br><span class="line">                                          triggered.</span><br><span class="line">     -p,--parallelism &lt;parallelism&gt;       The parallelism with <span class="built_in">which</span> to run the</span><br><span class="line">                                          program. Optional flag to override the</span><br><span class="line">                                          default value specified <span class="keyword">in</span> the</span><br><span class="line">                                          configuration.</span><br><span class="line">     -q,--sysoutLogging                   If present, suppress logging output to</span><br><span class="line">                                          standard out.</span><br><span class="line">     -s,--fromSavepoint &lt;savepointPath&gt;   Path to a savepoint to restore the job</span><br><span class="line">                                          from (<span class="keyword">for</span> example</span><br><span class="line">                                          hdfs:///flink/savepoint-1537).</span><br><span class="line">     -sae,--shutdownOnAttachedExit        If the job is submitted <span class="keyword">in</span> attached</span><br><span class="line">                                          mode, perform a best-effort cluster</span><br><span class="line">                                          shutdown when the CLI is terminated</span><br><span class="line">                                          abruptly, e.g., <span class="keyword">in</span> response to a user</span><br><span class="line">                                          interrupt, such as typing Ctrl + C.</span><br><span class="line">  Options <span class="keyword">for</span> yarn-cluster mode:</span><br><span class="line">     -d,--detached                        If present, runs the job <span class="keyword">in</span> detached</span><br><span class="line">                                          mode</span><br><span class="line">     -m,--jobmanager &lt;arg&gt;                Address of the JobManager (master) to</span><br><span class="line">                                          <span class="built_in">which</span> to connect. Use this flag to</span><br><span class="line">                                          connect to a different JobManager than</span><br><span class="line">                                          the one specified <span class="keyword">in</span> the</span><br><span class="line">                                          configuration.</span><br><span class="line">     -sae,--shutdownOnAttachedExit        If the job is submitted <span class="keyword">in</span> attached</span><br><span class="line">                                          mode, perform a best-effort cluster</span><br><span class="line">                                          shutdown when the CLI is terminated</span><br><span class="line">                                          abruptly, e.g., <span class="keyword">in</span> response to a user</span><br><span class="line">                                          interrupt, such as typing Ctrl + C.</span><br><span class="line">     -yD &lt;property=value&gt;                 use value <span class="keyword">for</span> given property</span><br><span class="line">     -yd,--yarndetached                   If present, runs the job <span class="keyword">in</span> detached</span><br><span class="line">                                          mode (deprecated; use non-YARN</span><br><span class="line">                                          specific option instead)</span><br><span class="line">     -yh,--yarnhelp                       Help <span class="keyword">for</span> the Yarn session CLI.</span><br><span class="line">     -yid,--yarnapplicationId &lt;arg&gt;       Attach to running YARN session</span><br><span class="line">     -yj,--yarnjar &lt;arg&gt;                  Path to Flink jar file</span><br><span class="line">     -yjm,--yarnjobManagerMemory &lt;arg&gt;    JobManager Container 的内存大小，默认单位是 MB</span><br><span class="line">     -yn,--yarncontainer &lt;arg&gt;            指定分配的 yarn container 的数量，等同于 flink Task Managers 的数量</span><br><span class="line">     -ynl,--yarnnodeLabel &lt;arg&gt;           Specify YARN node label <span class="keyword">for</span> the YARN</span><br><span class="line">                                          application</span><br><span class="line">     -ynm,--yarnname &lt;arg&gt;                Set a custom name <span class="keyword">for</span> the application</span><br><span class="line">                                          on YARN</span><br><span class="line">     -yq,--yarnquery                      Display available YARN resources</span><br><span class="line">                                          (memory, cores)</span><br><span class="line">     -yqu,--yarnqueue &lt;arg&gt;               Specify YARN queue.</span><br><span class="line">     -ys,--yarnslots &lt;arg&gt;                Number of slots per TaskManager</span><br><span class="line">     -yst,--yarnstreaming                 Start Flink <span class="keyword">in</span> streaming mode</span><br><span class="line">     -yt,--yarnship &lt;arg&gt;                 Ship files <span class="keyword">in</span> the specified directory</span><br><span class="line">                                          (t <span class="keyword">for</span> transfer)</span><br><span class="line">     -ytm,--yarntaskManagerMemory &lt;arg&gt;   单个 taskManager 的内存大小，默认单位是 MB</span><br><span class="line">     -yz,--yarnzookeeperNamespace &lt;arg&gt;   Namespace to create the Zookeeper</span><br><span class="line">                                          sub-paths <span class="keyword">for</span> high availability mode</span><br><span class="line">     -z,--zookeeperNamespace &lt;arg&gt;        Namespace to create the Zookeeper</span><br><span class="line">                                          sub-paths <span class="keyword">for</span> high availability mode</span><br><span class="line"></span><br><span class="line">  Options <span class="keyword">for</span> default mode:</span><br><span class="line">     -m,--jobmanager &lt;arg&gt;           Address of the JobManager (master) to <span class="built_in">which</span></span><br><span class="line">                                     to connect. Use this flag to connect to a</span><br><span class="line">                                     different JobManager than the one specified</span><br><span class="line">                                     <span class="keyword">in</span> the configuration.</span><br><span class="line">     -z,--zookeeperNamespace &lt;arg&gt;   Namespace to create the Zookeeper sub-paths</span><br><span class="line">                                     <span class="keyword">for</span> high availability mode</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flink </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Tomcat 日志配置说明</title>
      <link href="/2018/09/28/%E6%8A%80%E6%9C%AF/tomcat/tomcat%E7%9A%84%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/09/28/%E6%8A%80%E6%9C%AF/tomcat/tomcat%E7%9A%84%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>日志应该是除了代码之外，程序员最好的朋友了，它可以帮助我们定位问题、修复bug，或者是确认服务是否正常运转；很多时候我们做一次部署只是为了加几行日志；</p><p>而 <code>Tomcat</code> 作为经久畅销的web 服务器，一直是web 开发者首选，而 <code>Tomcat</code> 的原生日志是我们判断这个服务器是否正常运转的重要数据。</p><h3 id="Java-日志组件"><a href="#Java-日志组件" class="headerlink" title="Java 日志组件"></a>Java 日志组件</h3><p>这里我们按照历史顺序简单介绍一下 <code>Java</code> 常用的日志组件，</p><p><code>JUL</code>(Java Util Logging): 是 <code>jdk</code> 自带的log 实现组件，虽然是官方出品但是它并没有被广泛使用，主要是下面几个原因</p><ol><li><code>JUL</code> 出现的太晚了，2002年它才被放到 <code>jdk1.4</code> 中，当时已经有很多第三方的日志组件被广泛使用了</li><li><code>JUL</code> 早期性能问题太明显，到 <code>JDK1.5</code> 才有所改善，但是它和其他第三方日志组件<code>logback</code>或<code>log4j2</code>相比也还是有差距</li><li><code>JUL</code> 提供的功能不如第三方组件<code>logback</code>或<code>log4j2</code>完善</li></ol><p><code>log4j</code> 是在 <code>logback</code> 之前被广泛使用的日志实现组件，<code>log4j</code> 在设计上十分优秀，对后期的<code>Java</code> 日志框架有深远的影响，但是它在性能上存在缺陷；<code>logback</code> 出现之后就取代了 <code>log4j</code></p><p><code>JCL</code>(Apache Commons Logging): apache 提出的 <code>Log Facade</code>，只提供日志api，不提供实现，通过不同的 Adapter 来使用 <code>JUL</code> 或者 <code>log4j</code>；在打印日志的时候调用的都是 <code>JCL</code> 指定的api ，具体实现是看当前的 <code>classpath</code> 中有什么实现，如果什么都没有</p><p><code>slf4j</code>(The Simple Logging Facade For Java): <code>slf4j</code> 是 <code>Ceki Gülcü</code> 开发的 <code>Log Facade</code>，主要是因为<code>Ceki Gülcü</code> 觉得作为日志统一接口的 <code>JCL</code> 设计的不合理：<br></p><p>下面这种写法不管是否输出 <code>debug</code> 级别的时候都需要做一次字符串拼接，如果这种代码被反复调用就会产生很多无用的字符串拼接，影响性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">"log:"</span> + log);</span><br></pre></td></tr></table></figure><p>而官方给出的最佳时间方式是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">  logger.debug(<span class="string">"log:"</span> + log);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么看都是反人类的设计，所以在 <code>slf4j</code> 中，设计的api 是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">"log:&#123;&#125;"</span>, log);</span><br></pre></td></tr></table></figure><p><code>logback</code>: <code>logback</code> 也是<code>Ceki Gülcü</code> 开发的日志实现，在 <code>log4j</code> 的基础上进行了改进，提供了更好的性能实现，异步logger，Filter 等更能多的特性。</p><p><code>Ceki Gülcü</code> 给我们开发了很好用的日志组件，但是现在有了两个 <code>Log Facade</code> 和三个流行的 <code>Log Implementation</code>，事情变的复杂了；<code>Ceki Gülcü</code> 作为一个完美主义者，为了我们能在不同的log 之间自由切换，他又开发了各种 <code>Adapater</code> 和 <code>Bridge</code> 来连接，这里盗用一张 <code>slf4j</code> 官网的图片</p><p><img src="/assets/picture/slf4j_over.png" alt="图片" title="slf4j 桥接其他日志api关系图"></p><p><code>log4j2</code>: <code>log4j2</code> 的开发维护人员不想看着 <code>log4j</code> 被 <code>slf4j/logback</code> 所取代，在设计上很大程度的模仿了 <code>slf4j/logback</code>，完全脱离<code>log4j1.x</code>，在性能上实现了很大的提升，作为一个高仿品这里不多介绍。</p><h3 id="Tomcat-的日志实现方法"><a href="#Tomcat-的日志实现方法" class="headerlink" title="Tomcat 的日志实现方法"></a><code>Tomcat</code> 的日志实现方法</h3><p><code>Tomcat</code> 内部整合的日志模块是 <code>JULI</code>，<code>JULI</code>是从 <code>JCL</code> fork 过来的一个重命名分支，默认被硬编码使用 <code>JUL</code> 作为日志实现，从而保证 <code>Tomcat</code> 本身的日志和业务日志实现完美隔离。<br>而<code>Tomcat</code>的日志的配置文件默认位置是 <code>${catalina.base}/conf/logging.properties</code>，如果无法读取或不存在的时候，就会去找<code>${java.home}/lib/logging.properties</code>；在web应用的范围内也有一个日志配置文件 <code>WEB-INF/classes/logging.properties</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"># Licensed to the Apache Software Foundation (ASF) under one or more</span><br><span class="line"># contributor license agreements.  See the NOTICE file distributed with</span><br><span class="line"># this work for additional information regarding copyright ownership.</span><br><span class="line"># The ASF licenses this file to You under the Apache License, Version 2.0</span><br><span class="line"># (the &quot;License&quot;); you may not use this file except in compliance with</span><br><span class="line"># the License.  You may obtain a copy of the License at</span><br><span class="line">#</span><br><span class="line">#     http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line">#</span><br><span class="line"># Unless required by applicable law or agreed to in writing, software</span><br><span class="line"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"># See the License for the specific language governing permissions and</span><br><span class="line"># limitations under the License.</span><br><span class="line"></span><br><span class="line">## 全局申明，tomcat 可以使用的 Handler</span><br><span class="line">handlers = 1catalina.org.apache.juli.FileHandler, 2localhost.org.apache.juli.FileHandler, 3manager.org.apache.juli.FileHandler, 4host-manager.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler</span><br><span class="line"></span><br><span class="line">## 在</span><br><span class="line">.handlers = 1catalina.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler</span><br><span class="line"></span><br><span class="line">############################################################</span><br><span class="line"># Handler specific properties.</span><br><span class="line"># Describes specific configuration info for Handlers.</span><br><span class="line">############################################################</span><br><span class="line"></span><br><span class="line">## catalina.out catalina.yyyy-MM-dd.log 日志的级别、日志文件位置、日志文件名称前缀配置</span><br><span class="line">1catalina.org.apache.juli.FileHandler.level = FINE</span><br><span class="line">1catalina.org.apache.juli.FileHandler.directory = $&#123;catalina.base&#125;/logs</span><br><span class="line">1catalina.org.apache.juli.FileHandler.prefix = catalina.</span><br><span class="line"></span><br><span class="line">## localhost.yyyy-MM-dd.log 日志的级别、日志文件位置、日志文件名称前缀配置</span><br><span class="line">2localhost.org.apache.juli.FileHandler.level = FINE</span><br><span class="line">2localhost.org.apache.juli.FileHandler.directory = $&#123;catalina.base&#125;/logs</span><br><span class="line">2localhost.org.apache.juli.FileHandler.prefix = localhost.</span><br><span class="line"></span><br><span class="line">## manager.yyyy-MM-dd.log 日志的级别、日志文件位置、日志文件名称前缀配置</span><br><span class="line">3manager.org.apache.juli.FileHandler.level = FINE</span><br><span class="line">3manager.org.apache.juli.FileHandler.directory = $&#123;catalina.base&#125;/logs</span><br><span class="line">3manager.org.apache.juli.FileHandler.prefix = manager.</span><br><span class="line"></span><br><span class="line">## host-manager.yyyy-MM-dd.log 日志的级别、日志文件位置、日志文件名称前缀配置</span><br><span class="line">4host-manager.org.apache.juli.FileHandler.level = FINE</span><br><span class="line">4host-manager.org.apache.juli.FileHandler.directory = $&#123;catalina.base&#125;/logs</span><br><span class="line">4host-manager.org.apache.juli.FileHandler.prefix = host-manager.</span><br><span class="line"></span><br><span class="line">## console 日志级别及格式设置</span><br><span class="line">java.util.logging.ConsoleHandler.level = FINE</span><br><span class="line">java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">############################################################</span><br><span class="line"># Facility specific properties.</span><br><span class="line"># Provides extra control for each logger.</span><br><span class="line">############################################################</span><br><span class="line"></span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].level = INFO</span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].handlers = 2localhost.org.apache.juli.FileHandler</span><br><span class="line"></span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/manager].level = INFO</span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/manager].handlers = 3manager.org.apache.juli.FileHandler</span><br><span class="line"></span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/host-manager].level = INFO</span><br><span class="line">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/host-manager].handlers = 4host-manager.org.apache.juli.FileHandler</span><br><span class="line"></span><br><span class="line"># For example, set the org.apache.catalina.util.LifecycleBase logger to log</span><br><span class="line"># each component that extends LifecycleBase changing state:</span><br><span class="line">#org.apache.catalina.util.LifecycleBase.level = FINE</span><br><span class="line"></span><br><span class="line"># To see debug messages in TldLocationsCache, uncomment the following line:</span><br><span class="line">#org.apache.jasper.compiler.TldLocationsCache.level = FINE</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
            <tag> Java Web </tag>
            
            <tag> log </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HBase 简介和使用 Sqoop 同步 Mysql 数据到 HBase</title>
      <link href="/2018/08/26/%E6%8A%80%E6%9C%AF/hbase/hbase-sqoop/"/>
      <url>/2018/08/26/%E6%8A%80%E6%9C%AF/hbase/hbase-sqoop/</url>
      <content type="html"><![CDATA[<h3 id="HBase-数据模型"><a href="#HBase-数据模型" class="headerlink" title="HBase 数据模型"></a><code>HBase</code> 数据模型</h3><h4 id="Namespace-命名空间"><a href="#Namespace-命名空间" class="headerlink" title="Namespace: 命名空间"></a><code>Namespace</code>: 命名空间</h4><p>类似于关系型数据库中的 <code>database schema</code></p><h4 id="Table-表"><a href="#Table-表" class="headerlink" title="Table: 表"></a><code>Table</code>: 表</h4><p>一个 <code>Namespace</code> 下有多个表，一个表可以包含多个行</p><h4 id="Row-行"><a href="#Row-行" class="headerlink" title="Row: 行"></a><code>Row</code>: 行</h4><p>在 <code>HBase</code> 中 <code>Row</code> 由一个 <code>Row Key</code> 和一个或多个列及其值组成，数据值的存储按照 <code>Row Key</code> 的字典顺序存储的。</p><h4 id="Column-列"><a href="#Column-列" class="headerlink" title="Column: 列"></a><code>Column</code>: 列</h4><p>在 <code>HBase</code> 中， 每个列有它所属的 <code>Column Family(列簇)</code>， 以及<code>Column Qualifier(列修饰符)</code>, 列名组成是 <code>Column Family:Column Qualifier</code></p><h4 id="Column-Family-列簇"><a href="#Column-Family-列簇" class="headerlink" title="Column Family: 列簇"></a><code>Column Family</code>: 列簇</h4><p>在 <code>HBase</code> 中将列进行分类，每个列都有它所属的<code>列簇</code>，<code>列簇</code> 把列和相应的值物理上联合在一起。创建表的时候，必须指定至少一个 <code>列簇</code>。每个列出是一个存储属性的集合，</p><h4 id="Column-Qualifier-列修饰符"><a href="#Column-Qualifier-列修饰符" class="headerlink" title="Column Qualifier: 列修饰符"></a><code>Column Qualifier</code>: 列修饰符</h4><p><code>列簇</code> 和 <code>列修饰符</code> 才是实际意义上的列唯一标识，假设存在 <code>列簇</code> content, 可以存在 <code>列修饰符</code> xml, 组成一个唯一的列标识 <code>content:xml</code>；创建表的时候，<code>列簇</code> 已经被指定了，但是 <code>列修饰符</code> 是可变的，可以再 <code>put</code> 指令中随意指定属于 <code>列簇</code> 的 <code>列修饰符</code>。</p><h4 id="Cell"><a href="#Cell" class="headerlink" title="Cell"></a><code>Cell</code></h4><p>一个Cell是行，列簇和列修饰符的组合，并且包含一个值和时间戳，时间戳代表着值的版本。</p><h4 id="Timestamp（时间戳）"><a href="#Timestamp（时间戳）" class="headerlink" title="Timestamp（时间戳）"></a><code>Timestamp</code>（时间戳）</h4><p>一个时间戳是连同值一起被写入的，是值版本的唯一标识，默认情况下，时间戳表示数据写入时RegionServer的时间，但是当你在写数据到Cell的时候，你可以指定一个不同的时间戳。</p><h3 id="HBase-常用指令"><a href="#HBase-常用指令" class="headerlink" title="HBase 常用指令"></a><code>HBase</code> 常用指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> create_namespace <span class="string">'n1'</span> //  创建一个 namespace n1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> list_namespace        //  列出所有的 namespace</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> create <span class="string">'n1:t1'</span>, <span class="string">'CF1'</span>, <span class="string">'CF2'</span> // 创建表 t1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> list_namespace_tables <span class="string">'n1'</span>   // 列出 namespace n1 下的所有 table</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> describe <span class="string">'n1:t1'</span>      //  查看表结构</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> put <span class="string">'n1:t1'</span>, <span class="string">'rk'</span>, <span class="string">'CF1:name'</span>, <span class="string">'test'</span> // 往表 n1:t1 中 row key 是 rk 的行中插入列名称是 CF1:name 的值 <span class="string">'test'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> get <span class="string">'n1:t1'</span>, <span class="string">'rk'</span> // 获取表 <span class="string">'n1:t1'</span> 中 row key 是 rk 的所有数据</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> scan <span class="string">'n1:t1'</span>      // 模糊查看表 n1:t1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> scan <span class="string">'n1:t1'</span>, FILTER=&gt;<span class="string">"ColumnPrefixFilter('name') AND ValueFilter(=,'substring:test')"</span>  // 模糊查询，列修饰符前缀为name 且值中包含字段 <span class="built_in">test</span> 的数据</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> delete <span class="string">'n1:t1'</span>, <span class="string">'rk'</span>, <span class="string">'CF1:name'</span> // 删除 row key 是 rk 列 `CF1:name` 的数据</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">disable</span> <span class="string">'n1:t1'</span>      // 禁用表 n1:t1，被被删除之前必须先被禁用</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> is_enabled <span class="string">'n1:t1'</span>   // 查看表 n1:t1 是否可用</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> is_disabled <span class="string">'n1:t1'</span>  // 查看表 n1:t1 是否被禁用</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">enable</span> <span class="string">'n1:t1'</span>       // 启用表 n1:t1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> drop <span class="string">'n1:t1'</span>         // 删除表 n1:t1，注意：只能删除被禁用的表</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> drop_namespace <span class="string">'n1'</span>  // 删除命名空间 n1，注意：只能删除没有表的 namespace</span></span><br></pre></td></tr></table></figure><h3 id="sqoop-导出-mysql-数据到-HBase"><a href="#sqoop-导出-mysql-数据到-HBase" class="headerlink" title="sqoop 导出 mysql 数据到 HBase"></a><code>sqoop</code> 导出 <code>mysql</code> 数据到 <code>HBase</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HADOOP_CLASSPATH=/absolute/path/to/mysql-connector-java-5.1.15.jar  </span><br><span class="line">sqoop import --connect jdbc:mysql://ip:port/database_name --username 'username' --password 'password' --table 'table_name' --columns "id,name,code,description" --hbase-table 'test:hbase_table_name' --hbase-create-table --hbase-row-key 'id,code' --column-family info</span><br></pre></td></tr></table></figure><p>上述命令行解析</p><ol><li><p>设置 <code>HADOOP_CLASSPATH</code><br><br>首先需要设置 <code>HADOOP_CLASSPATH</code>，值是 <code>mysql-connector-java-5.1.15.jar</code> 的绝对路径，否则会报错：<code>java.lang.RuntimeException: Could not load db driver class: com.mysql.jdbc.Driver</code></p></li><li><p><code>--connect</code><br><br>连接数据库的url，从这个数据库中导出数据</p></li><li><p><code>--username</code><br><br>数据库用户名</p></li><li><p><code>--password</code><br><br>数据库密码</p></li><li><p><code>--table</code><br><br>导出数据的源数据库表</p></li><li><p><code>--columns</code><br><br>本次导出的数据，可以一次导出多列，用逗号分隔，导出的列在hbase 中属于 <code>--column family</code> 参数指定的列簇，列名称是  <code>column family:mysql表中的列名</code>，需要注意的是，如果没有指定参数 <code>--hbase-row-key</code>，在hbase 表中的row key 将是 <code>--columns</code> 中第一列。</p></li><li><p><code>--hbase-table</code><br><br>本次导入数据的 hbase 表，需要注意的是导入数据的hbase 表可以不存在，但是hbase 表所属的 namespace 必须是存在的，否则会报错：<br></p><pre><code>Import failed: org.apache.hadoop.hbase.NamespaceNotFoundException: org.apache.hadoop.hbase.NamespaceNotFoundException: &apos;namespace&apos;</code></pre></li><li><p><code>--hbase-create-table</code><br><br>如果导入数据的表不存在，则创建该表</p></li><li><p><code>--hbase-row-key</code><br><br>设置 hbase 中的 <code>Row Key</code>，参数值是mysql 表中的列名，可以设置多个列合并成 <code>Row Key</code>, 用逗号分隔</p></li><li><p><code>--column-family</code><br><br>指定导入数据所属的列簇，每次导入数据只能导入属于同一个<code>列簇</code> 的数据，如果 mysql 表中数据属于多个 <code>列簇</code>，只能通过多条指令分批导入。</p></li></ol><p><strong><em>注意：上述指令没有指定列分隔符和行分隔符，默认的列分隔符是 <code>&#39;\001&#39;</code>，在less 中显示是 <code>^A</code>；默认的行分隔符是 <code>&#39;\n&#39;</code>。</em></strong></p>]]></content>
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HBase </tag>
            
            <tag> Sqoop </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《程序化广告——个性化精准投放实用手册》常见问题导读</title>
      <link href="/2018/08/01/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/%E7%A8%8B%E5%BA%8F%E5%8C%96%E5%B9%BF%E5%91%8A-%E4%B8%AA%E6%80%A7%E5%8C%96%E7%B2%BE%E5%87%86%E6%8A%95%E6%94%BE%E5%AE%9E%E7%94%A8%E6%89%8B%E5%86%8C-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%AF%BC%E8%AF%BB/"/>
      <url>/2018/08/01/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/%E7%A8%8B%E5%BA%8F%E5%8C%96%E5%B9%BF%E5%91%8A-%E4%B8%AA%E6%80%A7%E5%8C%96%E7%B2%BE%E5%87%86%E6%8A%95%E6%94%BE%E5%AE%9E%E7%94%A8%E6%89%8B%E5%86%8C-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%AF%BC%E8%AF%BB/</url>
      <content type="html"><![CDATA[<h4 id="问：与传统广告购买相比，程序化广告有什么优势？"><a href="#问：与传统广告购买相比，程序化广告有什么优势？" class="headerlink" title="问：与传统广告购买相比，程序化广告有什么优势？"></a>问：与传统广告购买相比，程序化广告有什么优势？</h4><p><strong>答： 传统广告购买模式下，广告主需要和总多媒体或者广告代理逐个谈判购买媒体资源；程序化购买模式下，广告主可以通过 <code>DSP</code>、<code>TD</code> 或广告代理来对接 <code>Ad Exchang(ADX)</code> 或 <code>SSP</code>；对于程序化广告，通过 <code>DMP</code> 的数据可以做到精准定向投放，还可以结合 <code>PCP(程序化创意平台)</code> 进行个性化广告制作，实现 “千人千面”；借助 <code>广告验证平台</code> 进行广告验证；还可以满足广告主对 <code>品牌安全</code>，<code>反作弊过滤</code>，<code>广告可见度分析</code>等方面的要求。</strong><br><br><strong>对于广告主，程序化广告无需耗费人力一一对接各个媒体渠道，直接加入交易市场即可；程序化广告的精准投放能减少预算浪费并提升转化率；实时竞价和实时投放是的广告数据的收集、分析和优化过程变动更简单、高效。</strong><br><br><strong>对于媒体，程序化广告无需媒体方好美人力资源和广告主或广告代理逐一谈判、对接，只需要对接交易市场；程序化广告能关注每个广告流的销售，将流量进行分级售卖，提高变现能力；程序化广告能更贴合用户的需求，改善媒体用户的用户体验。</strong><br></p><hr><h4 id="问：开发和运营需方平台有什么门槛？"><a href="#问：开发和运营需方平台有什么门槛？" class="headerlink" title="问：开发和运营需方平台有什么门槛？"></a>问：开发和运营需方平台有什么门槛？</h4><p><strong>答：开发和运营需求方平台有 <code>技术</code>、<code>资金</code>、<code>流量资源</code>、<code>广告主资源</code>等方面的能力</strong><br><br><strong>1. 技术：DSP 需要有一下技术能力</strong><br><br><strong>1.1 参与RTB，实时竞价的能力，保证100ms 内作出响应。</strong><br><br><strong>1.1.1 数据收集能力：及时收集竞价、曝光和点击数据</strong><br><br><strong>1.1.2 数据分析能力：竞价过程中DSP 需要分析大量流量数据数据，分析流量是否符合广告投放需求。</strong><br><br><strong>1.1.3 日志数据处理能力：竞价过程中 DSP 需要出价，DSP 需要对日志进行实时统计和离线统计，然后进行 <code>CTR预估</code>、<code>转化率预估</code>和<code>点击价值预估</code>。</strong><br><br><strong>1.1.4 用户识别能力：精准定向能力来自DSP 的用户识别能力和定向能力，DSP 需要支持Cookie 和移动设备ID映射去识别用户，DSP 需要收集用户行为数据，清晰的刻画用户画像。</strong><br><br><strong>2. 资金：DSP 系统需要足够的资金去维持各项硬件设备；还需要足够的运营资金支撑专业团队以及大客户业务</strong><br><br><strong>3. 流量资源：DSP 需要满足广告主对流量的需求</strong><br><br><strong>4. 广告主资源：DSP 需要有足够的广告主资源保证广告填充率，同时足够的广告预算去满足资金需求</strong><br><br><strong>5. 专业人才：技术人才、运营人才</strong><br><br><strong>5.1 DSP 需要技术人才高效的开发和维护DSP 系统</strong><br><br><strong>5.2 DSP 需要有专业的运营人才在数据分析的基础上，根据经验，及时调整投放过程中的各项决策</strong><br></p><hr><h4 id="问：QPS-是什么意思？流量、竞价请求、QPS-三者之间是什么关系？"><a href="#问：QPS-是什么意思？流量、竞价请求、QPS-三者之间是什么关系？" class="headerlink" title="问：QPS 是什么意思？流量、竞价请求、QPS 三者之间是什么关系？"></a>问：QPS 是什么意思？流量、竞价请求、QPS 三者之间是什么关系？</h4><p><strong>答：QPS(Query Per Second) 是每秒查询率，是对服务器在规定时间内所处理流量多少的衡量标准</strong><br><br><strong>一个竞价请求一般只携带一个竞价请求，但是为了节省网络流量等原因，部分渠道会通过一个竞价请求写到同一页面不同广告位的多个流量</strong><br><br><strong>竞价服务会根据DSP的消耗能力(广告填充率、出价和竞得率)设置固定的QPS阈值，或者根据DSP出价和竞得率自动调整QPS阈值</strong><br><br><strong>DSP 也会在ADX/SSP后台设置它能接收到QPS阈值，防止DSP系统过载</strong><br></p><hr><h4 id="问：如何选择需求方平台，有哪些评估指标？"><a href="#问：如何选择需求方平台，有哪些评估指标？" class="headerlink" title="问：如何选择需求方平台，有哪些评估指标？"></a>问：如何选择需求方平台，有哪些评估指标？</h4><p><strong>答：评估需求方有如下指标：媒体资源、技术能力、数据实力、算法能力、公司背景、服务能力、收费模式</strong><br></p><hr><h4 id="问：开发和运营广告交易平台有什么门槛？"><a href="#问：开发和运营广告交易平台有什么门槛？" class="headerlink" title="问：开发和运营广告交易平台有什么门槛？"></a>问：开发和运营广告交易平台有什么门槛？</h4><p><strong>答：开发和运营广告交易平台需要 <code>技术完整性</code>、<code>运营规范化</code>、<code>足够的填充率</code></strong><br><br><strong>技术完整性：完整的流量管理、竞价规则、审核管理等技术机制，保证RTB 流程的高效、完整性</strong><br><br><strong>运营规范化：规范的DSP技术对接文档、规范化的运营流程</strong><br><br><strong>足够的填充率：媒体方要求交易平台保证足够的填充率，这取决于交易平台对接的流量质量和规模、价格政策还有数据开放性</strong><br></p><hr><h4 id="问：程序化广告常用的第三方技术服务有哪些？提供这些服务的公司有哪些？"><a href="#问：程序化广告常用的第三方技术服务有哪些？提供这些服务的公司有哪些？" class="headerlink" title="问：程序化广告常用的第三方技术服务有哪些？提供这些服务的公司有哪些？"></a>问：程序化广告常用的第三方技术服务有哪些？提供这些服务的公司有哪些？</h4><p><strong>答：程序化广告需要的第三方服务有 **<br><br>**<code>程序化创意平台(Programmatic Creative Platform)</code>：通过技术自动生成海量创意，并利用算法和数据对不同受众动态的展示广告并进行创意优化，提供服务的有舜飞科技、筷子科技、Sizmek</strong><br><br><strong><code>广告验证平台(Ad Verification Platform)</code>：</strong><br><br><strong>足够的填充率：媒体方要求交易平台保证足够的填充率，这取决于交易平台对接的流量质量和规模、价格政策还有数据开放性</strong><br></p><hr><h4 id="问：品牌广告如何考核投放效果？"><a href="#问：品牌广告如何考核投放效果？" class="headerlink" title="问：品牌广告如何考核投放效果？"></a>问：品牌广告如何考核投放效果？</h4><p>*<em>答：品牌广告有如下考核标准 *</em><br></p><p><strong>品牌广告投放效果的考核主要从<code>广告效果</code>，<code>成本收益</code>，<code>投放保障</code>三个方面进行 **<br><br>**1. <code>广告效果</code>：衡量广告受众的活跃度和对广告的接受度。从广告效果的层级来说，传播效果可以用广告曝光维度衡量；广告达到的心里效果可以通过受众的行为效果进行衡量；行为效果可以从落地页/网站/APP访问以及用户互动角度进行考核。</strong><br><br><strong>2. <code>成本收益</code>：衡量广告投放整体消耗、各渠道等维度的性价比</strong><br><br><strong>3. <code>投放保障</code>：一般是衡量广告投放的真实性和安全性，用于保障广告效果以及成本收益。</strong><br></p><p><img src="/assets/picture/brand.ads.kpi.jpg" alt title="品牌广告投放考核KPI"></p><p><em>* 具体的考核标准如下：**<br><br>** 独立访客数(UV, Unique Visitor)，在特定时间内访问页面的虚拟自然人（用客户端标识）数量 **<br><br>** 频次(Frequency)，同一波广告投放活动中，每个独立访客接触广告的次数 **<br><br>** 广告可视度(Viewability)，广告出现在窗口可见区域的广告曝光量占广告总曝光量的占比；具体可见曝光定义见可见曝光定义表 **<br><br>** 广告可见的TA浓度(Viewable TA%，Target Audience)，<code>TA%</code> = 目标市场中看到广告的TA / 目标市场的广告受众总数 **<br><br>** 广告可见的TA到达率(Viewable TA N+Search)，目标市场中看到广告N次及以上的的TA数量 / 目标市场广告受众总数 **<br><br>** 广告可见的互联网总收视点(Viewable IGRP, Internet Gross Rating Points)， <code>IGRP</code> = 平均曝光频次 \</em> 到达率 * 100 **<br></p><p>** 点击率(CTR, Click Through Rate)，广告点击次数占广告展示次数的占比<strong><br><br>** 互动率(Engagement Rate)，用户衡量广告投放中用户在广告素材或者站内(网站或APP)的交互度和参与度</strong><br><br>** 回搜率(Search Conversion)，广告受众接触广告后在各个平台中搜索广告主相关关键词的用户占比，用于衡量品牌广告对用户品牌认知的提升程度**<br></p><p>** 每点击成本(CPC, Cost Per Click)，广告被点击一次对应的价格 <strong><br><br>** 每千人成本(CPM, Cost Per Mille\Cost Per Thousand Impressions)，广告被展示1000次对应的价格 **<br><br>** 每UV成本(CPUV, Cost Per UV)，广告曝光中每获取一个 UV 的价格；计算公式为 CPUV = 广告消耗金额 / UV数量 **<br><br>** 单次交互成本(CPE, Cost Per Engagement) 或 (CPEV, Cost Per Engaged Visit)，每获得一个受众互动行为对应的价格 **<br><br>** 受众对广告的浏览\互动时长的成本(CPH, Cost Per Hour)，受众对广告的浏览\互动时长的成本，一定程度上代表了广告对受众品牌意识的影响力</strong><br><br><strong><em>疑问点：广告主在多个渠道投放了品牌广告，如何确认回搜行为关联的品牌广告是在哪个渠道投放的？</em></strong></p><p>** 跳出率(Bounce Rate)，指只浏览了入口页面就离开的访问流量占进入该页面的总流量的比例，用于衡量用户点击广告后进入页面的访问质量 **<br><br>** 二跳率(2nd-click Rate)，二跳指用户进入落地页之后在页面的首次有效点击，二跳率是二跳量占进入该页面的总访问量的比例 **<br></p><p>** 品牌安全(Brand Safety)，品牌广告的投放环境要求非常高，不允许出现品牌广告出现在某些网站或媒体上，也不允许通过敏感\非法的关键词触发广告；广告主一般通过广告验证平台过滤敏感或非法关键词/页面。<strong><br><br>** 反作弊(Anti-Fraud)，品牌广告主的考核标准更容易被作弊，因此广告主需要考量服务方的反作弊能力</strong><br><br>** 无效流量验证(Invalid Traffic Verification)，作弊流量只是无效流量的一部分，无效流量的定义见 <code>MMA（中国无线营销联盟）</code><a href="http://www.mmachina.cn/download/MMAa%CC%88%C2%B8%C2%ADa%CC%8A%C2%9B%C2%BD%C3%A6%C2%97%C2%A0c%CC%A7%C2%BA%C2%BFe%CC%80%C2%90%C2%A5e%CC%81%C2%94%C2%80e%CC%80%C2%81%C2%94c%CC%A7%C2%9B%C2%9Fc%CC%A7%C2%A7%C2%BBa%CC%8A%C2%8A%C2%A8a%CC%88%C2%BA%C2%92e%CC%80%C2%81%C2%94c%CC%A7%C2%BD%C2%91a%CC%8A%C2%B9%C2%BFa%CC%8A%C2%91%C2%8A%C3%A6%C2%97%C2%A0%C3%A6%C2%95%C2%88%C3%A6%C2%B5%C2%81e%CC%81%C2%87%C2%8Fe%CC%81%C2%AA%C2%8Ce%CC%80%C2%AF%C2%81%C3%A6%C2%A0%C2%87a%CC%8A%C2%87%C2%86V.1.0.pdf" title="移动互联网广告无效流量验证标准V.1.0" target="_blank" rel="noopener">移动互联网广告无效流量验证标准V.1.0</a> ；**<br><br>** 第三方监控差异(Discrepancy)，第三方数据和DSP平台统计数据之间的差异值 **<br></p><hr><h4 id="问：OTV-是指什么？OTV广告的考核指标有哪些？"><a href="#问：OTV-是指什么？OTV广告的考核指标有哪些？" class="headerlink" title="问：OTV 是指什么？OTV广告的考核指标有哪些？"></a>问：<code>OTV</code> 是指什么？<code>OTV</code>广告的考核指标有哪些？</h4><p>*<em>答：<code>OTV</code> 是 <code>Online TV</code>（网络电视或网络视频），主要的考核指标包含上一问题中的 <code>广告可见度</code>, <code>Viewable TA%</code>, <code>Viewable TA N+Reach</code>, <code>Viewable IGRP</code> 以及基本的广告考核标准 *</em><br></p><hr><h4 id="问：广告可视度的标准是什么？"><a href="#问：广告可视度的标准是什么？" class="headerlink" title="问：广告可视度的标准是什么？"></a>问：广告可视度的标准是什么？</h4><p><strong>答：<code>广告可视度(Viewability)</code> 指广告出现在窗口可见痊愈的广告曝光量占广告总曝光率的比例。</strong><br></p><p><strong><code>MMA(中国无线营销联盟)</code> 制定的 <a href="http://47.104.208.19/wp-content/uploads/2018/05/MMA%E4%B8%AD%E5%9B%BD%E6%97%A0%E7%BA%BF%E8%90%A5%E9%94%80%E8%81%94%E7%9B%9F%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91%E5%B9%BF%E5%91%8A%E5%8F%AF%E8%A7%81%E6%80%A7%E9%AA%8C%E8%AF%81%E6%A0%87%E5%87%86V.1.0.pdf" title="移动互联网广告可见性验证标准 V.1.0" target="_blank" rel="noopener">移动互联网广告可见性验证标准 V.1.0</a> 中对可见性的定义标准遵从 <code>IBA</code>(互动广告局) 和 <code>MRC</code>(媒体分级委员会) 对可视度的计算标准的定义，具体内容如下：</strong><br><br><strong>首先需要注意的是，能够被评价广告可视度的广告都必须是有效流量，无效流量是不需要计算可视度的</strong><br><br><strong>1. 对测量对象的一般要求</strong><br><br>** &nbsp;&nbsp;&nbsp;&nbsp;1) 客户端计数<strong><br><br>** &nbsp;&nbsp;&nbsp;&nbsp;2) 过滤非人类流量和无效流量</strong><br><br>** &nbsp;&nbsp;&nbsp;&nbsp;3) 缓存清除技术<strong><br><br>** &nbsp;&nbsp;&nbsp;&nbsp;4) 区分明显的（机器人）自动刷新行为与人为活动</strong><br><br>** &nbsp;&nbsp;&nbsp;&nbsp;5) 区分被遮挡及不在显示区域的曝光<strong><br><br>** &nbsp;&nbsp;&nbsp;&nbsp;6) 公开内部材料和流量的传输</strong><br><br>** &nbsp;&nbsp;&nbsp;&nbsp;7) 媒体，门户网站，广告服务器，广告网络和交易所的完整公开<strong><br><br>**2. 对可见广告的曝光要求</strong><br></p><table><thead><tr><th>广告类型</th><th>面积</th><th>时长</th><th>窗口要求</th></tr></thead><tbody><tr><td>PC 展示广告（普通）</td><td>&gt;= 50%</td><td>&gt;= 1秒</td><td>浏览器的可视空间</td></tr><tr><td>PC 展示广告（大）</td><td>&gt;= 30%</td><td>&gt;= 1秒</td><td>浏览器的可视空间</td></tr><tr><td>PC 视屏广告</td><td>&gt;= 50%</td><td>&gt;= 2秒</td><td>浏览器的可视空间</td></tr><tr><td>移动展示广告</td><td>&gt;= 50%</td><td>&gt;= 1秒</td><td>移动浏览器或App终端的可视空间</td></tr><tr><td>移动视屏广告</td><td>&gt;= 50%</td><td>&gt;= 2秒</td><td>移动浏览器或App终端的可视空间</td></tr></tbody></table><hr><h4 id="问：如何保障品牌安全，需要规避哪些类别？"><a href="#问：如何保障品牌安全，需要规避哪些类别？" class="headerlink" title="问：如何保障品牌安全，需要规避哪些类别？"></a>问：如何保障<code>品牌安全</code>，需要规避哪些类别？</h4><p><strong>答：品牌广告对于 <code>投放环境</code> 有很高的要求，不能让广告受众对品牌产生负面影响，<code>品牌安全</code> 要求每个广告验证服务商维护并公开潜在规避类别</strong><br><br><strong>1. IAB <code>内容分级法</code>规定的规避类别 **<br><br>** · 成人内容（Audit Content）</strong><br><br>** · 协助非法活动（Facilitation of Illeagl Activities）<strong><br><br>** · 有争议的主题，即违反现有的社会规范，如神秘、禁忌、反常的生活方式（Controversial Subjects, contrary to existing social norms, such as OccultTaboos、Unusual Lifestyles）</strong><br><br>** · 侵犯版权（Copyright Infringement）<strong><br><br>** · 药物\酒精\受管制药品（Drugs\Alcoho\Controlled Substances）</strong><br><br>** · 极端的图像\明显暴力内容（Extreme Graphic\Explicit Violence）<strong><br><br>** · 诱导篡改度量衡的问题（Incentivized Manipulation of Measurements）</strong><br><br>** · 仇恨\亵渎（Hate\Profanity）<strong><br><br>** · 骚扰\间谍软件\恶意软件\盗版软件（Nuisance\Spyware<br>Malware\Warez） **<br><br>** · 政治\宗教（Political\Religion）</strong><br><br>** · 未经认证的有用户生成的内容（Unmoderated User Generated Content）**<br><br>*<em>2. MMA China 品牌安全和流量质量小组的规避类别 *</em><br><br>** · 分裂言论 **<br><br>** · 讣告 **<br><br>** · 邪教相关言论 **<br><br>** · 恐怖主义言论 **<br><br>** · 党和国家领导人（包括不限于文字、影像等信息）旁 **<br><br>** · 革命烈士（包括不限于文字、影像等信息）旁 **<br><br>** · 在广告主媒介计划以外 **<br></p>]]></content>
      
      <categories>
          
          <category> 计算广告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序化广告 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo-next-github-page</title>
      <link href="/2018/07/29/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/hexo-next-github-page/"/>
      <url>/2018/07/29/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/hexo-next-github-page/</url>
      <content type="html"><![CDATA[<h1 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 <code>Hexo</code></h1><p><em>安装 <code>Hexo</code> 的前提你已经安装以下安装程序</em></p><pre><code>1. Node.js2. Git</code></pre><h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 <code>Node.js</code></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure><p>或者从 [官网](<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a> 官网) 下载安装包，傻瓜式安装</p><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 <code>Git</code></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure><p>或者从 [官网](<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a> 官网) 下载安装包，傻瓜式安装</p><h2 id="安装-Hexo-1"><a href="#安装-Hexo-1" class="headerlink" title="安装 Hexo"></a>安装 <code>Hexo</code></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>查看安装版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ hexo -v</span><br><span class="line">hexo-cli: 1.1.0</span><br><span class="line">os: Darwin 16.3.0 darwin x64</span><br><span class="line">http_parser: 2.8.0</span><br><span class="line">node: 10.7.0</span><br><span class="line">v8: 6.7.288.49-node.15</span><br><span class="line">uv: 1.22.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">ares: 1.14.0</span><br><span class="line">modules: 64</span><br><span class="line">nghttp2: 1.32.0</span><br><span class="line">napi: 3</span><br><span class="line">openssl: 1.1.0h</span><br><span class="line">icu: 62.1</span><br><span class="line">unicode: 11.0</span><br><span class="line">cldr: 33.1</span><br><span class="line">tz: 2018e</span><br></pre></td></tr></table></figure><h1 id="Hexo-使用简介"><a href="#Hexo-使用简介" class="headerlink" title="Hexo 使用简介"></a><code>Hexo</code> 使用简介</h1><h2 id="初始化-Hexo-文件夹"><a href="#初始化-Hexo-文件夹" class="headerlink" title="初始化 Hexo 文件夹"></a>初始化 <code>Hexo</code> 文件夹</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /path/to/my/blog/source/code  ## 传建一个保存博客源代码的目录</span><br><span class="line">hexo init                           ## 初始化一个 Hexo 文件夹</span><br></pre></td></tr></table></figure><p>然后我们来看看初始化后的 hexo 文件夹</p><pre><code>.├── _config.yml                ## 配置文件├── node_modules               ## npm 依赖文件夹            ├── package-lock.json          ## 根据 package.json 文件生成的版本依赖锁定文件，指定了依赖的确定版本├── package.json               ## 声明 hexo 的所有依赖机器版本，详见 https://docs.npmjs.com/getting-started/using-a-package.json├── scaffolds                  ## 存放模板的文件夹，hexo new &apos;file&apos; 指令创建新文档的时候会使用 scaffolds 中的模板├── source                     ## hexo 源文件└── themes                     ## hexo 使用的主题文件夹存放位置</code></pre><h2 id="创建一个新文档"><a href="#创建一个新文档" class="headerlink" title="创建一个新文档"></a>创建一个新文档</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new 'newfile'</span><br></pre></td></tr></table></figure><pre><code>➜ ... hexo new &apos;new file&apos;INFO  Created: ~/.../source/_posts/new-file.md</code></pre><p>我们可以看到在 source 文件夹下面新建了一个新的 <code>markdown</code> 文件</p><h2 id="生成-Hexo-静态文件"><a href="#生成-Hexo-静态文件" class="headerlink" title="生成 Hexo 静态文件"></a>生成 <code>Hexo</code> 静态文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate ## 可以使用简写指令 [hexo g]</span><br></pre></td></tr></table></figure><p>下面我们可以看到 <code>Hexo</code> 文件夹下多了一个 <code>public</code> 文件夹</p><pre><code>.├── _config.yml├── db.json├── node_modules├── package-lock.json├── package.json├── public                ## 存放生成的静态文件，包含 js、css、html、图片├── scaffolds├── source└── themes</code></pre><h2 id="启动-Hexo-服务"><a href="#启动-Hexo-服务" class="headerlink" title="启动 Hexo 服务"></a>启动 <code>Hexo</code> 服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server    <span class="comment">## 简写指令 hexo s</span></span><br></pre></td></tr></table></figure><p>现在我们可以通过 <code>http://localhost:4000/</code> 来访问我们搭建的网站</p><h2 id="一键部署到-GitHub"><a href="#一键部署到-GitHub" class="headerlink" title="一键部署到 GitHub"></a>一键部署到 GitHub</h2><h3 id="修改-config-yml-文件"><a href="#修改-config-yml-文件" class="headerlink" title="修改 _config.yml 文件"></a>修改 <code>_config.yml</code> 文件</h3><pre><code>deploy:  type: git  repo: &lt;repository url&gt;  branch: [branch]  message: [message]</code></pre><h3 id="安装-hexo-deployer-git"><a href="#安装-hexo-deployer-git" class="headerlink" title="安装 hexo-deployer-git"></a>安装 <code>hexo-deployer-git</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h4 id="安装-hexo-deployer-git-遇到的问题"><a href="#安装-hexo-deployer-git-遇到的问题" class="headerlink" title="安装 hexo-deployer-git 遇到的问题"></a>安装 <code>hexo-deployer-git</code> 遇到的问题</h4><pre><code>&gt; npm install hexo-deployer-git --savenpm WARN deprecated swig@1.4.2: This package is no longer maintained+ hexo-deployer-git@0.3.1added 31 packages from 36 contributors and audited 2296 packages in 10.148sfound 1 low severity vulnerability  run `npm audit fix` to fix them, or `npm audit` for details</code></pre><p>让我们执行 <code>npm audit</code> 指令来查看具体问题</p><p>➜  hexo.test.blog npm audit</p><pre><code>                       === npm audit security report ===┌──────────────────────────────────────────────────────────────────────────────┐│                                Manual Review                                 ││            Some vulnerabilities require your attention to resolve            ││                                                                              ││         Visit https://go.npm.me/audit-guide for additional guidance          │└──────────────────────────────────────────────────────────────────────────────┘┌───────────────┬──────────────────────────────────────────────────────────────┐│ Low           │ Regular Expression Denial of Service                         │├───────────────┼──────────────────────────────────────────────────────────────┤│ Package       │ uglify-js                                                    │├───────────────┼──────────────────────────────────────────────────────────────┤│ Patched in    │ &gt;=2.6.0                                                      │├───────────────┼──────────────────────────────────────────────────────────────┤│ Dependency of │ hexo-deployer-git                                            │├───────────────┼──────────────────────────────────────────────────────────────┤│ Path          │ hexo-deployer-git &gt; swig &gt; uglify-js                         │├───────────────┼──────────────────────────────────────────────────────────────┤│ More info     │ https://nodesecurity.io/advisories/48                        │└───────────────┴──────────────────────────────────────────────────────────────┘found 1 low severity vulnerability in 2296 scanned packages  1 vulnerability requires manual review. See the full report for details.</code></pre><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>添加淘宝 npm 镜像源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>然后我们可以继续安装 <code>hexo-deployer-git</code> 了</p><h3 id="部署网站"><a href="#部署网站" class="headerlink" title="部署网站"></a>部署网站</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy    ## 简写指令 hexo d</span><br></pre></td></tr></table></figure><p>部署指令将生成 <code>.deploy_git</code> 文件加，我们需要在 <code>.deploy_git</code> 文件中指定远程 git 链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin giturl</span><br></pre></td></tr></table></figure><h2 id="清除缓存和已创建的静态文件"><a href="#清除缓存和已创建的静态文件" class="headerlink" title="清除缓存和已创建的静态文件"></a>清除缓存和已创建的静态文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><h2 id="生成并部署-Hexo-网站"><a href="#生成并部署-Hexo-网站" class="headerlink" title="生成并部署 Hexo 网站"></a>生成并部署 <code>Hexo</code> 网站</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>这两个指令是等价的，都是先构建本地静态文件，再部署网站</p><h1 id="使用-NexT-主题"><a href="#使用-NexT-主题" class="headerlink" title="使用 NexT 主题"></a>使用 <code>NexT</code> 主题</h1><h2 id="下载-NexT-主题"><a href="#下载-NexT-主题" class="headerlink" title="下载 NexT 主题"></a>下载 <code>NexT</code> 主题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd your-hexo-site</span><br><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><h2 id="修改站点配置文件"><a href="#修改站点配置文件" class="headerlink" title="修改站点配置文件"></a>修改站点配置文件</h2><p>修改 <code>_config.yml</code> 文件中的 <code>theme</code> 配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span>  <span class="comment"># next 是 themes 文件下主题文件夹的名称，冒号后面必须有空格，这是 yaml 语法</span></span><br></pre></td></tr></table></figure><p>现在你可以执行以下指令去构建静态文件并且部署网站了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>然后你可以访问 <code>http://localhost:4000/</code> 去访问你的博客了</p><p><img src="/assets/picture/next-demo.png" alt title="NexT 主题 Demo 图片"></p><h2 id="配置-NexT-主题"><a href="#配置-NexT-主题" class="headerlink" title="配置 NexT 主题"></a>配置 <code>NexT</code> 主题</h2><h3 id="修改菜单栏"><a href="#修改菜单栏" class="headerlink" title="修改菜单栏"></a>修改菜单栏</h3><p>修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span>                                                          <span class="string">|  menu:                                                      </span></span><br><span class="line"><span class="string"></span><span class="attr">  home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span>                                              <span class="string">|    home: / || home                        # 主页，默认配置打开</span></span><br><span class="line"><span class="string">  #about: /about/ || user                                      |    #about: /about/ || user                # 关于自己，可以配置</span></span><br><span class="line"><span class="string">  #tags: /tags/ || tags                                        |    tags: /tags/ || tags                   # 标签页，默认配置关闭，需要你打开注释</span></span><br><span class="line"><span class="string">  #categories: /categories/ || th                              |    categories: /categories/ || th         # 分类页，默认配置关闭，需要你打开注释</span></span><br><span class="line"><span class="string"></span><span class="attr">  archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span>                              <span class="string">|    archives: /archives/ || archive        # 归档页，默认配置打开</span></span><br><span class="line"><span class="string">  #schedule: /schedule/ || calendar                            |    #schedule: /schedule/ || calendar</span></span><br><span class="line"><span class="string">  #sitemap: /sitemap.xml || sitemap                            |    #sitemap: /sitemap.xml || sitemap</span></span><br><span class="line"><span class="string">  #commonweal: /404/ || heartbeat                                                                          # 公益404页，默认配置关闭，需要你打开注释</span></span><br></pre></td></tr></table></figure><h4 id="配置标签页"><a href="#配置标签页" class="headerlink" title="配置标签页"></a>配置标签页</h4><ol><li>创建标签页</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page <span class="string">"tags"</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>修改 themes/next/_config.yml 文件<br>去除 <code>menu.tags</code> 前的 <code>#</code></p></li><li><p>修改标签页标题<br>修改 source/tags/index.md 文件中的 title，写一个你喜欢的标题</p></li></ol><h4 id="配置分类页"><a href="#配置分类页" class="headerlink" title="配置分类页"></a>配置分类页</h4><ol><li>创建标签页</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page <span class="string">"categories"</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>修改 themes/next/_config.yml 文件<br>去除 <code>menu.categories</code> 前的 <code>#</code></p></li><li><p>修改标签页标题<br>修改 source/categories/index.md 文件中的 title，写一个你喜欢的标题</p></li></ol><h3 id="选择-scheme"><a href="#选择-scheme" class="headerlink" title="选择 scheme"></a>选择 <code>scheme</code></h3><p><code>themes/next/_config.yml</code> 文件中默认主题是 <code>Muse</code>，我选择  <code>Mist</code></p><pre><code># Schemesscheme: Muse          # 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白#scheme: Mist         # Muse 的紧凑版本，整洁有序的单栏外观#scheme: Pisces       # 双栏 Scheme，小家碧玉似的清新#scheme: Gemini</code></pre><h3 id="自定义样式"><a href="#自定义样式" class="headerlink" title="自定义样式"></a>自定义样式</h3><h4 id="修改页面宽度"><a href="#修改页面宽度" class="headerlink" title="修改页面宽度"></a>修改页面宽度</h4><p>编辑主题的 source/css/_variables/custom.styl 文件，新增变量：</p><pre><code>// 当屏幕宽度 &lt; 1600px, 修改成你期望的宽度$content-desktop = 900px// 当视窗超过 1600px 后的宽度$content-desktop-large = 1300px</code></pre><h4 id="生成文章摘要"><a href="#生成文章摘要" class="headerlink" title="生成文章摘要"></a>生成文章摘要</h4><ol><li>在文章中使用 <code>&lt;!-- more --&gt;</code> 手动进行截断，在 <code>&lt;!-- more --&gt;</code> 上方撰写摘要，Hexo 提供的方式 <em>【推荐】</em></li><li>在文章的 <code>front-matter</code> 中添加 <code>description</code>，并提供文章摘录，我选择这种</li></ol><h4 id="修改作者名称、描述、语言、时区"><a href="#修改作者名称、描述、语言、时区" class="headerlink" title="修改作者名称、描述、语言、时区"></a>修改作者名称、描述、语言、时区</h4><p>修改 <code>_config.yml</code> 文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site                                                         |  # Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Ice</span> <span class="string">summer</span> <span class="string">bug's</span> <span class="string">notes</span>                                  <span class="string">|  title: Hexo</span></span><br><span class="line"><span class="string"></span><span class="attr">subtitle:</span>                                                      <span class="string">|  subtitle:</span></span><br><span class="line"><span class="string"></span><span class="attr">description:</span> <span class="string">About</span> <span class="string">technology</span> <span class="string">and</span> <span class="string">about</span> <span class="string">life.</span>                  <span class="string">|  description:</span></span><br><span class="line"><span class="string"></span><span class="attr">keywords:</span>                                                      <span class="string">|  keywords:</span></span><br><span class="line"><span class="string"></span><span class="attr">author:</span> <span class="string">Liam</span> <span class="string">Chen</span>                                              <span class="string">|  author: John Doe</span></span><br><span class="line"><span class="string"></span><span class="attr">language:</span> <span class="string">zh-Hans</span>                                              <span class="string">|  language:</span></span><br><span class="line"><span class="string"></span><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure><h4 id="修改作者头像"><a href="#修改作者头像" class="headerlink" title="修改作者头像"></a>修改作者头像</h4><p>修改 <code>themes/next/_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">avatar:</span> <span class="string">/images/headPicture.png</span></span><br></pre></td></tr></table></figure><h1 id="使用-GitHub-Pages"><a href="#使用-GitHub-Pages" class="headerlink" title="使用 GitHub Pages"></a>使用 <code>GitHub Pages</code></h1><p><code>GitHub Pages</code> 使用教程有很多，这里不做赘述，主要是将 <code>.deploy_git</code> 文件夹托管到 <code>GitHub</code> 上，并设置成 <code>GitHub Pages</code></p><p><code>_config.yml</code> 文件中的 <code>deploy.repo</code> 设置成 github url</p><p>我们还可以再建一个 github repository 来管理 Hexo 文件夹</p>]]></content>
      
      <categories>
          
          <category> GitHub Pages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> NexT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>etcd 使用入门</title>
      <link href="/2018/05/21/%E6%8A%80%E6%9C%AF/etcd/2018-05-21-etcd%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/05/21/%E6%8A%80%E6%9C%AF/etcd/2018-05-21-etcd%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="etcd-使用入门"><a href="#etcd-使用入门" class="headerlink" title="etcd 使用入门"></a>etcd 使用入门</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>介绍 etcd 和 raft协议</p><h3 id="etcd-安装"><a href="#etcd-安装" class="headerlink" title="etcd 安装"></a>etcd 安装</h3><p>etcd 的安装有两种方式</p><ol><li>直接从<a href https: github.com coreos etcd releases "" title="release binary page">官网</a>下载 release 版本的二进制文件</li><li>下载源码手动编译安装</li></ol><p>个人倾向于使用 release 版本安装，下面开始下载安装</p><ol><li><p>找到下载的压缩包，解压</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip etcd-v3.3.8-darwin-amd64.zip</span><br></pre></td></tr></table></figure></li><li><p>将解压的文件夹的移动到安装目录中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /path/to/etcd /usr/<span class="built_in">local</span>/etcd</span><br></pre></td></tr></table></figure></li></ol><p>此时我们可以先看看解压后有什么？</p><pre><code>➜  etcd-v3.3.8-darwin-amd64 lltotal 113064drwxr-xr-x  22 ?  staff   748B  6 16 00:55 Documentation-rw-r--r--   1 ?  staff    38K  6 16 00:55 README-etcdctl.md-rw-r--r--   1 ?  staff   7.1K  6 16 00:55 README.md-rw-r--r--   1 ?  staff   7.7K  6 16 00:55 READMEv2-etcdctl.mddrwx------   3 ?  staff   102B  7 16 23:45 default.etcd-rwxr-xr-x   1 ?  staff    30M  6 16 00:55 etcd-rwxr-xr-x   1 ?  staff    25M  6 16 00:55 etcdctl</code></pre><p>可以看到这里有两个可执行程序: <code>etcd</code> 和 <code>etcdctl</code></p><p><code>etcd</code>: etcd 服务端程序<br><code>etcdctl</code>: etcd 客户端程序</p><ol start="3"><li>启动程序</li></ol><p>3.1 使用默认配置启动程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./etcd</span><br></pre></td></tr></table></figure><p>3.2 来一些启动配置，启动一个集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">nohup ./etcd --name test1 --initial-advertise-peer-urls http://localhost:2380 \</span><br><span class="line">  --listen-peer-urls http://localhost:2380 \</span><br><span class="line">  --listen-client-urls http://localhost:2379,http://127.0.0.1:2379 \</span><br><span class="line">  --advertise-client-urls http://localhost:2379 \</span><br><span class="line">  --initial-cluster-token test-cluster \</span><br><span class="line">  --initial-cluster test1=http://localhost:2380,test2=http://localhost:2390,test3=http://localhost:2400 \</span><br><span class="line">  --initial-cluster-state new \</span><br><span class="line">  --data-dir /app/etcd/data1 &amp;</span><br><span class="line"></span><br><span class="line">nohup ./etcd --name test2 --initial-advertise-peer-urls http://localhost:2390 \</span><br><span class="line">  --listen-peer-urls http://localhost:2390 \</span><br><span class="line">  --listen-client-urls http://localhost:2389,http://127.0.0.1:2389 \</span><br><span class="line">  --advertise-client-urls http://localhost:2389 \</span><br><span class="line">  --initial-cluster-token test-cluster \</span><br><span class="line">  --initial-cluster test1=http://localhost:2380,test2=http://localhost:2390,test3=http://localhost:2400 \</span><br><span class="line">  --initial-cluster-state new \</span><br><span class="line">  --data-dir /app/etcd/data2 &amp;</span><br><span class="line"></span><br><span class="line">nohup ./etcd --name test3 --initial-advertise-peer-urls http://localhost:2400 \</span><br><span class="line">  --listen-peer-urls http://localhost:2400 \</span><br><span class="line">  --listen-client-urls http://localhost:2399,http://127.0.0.1:2399 \</span><br><span class="line">  --advertise-client-urls http://localhost:2399 \</span><br><span class="line">  --initial-cluster-token test-cluster \</span><br><span class="line">  --initial-cluster test1=http://localhost:2380,test2=http://localhost:2390,test3=http://localhost:2400 \</span><br><span class="line">  --initial-cluster-state new \</span><br><span class="line">  --data-dir /app/etcd/data3 &amp;</span><br></pre></td></tr></table></figure><h3 id="ETCD-简单指令操作"><a href="#ETCD-简单指令操作" class="headerlink" title="ETCD 简单指令操作"></a><code>ETCD</code> 简单指令操作</h3><ol><li><code>ETCD</code> 数据插入</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./etcdctl put key value</span><br></pre></td></tr></table></figure><ol start="2"><li>插入文件数据到 <code>ETCD</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file | ./etcdctl put key</span><br></pre></td></tr></table></figure><ol start="3"><li>数据查看</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./etcdctl get key</span><br></pre></td></tr></table></figure><ol start="4"><li>集群健康度查看</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./etcdctl --endpoints=[endpoint1, endpoint2, endpoint3] endpoint health</span><br></pre></td></tr></table></figure><p>得到结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">endpoint1 is healthy: successfully committed proposal: took = 932.637µs</span><br><span class="line">endpoint2 is healthy: successfully committed proposal: took = 1.058401ms</span><br><span class="line">endpoint3 is healthy: successfully committed proposal: took = 1.127266ms</span><br></pre></td></tr></table></figure><ol start="5"><li>集群节点状态查询</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./etcdctl --endpoints=[endpoint1, endpoint2, endpoint3] endpoint status</span><br></pre></td></tr></table></figure><p>得到结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">endpoint1, 180821f2462664c9, 3.2.12, 555 MB, <span class="literal">true</span>, 169, 12167260</span><br><span class="line">endpoint2, b2b4375ce5b9bb02, 3.2.12, 555 MB, <span class="literal">false</span>, 169, 12167260</span><br><span class="line">endpoint3, e4927ddc8eb44d9e, 3.2.12, 555 MB, <span class="literal">false</span>, 169, 12167260</span><br></pre></td></tr></table></figure><pre><code>注意：`ETCD` 的API 分为 `V2` 和 `V3` 两个版本，两者之间差距很大，上述 `etcdctl` 客户端的使用都是 `V3` API，在执行之前，请执行命令 `export ETCDCTL_API=3`</code></pre>]]></content>
      
      <categories>
          
          <category> etcd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> etcd </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>golang GC</title>
      <link href="/2018/05/16/%E6%8A%80%E6%9C%AF/golang/2018-05-16-golang-GC/"/>
      <url>/2018/05/16/%E6%8A%80%E6%9C%AF/golang/2018-05-16-golang-GC/</url>
      <content type="html"><![CDATA[<h3 id="golang-GC-浅谈"><a href="#golang-GC-浅谈" class="headerlink" title="golang GC 浅谈"></a>golang GC 浅谈</h3><p>Garbage collector (GC).</p><pre><code>The GC runs concurrently with mutator threads, is type accurate (aka precise), allows multiple GC thread to run in parallel. It is a concurrent mark and sweep that uses a write barrier.</code></pre><p>golang 的 GC 和工作线程并行运行，<em>?类型准确？</em>，允许多个GC 线程并发运行, 通过 <code>write barrier</code> 实现并发的标记清除。</p><pre><code>It is non-generational and non-compacting. Allocation is done using size segregated per P allocation areas to minimize fragmentation while eliminating locks in the common case.</code></pre><p>golang GC 不分代，不压缩。 golang 在分配内存的时候是预先将内存划分为固定大小的内存块，以尽量减少碎片，同时消除常见情况下的锁定。</p><pre><code>The algorithm decomposes into several steps.This is a high level description of the algorithm being used. For an overview of GC a good place to start is Richard Jones&apos; gchandbook.org.</code></pre><p>gc 算法被分解成多个步骤<br>这里是对 <code>垃圾回收</code> 算法的高度概括，对于 <code>垃圾回收</code> 算法的综述和入门学习的资料是 <code>Richard Jones</code> 的 <a href="http://gchandbook.org" title="gchandbook.org" target="_blank" rel="noopener">gchandbook.org</a></p><pre><code>The algorithm&apos;s intellectual heritage includes Dijkstra&apos;s on-the-fly algorithm, seeEdsger W. Dijkstra, Leslie Lamport, A. J. Martin, C. S. Scholten, and E. F. M. Steffens. 1978.On-the-fly garbage collection: an exercise in cooperation. Commun. ACM 21, 11 (November 1978),966-975.For journal quality proofs that these steps are complete, correct, and terminate seeHudson, R., and Moss, J.E.B. Copying Garbage Collection without stopping the world.Concurrency and Computation: Practice and Experience 15(3-5), 2003.1. GC performs sweep termination.</code></pre><p>gc 执行清除</p><pre><code>a. Stop the world. This causes all Ps to reach a GC safe-point.</code></pre><p><code>SWT</code>(Stop the word)：使所有用户线程到达一个 <code>GC</code> 安全点</p><pre><code>b. Sweep any unswept spans. There will only be unswept spans if this GC cycle was forced before the expected time.2. GC performs the &quot;mark 1&quot; sub-phase. In this sub-phase, Ps areallowed to locally cache parts of the work queue.     a. Prepare for the mark phase by setting gcphase to \_GCmark     (from \_GCoff), enabling the write barrier, enabling mutator     assists, and enqueueing root mark jobs. No objects may be     scanned until all Ps have enabled the write barrier, which is     accomplished using STW.     b. Start the world. From this point, GC work is done by mark     workers started by the scheduler and by assists performed as     part of allocation. The write barrier shades both the     overwritten pointer and the new pointer value for any pointer     writes (see mbarrier.go for details). Newly allocated objects     are immediately marked black.     c. GC performs root marking jobs. This includes scanning all     stacks, shading all globals, and shading any heap pointers in     off-heap runtime data structures. Scanning a stack stops a     goroutine, shades any pointers found on its stack, and then     resumes the goroutine.     d. GC drains the work queue of grey objects, scanning each grey     object to black and shading all pointers found in the object     (which in turn may add those pointers to the work queue).</code></pre><p><code>write barrier</code>: 写屏障</p>]]></content>
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> gc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>golang 内存管理浅析</title>
      <link href="/2018/05/16/%E6%8A%80%E6%9C%AF/golang/golang%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%B5%85%E6%9E%90/"/>
      <url>/2018/05/16/%E6%8A%80%E6%9C%AF/golang/golang%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%B5%85%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong><em>从一个问题和回复开始了解 go语言内存管理</em></strong></p><h3 id="How-do-I-know-whether-a-variable-is-allocated-on-the-heap-or-the-stack"><a href="#How-do-I-know-whether-a-variable-is-allocated-on-the-heap-or-the-stack" class="headerlink" title="How do I know whether a variable is allocated on the heap or the stack?"></a>How do I know whether a variable is allocated on the heap or the stack?</h3><pre><code>From a correctness standpoint, you don&apos;t need to know. Each variable in Go exists as long as there are references to it. The storage location chosen by the implementation is irrelevant to the semantics of the language.The storage location does have an effect on writing efficient programs. When possible, the Go compilers will allocate variables that are local to a function in that function&apos;s stack frame. However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors. Also, if a local variable is very large, it might make more sense to store it on the heap rather than the stack.In the current compilers, if a variable has its address taken, that variable is a candidate for allocation on the heap. However, a basic escape analysis recognizes some cases when such variables will not live past the return from the function and can reside on the stack.</code></pre><p>从 <a href="https://golang.org/doc/faq" title="go 语言官网" target="_blank" rel="noopener">go语言官网</a> 的问题列表中有上面这个问题，简单翻译如下</p><h3 id="我们如何知道变量是分配在堆上还是栈上？"><a href="#我们如何知道变量是分配在堆上还是栈上？" class="headerlink" title="我们如何知道变量是分配在堆上还是栈上？"></a>我们如何知道变量是分配在堆上还是栈上？</h3><pre><code>明确地说，你不需要知道答案。 go语言的每个变量当它存在引用的时候它就会一直存在，语言对存储位置的选择与语言的语义无关。存储位置确实会影响编写高效的程序。如果可能，Go编译器将在函数的栈中给本地变量分配存储空间。但是，如果编译器在函数返回后无法证明变量未被引用，则编译器必须在堆上分配变量以避免空指针。此外，如果局部变量非常大，将它存储在堆而不是栈上可能更有意义。在当前主流的编译器中，如果变量有其他访问地址，则该变量是堆上分配的候选变量。但是，基本的逃逸分析可以识别某些情况，这些生命周期只在函数周期内的变量将分配在栈上。</code></pre><p>这个问题和答案告诉我们两个事情，一个是简单介绍了 <code>逃逸分析</code>，另一个就是 go语言官方开发者不认为我们需要了解 <code>内存分配</code>，现在我们需要去了解 <code>逃逸分析</code> 和 <code>内存管理</code>。</p><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>先看看 <code>维基百科</code> 上关于 <code>逃逸分析</code> 的说明</p><pre><code>「逃逸分析」是编译程序优化理论中确定指针动态范围的方法 ———— 分析程序哪些地方可以访问指针，它涉及到指针分析和形状分析。当一个变量在子程序中被分配时，一个指向变量的指针可能会逃逸到其它执行程序中，或者去调用子程序。如果使用尾递归优化（通常在函数编程语言中是需要的），对象也可能逃逸到被调用的子程序中。 如果一个子程序分配一个对象并返回一个该对象的指针，该对象可能在程序中的任何一个地方被访问到——这样指针就成功“逃逸”了。如果指针存储在全局变量或者其它数据结构中，它们也可能发生逃逸，这种情况是当前程序中的指针逃逸。 逃逸分析需要确定指针所有可以存储的地方，保证指针的生命周期只在当前进程或线程中。</code></pre><h3 id="golang-逃逸分析示例"><a href="#golang-逃逸分析示例" class="headerlink" title="golang 逃逸分析示例"></a>golang 逃逸分析示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go run -gcflags="-m -l" escape_ayalysis_demo.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := returnString1()</span><br><span class="line">s2 := returnStringPrt1()</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"s1:"</span>, s1, <span class="string">", addr: "</span>, &amp;s1, <span class="string">"\ns2:"</span>, s2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnString1</span><span class="params">()</span> <span class="params">(rs1 <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">rs1 = <span class="string">"this is a variable in func will return"</span></span><br><span class="line"><span class="built_in">println</span>(rs1)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnStringPrt1</span><span class="params">()</span> <span class="params">(sp1 *<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">rspt1 := <span class="string">"this is a variable in func will return"</span></span><br><span class="line"><span class="built_in">println</span>(rspt1)</span><br><span class="line"><span class="keyword">return</span> &amp;rspt1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用 <code>go:noinline</code> 来禁止编译器使用内联代码来替换函数调用，<br><br>然后我们使用  <code>gcflags=&quot;-m -m&quot;</code> 来查看编译器报告，<code>gcflags</code> 最多可以有四个 <code>-m</code>, 一般来说两个 <code>-m</code> 的信息已经足够了</p><pre><code>&gt; go run -gcflags=&quot;-m -m&quot; escape_ayalysis_demo.go# command-line-arguments./escape_ayalysis_demo.go:11:6: cannot inline returnString1: marked go:noinline./escape_ayalysis_demo.go:18:6: cannot inline returnStringPrt1: marked go:noinline./escape_ayalysis_demo.go:4:6: cannot inline main: non-leaf function./escape_ayalysis_demo.go:21:9: &amp;rspt1 escapes to heap./escape_ayalysis_demo.go:21:9:         from sp1 (return) at ./escape_ayalysis_demo.go:21:2./escape_ayalysis_demo.go:19:2: moved to heap: rspt1./escape_ayalysis_demo.go:7:33: main &amp;s1 does not escapethis is a variable in func will returnthis is a variable in func will returns1: this is a variable in func will return , addr:  0xc42005ff68s2: 0xc42000e020</code></pre><p>这里可以看到函数 <code>returnString1</code> 中没有发生逃逸，因为 <code>returnString1</code> 的返回值类型是 <code>string</code>, <code>main</code> 函数通过值复制将 <code>rs1</code> 的值复制一份而得到 <code>s1</code>；<br>而函数 <code>returnStringPrt1</code> 的返回值是 <code>string</code> 类型的指针，在 <code>main</code> 函数中调用了 <code>returnStringPrt1</code> 时，可以访问指针 <code>sp1</code> 指向的变量，此时指针 <code>sp1</code> 和指针 <code>s2</code> 指向同一个变量，因此变量 <code>rspt1</code> 分配在堆空间中。</p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>Memory allocator.<br>内存分配</p><p>This was originally based on tcmalloc, but has diverged quite a bit.<br><code>golang</code> 的内存分配的方法是在 <code>TCMalloc</code> 的基础上进行了一些改动，<code>TCMalloc(Thread-caching Malloc)</code> 介绍请看<br><a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html" target="_blank" rel="noopener">http://goog-perftools.sourceforge.net/doc/tcmalloc.html</a></p><h3 id="TCMalloc-Thread-caching-Malloc"><a href="#TCMalloc-Thread-caching-Malloc" class="headerlink" title="TCMalloc(Thread-caching Malloc)"></a><code>TCMalloc(Thread-caching Malloc)</code></h3><p><code>TCMalloc</code> 分配的内存主要是两个地方：<code>线程私有缓存(Thread Local Cache)</code> 和 <code>全局缓存堆（Central Heap）</code>；<br><code>TCMalloc</code> 为每个线程分配一个私有缓存，把 &lt;=32k 的对象视为 <code>小对象(Small Object)</code>，小对象的的内存分配先尝试从线程私有缓存上分配，如果线程私有缓存空间不足，再从全局缓存堆中申请一部分空间作为线程私有缓存，而周期性的垃圾回收会将线程私有缓存的空间归还给全局缓存堆；而大于 32k 的对象视为 <code>大对象(Large Object)</code>，大对象的分配直接在全局缓存堆上；</p><h3 id="小对象内存分配（Small-Object-Allocation）"><a href="#小对象内存分配（Small-Object-Allocation）" class="headerlink" title="小对象内存分配（Small Object Allocation）"></a>小对象内存分配（Small Object Allocation）</h3><p>线程本地缓存是一个单向链表 L1，链表 L1 的每个元素也是一个具有相同大小的空间对象的链表 l<sub>n</sub></p><p><img src="/assets/picture/theadheap.gif" alt title="Thread Local Cache Heap"></p><p><code>TCMalloc</code> 将线程本地缓存拆分成约170种大小类型的空闲对象列表，依次以 8bytes、16bytes、32bytes等大小递增</p><p>小对象内存分配具体步骤如下：</p><ol><li>计算对象大小，找到大于对象大小的最小的大小类型 m；</li><li>在当前线程中找到该大小类型的空闲对象链表 l<sub>m</sub>；</li><li>如果链表 l<sub>m</sub> 不为空，从链表中删除第一个空闲对象用于内存分配；这个操作过程中，<code>TCMalloc</code> 不需要加锁，这个对提高内存分配的效率很有帮助；</li><li>如果链表 l<sub>m</sub> 为空，从所有线程共享的 <code>Central Free List</code> 中获取一堆空闲对象，放到当前线程的私有缓存队列上去，在重复步骤3，从线程私有缓存中返回一个空闲对象</li></ol><p>The main allocator works in runs of pages.<br>Small allocation sizes (up to and including 32 kB) are<br>rounded to one of about 70 size classes, each of which<br>has its own free set of objects of exactly that size.<br>Any free page of memory can be split into a set of objects<br>of one size class, which are then managed using a free bitmap.</p><p>主要的内存分配器是工作在运行中的 <strong><em>?内存页?</em></strong> 上。<br>小对象分配的</p><p>golang 将内存切分成约70种固定大小的内存块，me</p><p>The allocator’s data structures are:</p><p>fixalloc: a free-list allocator for fixed-size off-heap objects,<br>    used to manage storage used by the allocator.<br>mheap: the malloc heap, managed at page (8192-byte) granularity.<br>mspan: a run of pages managed by the mheap.<br>mcentral: collects all spans of a given size class.<br>mcache: a per-P cache of mspans with free space.<br>mstats: allocation statistics.</p><p>Allocating a small object proceeds up a hierarchy of caches:</p><ol><li><p>Round the size up to one of the small size classes<br>and look in the corresponding mspan in this P’s mcache.<br>Scan the mspan’s free bitmap to find a free slot.<br>If there is a free slot, allocate it.<br>This can all be done without acquiring a lock.</p></li><li><p>If the mspan has no free slots, obtain a new mspan<br>from the mcentral’s list of mspans of the required size<br>class that have free space.<br>Obtaining a whole span amortizes the cost of locking<br>the mcentral.</p></li><li><p>If the mcentral’s mspan list is empty, obtain a run<br>of pages from the mheap to use for the mspan.</p></li><li><p>If the mheap is empty or has no page runs large enough,<br>allocate a new group of pages (at least 1MB) from the<br>operating system. Allocating a large run of pages<br>amortizes the cost of talking to the operating system.</p></li></ol><p>Sweeping an mspan and freeing objects on it proceeds up a similar<br>hierarchy:</p><ol><li><p>If the mspan is being swept in response to allocation, it<br>is returned to the mcache to satisfy the allocation.</p></li><li><p>Otherwise, if the mspan still has allocated objects in it,<br>it is placed on the mcentral free list for the mspan’s size<br>class.</p></li><li><p>Otherwise, if all objects in the mspan are free, the mspan<br>is now “idle”, so it is returned to the mheap and no longer<br>has a size class.<br>This may coalesce it with adjacent idle mspans.</p></li><li><p>If an mspan remains idle for long enough, return its pages<br>to the operating system.</p></li></ol><p>Allocating and freeing a large object uses the mheap<br>directly, bypassing the mcache and mcentral.</p><p>Free object slots in an mspan are zeroed only if mspan.needzero is<br>false. If needzero is true, objects are zeroed as they are<br>allocated. There are various benefits to delaying zeroing this way:</p><ol><li><p>Stack frame allocation can avoid zeroing altogether.</p></li><li><p>It exhibits better temporal locality, since the program is<br>probably about to write to the memory.</p></li><li><p>We don’t zero pages that never get reused.</p></li></ol><p>P: 运行是管理 G 并把他们映射到 Logical Processor，称之为P；P可以看作是一个抽象的资源或者一个上下文，它需要获取以便操作系统线程(称之为M)可以运行G。<br>M: 操作系统线程<br>G: goroutine，golang 中比线程还要轻量级的协程</p><p><code>fixalloc</code>: 固定大小的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> fixalloc <span class="keyword">struct</span> &#123;</span><br><span class="line">size   <span class="keyword">uintptr</span>  <span class="comment">// 固定</span></span><br><span class="line">first  <span class="function"><span class="keyword">func</span><span class="params">(arg, p unsafe.Pointer)</span> // <span class="title">called</span> <span class="title">first</span> <span class="title">time</span> <span class="title">p</span> <span class="title">is</span> <span class="title">returned</span></span></span><br><span class="line"><span class="function"><span class="title">arg</span>    <span class="title">unsafe</span>.<span class="title">Pointer</span></span></span><br><span class="line"><span class="function"><span class="title">list</span>   *<span class="title">mlink</span></span></span><br><span class="line"><span class="function"><span class="title">chunk</span>  <span class="title">uintptr</span> // <span class="title">use</span> <span class="title">uintptr</span> <span class="title">instead</span> <span class="title">of</span> <span class="title">unsafe</span>.<span class="title">Pointer</span> <span class="title">to</span> <span class="title">avoid</span> <span class="title">write</span> <span class="title">barriers</span></span></span><br><span class="line"><span class="function"><span class="title">nchunk</span> <span class="title">uint32</span></span></span><br><span class="line"><span class="function"><span class="title">inuse</span>  <span class="title">uintptr</span> // <span class="title">in</span>-<span class="title">use</span> <span class="title">bytes</span> <span class="title">now</span></span></span><br><span class="line"><span class="function"><span class="title">stat</span>   *<span class="title">uint64</span></span></span><br><span class="line"><span class="function"><span class="title">zero</span>   <span class="title">bool</span> // <span class="title">zero</span> <span class="title">allocations</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>重读计算广告</title>
      <link href="/2018/05/14/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/%E9%87%8D%E8%AF%BB%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/"/>
      <url>/2018/05/14/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/%E9%87%8D%E8%AF%BB%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>看了一遍刘鹏老师的《计算广告》，获益匪浅，但是部分地方还是不够明确，决定重读一番，学习笔记记录如下，如有错漏敬请斧正。</p><h3 id="在线广告"><a href="#在线广告" class="headerlink" title="在线广告"></a>在线广告</h3><p>在线广告开创了以人群为投放目标，以产品为导向的技术型投放模式，得到了广告主的青睐。在线广告开启了大规模自动化的利用数据改善产品和提高收入的先河，提供了一种盈利模式。</p><h4 id="什么是大数据"><a href="#什么是大数据" class="headerlink" title="什么是大数据"></a>什么是大数据</h4><p>如果有的数据处理问题无法通过数据采样的方法来降低温处理的复杂程度，就必须利用一些专门为海量数据处理而设计的计算和存储技术来实现。</p><p>大数据问题的 <code>4V特征</code></p><ol><li>Volume (规模)</li><li>Variety (多样性)</li><li>Velocity (高速)</li><li>Value (价值)</li></ol><p>大数据问题的特征：当数据的采用率的递增叫显著提升解决问题的效果，而且两者基本成正比，这就是典型的大数据问题。</p><h4 id="为什么要学习计算广告"><a href="#为什么要学习计算广告" class="headerlink" title="为什么要学习计算广告"></a>为什么要学习计算广告</h4><p>计算广告作为目前最成熟的得到充分商业化和规模化的大数据应用<br>1） 提供了规模化的将用户行为数据转为可衡量的商业价值的完整产品线和解决方案；<br>2） 孕育和孵化了较为成熟的数据加工和交易产业链，并对其中的<code>用户隐私</code>边界有深入的探讨；<br>3） 由于商业上的限制条件，计算广告的技术和产品逻辑比个性推荐更加复杂周密；</p><h4 id="什么是广告"><a href="#什么是广告" class="headerlink" title="什么是广告"></a>什么是广告</h4><pre><code>广告是由已经确定的`出资人`通过各种`媒介`进行的有关产品（商品、服务和观点）的，通常是有偿的、有组织的、综合的、劝服性的非人员的信息传播活动。                                                                                                    ————《当代广告学》</code></pre><p>这个定义中有两个主动参与方 ———— <code>出资人</code> 和 <code>媒介</code>, 还有一个被动的参与方, 被劝服的广告的观看者。在计算广告中术语分别是：<code>需求方(Demand)</code>(广告主、广告主代理商、其他形式的采买方)、<code>供给方(Supply)</code>(媒体、其他形式的变现平台)、 <code>广告受众(Adversiter)</code></p><p>传统广告主要是电视、报纸广告，在大量投放和优化效果广告的能力显然是缺乏的，只能是宣传品牌形象、提升中长期购买率和利润空间；而在线广告可以实现低成本的投放个性化广告，而且部分数字数字（如搜索、电子商务）可以明确的知道用户的意图，能够很好的优化广告效果。</p><p><em><em>广告的根本目的是<code>广告主</code>通过<code>媒体</code>达到<code>低成本</code>的<code>用户</code>接触</em></em></p><p>这个定义中的 <code>底成本</code> 需要一个评价指标，这就是 ———— <code>投入产出比（Return On Investment, ROI）</code>，即某次广告活动的总产出与总投入的比例。总投入很容易确定，但是总产出无法确定，但是我们我们也可以通过对各个广告渠道的对比，评估广告成本是否令人满意。</p><pre><code>一切付费的信息、产品或服务的传播渠道，都是广告。</code></pre><h4 id="在线广告创意类型"><a href="#在线广告创意类型" class="headerlink" title="在线广告创意类型"></a>在线广告创意类型</h4><blockquote><p>横幅广告</p><p>文字链接广告</p><p>富媒体广告</p><p>视频广告</p><blockquote><p>前插片广告： 视频播放前的</p><p>暂停广告：视频播放中，暂停时播放的广告</p></blockquote><p>社交广告：社交产品中的原生广告</p><p>移动广告</p><p>邮件定向营销广告</p></blockquote><h4 id="在线广告简史"><a href="#在线广告简史" class="headerlink" title="在线广告简史"></a>在线广告简史</h4><p>在线媒体出现并发展到一定的流量规模之后，就在页面上直接插入广告位，这种照搬报纸广告在互联网上展示广告的产品形式称为 <code>展示广告(display advertising)</code> , 而售卖广告的模式是采用合同的方式确定某一广告位在某一时间段为某特定广告主所独占，并且根据双方的要求，确定广告创意和投放策略，称为 <code>合约广告</code>。</p><p>随着在线媒体的流量快速增长以及在线广告逐渐被广告主了解接受，在线媒体提价的行为被接受，但是媒体流量和品牌认知度都相对稳定之后，提价就不再是提高收入的合适方案了。<br>但是很快在线广告不同于传统媒体广告的本质特点就被发现了：<br><em><em>在线广告可以对不同的广告受众展示不同的广告创意</em></em></p><p>这种广告投放的方式就是 <code>定向广告(trageted advertising)</code>。 而要做到这一点，首先要从技术上获取用户的属性标签，例如用户的性别、年龄等标签，这就是<code>受众定向</code>；而且这时候的广告不能再是静态的嵌入到网页中，而是响应前端的实时请求，根据用户标签自动选择并返回合适的广告， 这就是 <code>广告投放(ad serving)</code>。<br>此时广告的售卖方式还是以合同的形式进行，并且在合同中注明媒体需要保证广告的投放量以及投放量未完成时赔偿方案。这种<code>合约广告</code>的交易方式被称为<code>担保式投放（Guaranteed Delivery）</code>, 这种合约还是主要面对品牌广告主，计费方式是<code>按千次展示收费(Cost per Mille, CPM)</code>。</p><p>合约广告有两个技术难点：</p><ol><li>各个合约的目标受众会有交叉覆盖，如何有效的将流量分配到交叉覆盖上；</li><li>在在线环境下实时的完成每一次展示决策；<br>这两个难点的问题称为 <code>在线分配</code>， 可以使用 <code>带约束优化</code> 的数学框架来探索这个问题。</li></ol><p><code>定向投放</code>的目的是供给方为了<code>拆分流量</code>提高营收，但是<em>如果一开始就提供非常精细的定向，反而会造成售卖率下降</em>，品牌广告主都喜欢优质的流量，如果定向十分精确了略差的流量就卖不出去了。</p><p><code>受众定向</code>的产生使得市场发展呈现两个趋势</p><ol><li>定向标签越来越精准；</li><li>广告主的数量不断膨胀；</li></ol><p>上述两个趋势增加了 <code>在线分配</code> 问题的处理难度，降低了流量的变现能力。从业者开始考虑放弃量的保证，供给方只向广告主保证单位流量的成本，对每次展现都基本按照收益最高的原则来决策，这就是 <code>竞价广告</code>。</p><p><code>竞价广告</code> 的产生原因如上，然而现实中它的出现来自于 <code>搜索广告</code>，<code>搜索引擎</code>的关键词就是一个精准的定向，很自然的就采用的竞价的售卖方式<br>将搜索关键词换成浏览页面中的关键词就成了 <code>上下文广告</code>（信息流广告的鼻祖）</p><p>从宏观市场上看 <code>竞价广告</code> 摆脱了 <code>合约广告</code> 中合约的约束，让广告主能够充分竞争；但是微观上的最优方案并不是整个市场的最大收益。竞价机制的发展，诞生了 <code>广义第二高价 (Generalized Second Price, GSP)</code> 竞价理论。</p><p>有了竞价机制和受众定向，不被品牌广告主看好的中小互联网媒体将流量打包给一个组织，组织将媒体资源按照人群或者上下文标签打包售卖，用竞价的方式决定流量分配。这个组织就是 ———— <code>广告网络(ad Network, ADN)</code>。 <code>ADN</code> 采用的计费方式一般是 <code>按点击收费(Cost Per Click, CPC)</code>。最重要的是，ADN 的出现使得不受品牌广告主青睐的比较差流量有了变现的途径。</p><p>ADN 只通过出价接口提供价格约定，那么由谁来保证量呢？这就催生了一种需求方产品；此时流量采买发生了几点变化：</p><ol><li>流量采买更多的面向受众而非媒体或广告位进行采买；</li><li>需求方产品需要通过技术手段保证广告主量的要去，并在此基础上帮助广告主优化效果。</li></ol><p><em>问题：ADN 的竞价流程是什么样的？</em></p><p>AND 定义好定向标签，将流量分类打包出售，而不会去控制每次展示的出价；需求方选择了合适的标签组合并阶段性的调整出价来间接控制效果。而需求方产品对接多个 ADN 或媒体按人群一站式采买广告并优化投入产出比，这就是 <code>交易终端(Trading Desk, TD)</code>。</p><p>ADN 将媒体的广告受众打上了用户标签，然后批量售卖，但这不能满足需求方越来越明确的利益要求。例如：某电商需要通过给它的忠实用户投放广告来推广某产品，此时需求方需要按照自己的人群定义来挑选流量；流量拍卖的过程从广告主预先出价批量购买，变成了每次展示时实时出价，媒体方提供广告展示的页面的上下文页面URL和用户标识等信息给需求方，需求方就可以完成定制化的人群选择和出价，这就是 <code>实时竞价(Real Time Bidding, RTB)</code>。市场诞生了一个聚合大量媒体的剩余流量并且采用实时竞价方式为他们变现的产品形态 ———— <code>广告交易平台（ad Exchange, ADX）</code>。</p><p>通过实时竞价的方式，按照定制化的人群标签购买广告，这样的产品就是<code>需求方平台(Demand Side Platform, DSP)</code>。<code>DSP</code> 需要尽可能准确地估计每次展示带来的期望价值，而因为充分的环境信息使得深入计算和估计成为可能。基于 <code>DSP</code> 的广告采买方式叫作 <code>程序化交易(programmatic trade)</code>, 除了 <code>RTB</code> 外还有 <code>优选(perfered deals)</code> 以及 <code>私有交易市场(Private Market Place, PMP)</code>。</p><p>在在线广告的发展历史上，定向技术和交易形式的进化是一条主线。从固定位置合约交易到受众定向、担保投放，再到竞价交易方式，最后发展成开放的实时竞价交易市场。这一主线的核心驱动力是越来越多的数据源为广告决策提供支持，从而提升广告的效果。广告发展的另外一条主线是产品展现逻辑上的发展：从广告位和内容相对独立，到通过搜索广告认识到内容和广告对立起来未必是好的选择，搜索广告和信息流广告突出的效果就是因为内容的展现和触发逻辑高度一致，因此产生了将内容和广告以某种方式统一决策或排序的广告产品 ———— <code>原生广告</code>。<code>原生广告</code> 的思路在移动设备上很有前景。</p><h4 id="泛广告商业产品"><a href="#泛广告商业产品" class="headerlink" title="泛广告商业产品"></a>泛广告商业产品</h4><p><code>泛广告商业产品</code> 的本质都是 <code>付费推广</code>，这些付费推广模式的表现方式更加多样化，用户的感知程度和参与程度也大不相同，但是产品的销售模式却与狭义的广告基本相同，但这些商业产品本质上也是在线广告。</p><ol><li>团购</li><li>游戏联运</li><li>固定位导航</li><li>返利购买</li></ol><h3 id="计算广告基础"><a href="#计算广告基础" class="headerlink" title="计算广告基础"></a>计算广告基础</h3><p>计算广告的主要特点有 <code>可衡量的效果</code>以及相应的<code>计算优化</code>。</p><p>利润优化问题的概念框架</p><p>广告产品的收入衡量指标,也是计算广告中最核心的可衡量指标 ———— <code>千次展现期望收入(eCPM, excepted Cost Per Mille)</code>。<br><code>eCPM</code> 可分解为 <code>点击率(Click Through Rate, CTR)</code> 和 <code>点击价值</code></p><p>在线广告产品有很多种计费方式，不同的计费方式反映了不同的市场分工; 也就是说供给方和需求方如何分工估计点击率和点击价值，与整个市场的资源优化配置有关。</p><h4 id="广告信息接收过程"><a href="#广告信息接收过程" class="headerlink" title="广告信息接收过程"></a>广告信息接收过程</h4><ol><li>曝光：广告在页面上展示了</li><li>关注： 广告受众关注到了页面上的广告</li><li>理解： 广告受众理解了广告的诉求</li><li>接受： 广告表达的诉求得到广告受众的认同</li><li>保持： 追求长期转化的品牌广告，希望传达的信息给用户留下深刻的印象</li><li>决策： 广告最终带来的实际转化行为，例如购买</li></ol><h4 id="互联网广告的技术特点"><a href="#互联网广告的技术特点" class="headerlink" title="互联网广告的技术特点"></a>互联网广告的技术特点</h4><ol><li>技术和计算导向： 数字媒体的特点使得在线广告可以进行精确的受众定向；“由于在线广告有独特的竞价交易方式，可以对广告效果进行有效的预估和优化”。</li><li>效果的可衡量性： 广告的展示、点击数据直接可以衡量广告的效果</li><li>创意和投放方式的标准化：标准化的驱动力来自于受众定向和程序化购买</li><li>媒体概念的多样化：数字媒体的交互功能越来越丰富多彩，和线下媒体已经有了本质差别。不同在线媒体在转化的链条上位置不一样，有些更接近最后的决策，有些是为了吸引潜在用户。</li><li>数据驱动的投放决策：在线广告是目前最成熟的大数据引用。在线广告投放流程是：广泛收取用户的行为数据和广告反馈数据，利用云计算基础设施给用户打上合适的标签，同样根据数据在多个广告竞争同一次展示是作出决策，再将投放结果的统计数据反馈广告操作人员以调整投放策略。</li></ol><h4 id="计算广告的核心问题"><a href="#计算广告的核心问题" class="headerlink" title="计算广告的核心问题"></a>计算广告的核心问题</h4><pre><code>计算广告的核心问题，是为一系列用户和环境的组合找到最适合的广告投放策略以优化整体广告活动的利润。</code></pre><p>上述问题的公式化</p><p>max E (ri - qi)</p><p>其中 i 表示从第 1 次到第 T 次之间的一次广告展示。优化目标是在这 T 次展示的总收入(r)与总成本(q)的差。</p>]]></content>
      
      <categories>
          
          <category> 计算广告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算广告 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>golang 基础学习笔记（-）———— 基本语法</title>
      <link href="/2018/03/01/%E6%8A%80%E6%9C%AF/golang/2018-03-01-golang%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/03/01/%E6%8A%80%E6%9C%AF/golang/2018-03-01-golang%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<a id="more"></a><h2 id="Go-基础语法"><a href="#Go-基础语法" class="headerlink" title="Go 基础语法"></a>Go 基础语法</h2><h3 id="Go-程序的基本构成"><a href="#Go-程序的基本构成" class="headerlink" title="Go 程序的基本构成"></a>Go 程序的基本构成</h3><h4 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"hello, world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 程序的基本构成，每个程序都有自己所在的 <code>package</code>,  <code>包</code>这个概念类似于其他编程语言的<code>命名空间</code> 或者 <code>库名</code>, 一般用一个简单的单词，与其他功能区分开即可, 命名规范要求全小写，或者<code>&#39;_&#39;</code>连接的多个单词</p><p>Go 程序是通过 <code>import</code> 关键字将一组包链接在一起。<br><code>import &quot;fmt&quot;</code> 表示该程序需要使用 <code>package fmt</code>（函数或者其他元素），其中 “fmt” 是一个包名</p><p>格式是</p><ul><li>import “package_name”</li><li>import<br>(<br><br>  “package_name”<br><br>)</li></ul><h4 id="function"><a href="#function" class="headerlink" title="function"></a>function</h4><p>Go 程序的重要组成部分是函数，格式是 <code>func 函数名(参数列表) (返回值列表) {}</code></p><h4 id="main-main"><a href="#main-main" class="headerlink" title="main.main"></a>main.main</h4><p>Go 程序的入口是 <code>main.main</code> 方法, 第一个<code>main</code>是该程序的 <code>package</code>; 第二个 <code>main</code> 是该程序的 <code>main</code> 函数，<code>main</code> 函数要求没有参数列表和返回值列表。</p><h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><h4 id="int"><a href="#int" class="headerlink" title="int"></a>int</h4><p>包含int8, int16, int32, int64，分别8bit, 16bit, 32bit, 64bit的有符号整数，而int类型占的bit数决定于编译环境所在平台的位数，如果是32位环境则是32bit，如果是64位环境则是64bit。<br>除了有符号数之外还要无符号数，Go 语言中，无符号型整数有 uint8, uint16, uint32, unit64， int8 的取值范围是 [-128<del>127], 而uint8的取值范围是 [0</del>255], 其他有符号型和无符号型整数的取值范围和这个类型类似。</p><h4 id="byte"><a href="#byte" class="headerlink" title="byte"></a>byte</h4><pre><code>byte is an alias for uint8 and is equivalent to uint8 in all ways. It is used, by convention, to distinguish byte values from 8-bit unsigned integer values.</code></pre><p>byte 是 <code>uint8</code> 的别名（alias）， 或者说完全等同于 <code>uint8</code>。按照惯例用于区分8bit无符号数和byte 类型数据</p><h4 id="rune"><a href="#rune" class="headerlink" title="rune"></a>rune</h4><pre><code>rune is an alias for int32 and is equivalent to int32 in all ways. It is used, by convention, to distinguish character values from integer values.rune 是 `int32` 类型的别名, 或者说完全等同于 `int32`. 按照惯例用于区分字符类型和整数类型</code></pre><p><code>rune</code> 用数字表示字符的 <code>ASCII</code>编码</p><h4 id="float"><a href="#float" class="headerlink" title="float"></a>float</h4><p>浮点类数据类型包含<code>float32</code>和<code>float64</code>, Go 语言基于 <code>IEEE 754标准</code>实现的浮点类型数据，具体参见另一篇文章<a href="http://baidu.com" target="_blank" rel="noopener">浮点数</a></p><h4 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h4><p>布尔类型数据，取值有 true 和 false</p><h4 id="complex"><a href="#complex" class="headerlink" title="complex"></a>complex</h4><p>复数，有对应<code>float32</code> 和 <code>float64</code> 两个精度的数据类型 <code>complex64</code> 和 <code>complex128</code>,<br><code>complex(1, 2)`` 等同于</code>1 + 2i`</p><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>字符串类型，底层实现是byte 类型的 slice，不可变（immutable）</p><h4 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="literal">iota</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><p><code>iota</code> 是无类型的int 类型的常量计数器，在const关键字出现时配置为0，从0开始，const 中每增加一行iota 自增一次（+1）</p><p><code>iota</code> 的使用示例如下, 在 <code>const</code> 关键字修饰的括号中， <code>iota</code> 首先被重置成0， 然后 a = 0, b = 1, c = 2</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">  b        <span class="comment">// 1</span></span><br><span class="line">c        <span class="comment">// 2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>从上面的特性来看，我们可以使用 <code>iota</code> 来定义一个简单的<code>枚举</code>，来个小例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type chargeType int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">CPC  chargeType = iota // 0</span><br><span class="line">CPM                    // 1</span><br><span class="line">CPT                    // 2</span><br><span class="line">CPD                    // 3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>设想你在处理消费者的音频输出。音频可能无论什么都没有任何输出，或者它可能是单声道，立体声，或是环绕立体声的。<br>这可能有些潜在的逻辑定义没有任何输出为 0，单声道为 1，立体声为 2，值是由通道的数量提供。<br>所以你给 Dolby 5.1 环绕立体声什么值。<br>一方面，它有6个通道输出，但是另一方面，仅仅 5 个通道是全带宽通道（因此 5.1 称号 - 其中 .1 表示的是低频效果通道）。<br>不管怎样，我们不想简单的增加到 3。<br>我们可以使用下划线跳过不想要的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type AudioOutput int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">none  AudioOutput = iota // 0</span><br><span class="line">mone                    // 1</span><br><span class="line">stereo                  // 2</span><br><span class="line">_</span><br><span class="line">_</span><br><span class="line">Dolby                   // 5</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><h4 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h4><p>基础用法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> condition &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> condition1 &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition2 &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>关键字 if 和 else 之后的左大括号 { 必须和关键字在同一行，如果你使用了 else-if 结构，则前段代码块的右大括号 } 必须和 else-if 关键字在同一行。这两条规则都是被编译器强制规定的。</em></p><p>除了上述情况之外还有如下使用方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> initialization; condition &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Example:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i := getValue(); i &gt; <span class="number">10</span> &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><ol><li>常见用法</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count; i++ &#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>go 中没有while 循环，用for 循环代替</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i &lt; <span class="number">100</span> &#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>无限循环，没有 condition</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index := <span class="number">0</span>; ; index ++ &#123;&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><code>for range</code></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> idx, element := <span class="keyword">range</span> intArr &#123; <span class="comment">// idx 是数组下表，element 是数组下标所在元素</span></span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> idx := <span class="keyword">range</span> intArr &#123; <span class="comment">// idx 是数组下表</span></span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注意：<code>for a := range arr</code> 这种遍历的时候 a 是数组下标</em></p><p>或</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> map1 &#123; <span class="comment">// Key map 中的key value 是map 中的值</span></span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><code>break</code> 和 <code>continue</code></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> idx := <span class="number">0</span> ;; idx ++ &#123;</span><br><span class="line"><span class="keyword">if</span> idx &gt; <span class="number">10</span> &#123;</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">// 退出当前for 循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> idx := <span class="number">0</span> ;; idx ++ &#123;</span><br><span class="line"><span class="keyword">if</span> (idx % <span class="number">2</span>) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">// 进入下一个循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h4><p>相比其他语言来说go 语言的 <code>switch case</code> 更强大，它支持各种形式的表达式，而且匹配上一个 <code>case</code> 执行完分支代码后，程序会自动switch代码块，不需要使用 <code>break</code> 标明结束</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line"><span class="keyword">case</span> val1:</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">case</span> val2:</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">default</span>:  <span class="comment">// 不符合之前所有已给出条件的时候走到这里，建议写到最后</span></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子中<code>var1</code> 可以是<code>任何类型</code>， 而 <code>val1</code> 和 <code>val2</code> 是同类型的任意值</p><p>多个case 合并</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>:</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fallthrough</code></p><p>当执行完一个 <code>case</code> 分支后还想继续执行下一个 <code>case</code> 分支，可以使用关键字 <code>fallthrough</code></p><p>example：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">2</span></span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">fmt.Printf(<span class="string">"Value 1 or 0, val:%v \n"</span>, i)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.Printf(<span class="string">"Value 2, val:%v \n"</span>, i)</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">fmt.Printf(<span class="string">"Value 3, val:%v \n"</span>, i)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">"Value default, val:%v \n"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>上面程序的输出结果是：</p><pre><code>Value 2, val:2Value 3, val:2Process finished with exit code 0</code></pre><h4 id="array-数组"><a href="#array-数组" class="headerlink" title="array 数组"></a>array 数组</h4><p>数组是固定长度的同一类型元素组成的序列，可以通过数组下标访问来访问元素，下标从0开始</p><p>数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型，数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。</p><p>golang 提供内建函数 <code>append(arr []Type, element... Type)</code> 用于往数组中添加元素，也可用于 <code>slice</code><br>数组相关的<code>内建函数</code> 还有 <code>len()</code> 和 <code>cap()</code>, 对于数组而言 <code>len()</code> 和 <code>cap()</code> 是一样的</p><p><code>len()</code> 函数的参数也可以是 nil, <em>len(nil) == 0</em></p><p>数组的声明格式是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [length]Type</span><br></pre></td></tr></table></figure><p>刚声明的数组长度是 length，每个元素都是零值（数字是0， 字符串是’’，引用类型是nil）<br>也可以使用 <code>make</code> 定义一个数组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">make</span>([]Type, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure><p>还可以在定义的是时候设定初始值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>]<span class="keyword">int64</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>或者设定指定下标的元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>]<span class="keyword">int64</span>&#123;<span class="number">2</span>:<span class="number">1000</span>&#125;  <span class="comment">// arr := []int64&#123;0, 0, 1000&#125;</span></span><br></pre></td></tr></table></figure><p>如果数组元素本身可以比较的，那么数组也是可以用 <code>==</code> 比较的，反则会编译失败</p><h4 id="slice（切片）"><a href="#slice（切片）" class="headerlink" title="slice（切片）"></a>slice（切片）</h4><p><code>slice(切片)</code> 是对数组的一个连续片段的使用</p><p>切片也是可索引的，也可以使用 <code>len()</code> 函数的来获取长度<br>切片除了长度之外，还有一个属性是容量， 通过内建函数 <code>cap()</code> 函数来获取容量，容量的含义是切片开始位置到底层数组结束位置的数组长度<br>例如切片 s 是数组 a 的一部分，s = a[3:], 那么 <em>cap[s] = len(a) - 3</em><br>对于切片来说，始终需要保证 <code>0 &lt;= len(s) &lt;= cap(s)</code>， 如果 <em>len(s) &gt; cap(s)</em> 就会出现<code>越界异常</code></p><p>从上面这段文字总结出 <code>slice</code> 的组成元素是：</p><ol><li>指针（指向底层数组中切片的第一个元素）</li><li>长度</li><li>容量</li></ol><p>下图描述了切片的构成<br><img src="/assets/picture/slice.png" alt="图片" title="slice 构成"></p><p>slice 的初始化方式是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 [...]Type    <span class="comment">// 不需要指明长度，编译器会自动构建一个长度合适的底层数组</span></span><br><span class="line"><span class="keyword">var</span> slice2 []Type       <span class="comment">// _..._可以不写</span></span><br><span class="line"><span class="keyword">var</span> arr [length]Type    <span class="comment">// 声明一个数组</span></span><br><span class="line">slice3 := arr[start:end] <span class="comment">// 声明一个由数组中 [start, end) 元素组成的切片</span></span><br><span class="line">slice4 := arr[start:]    <span class="comment">// end 可以省略不写，表示 end = len(arr)声明一个由数组中 [start, len(arr)) 元素组成的切片</span></span><br><span class="line">slice5 := arr[:end]      <span class="comment">// start 可以省略不写，表示 start = 0 声明一个由数组中 [0, end) 元素组成的切片</span></span><br><span class="line">slice6 := <span class="built_in">make</span>([]Type, <span class="built_in">len</span>, <span class="built_in">cap</span>)  <span class="comment">// 声明一个具体类型，长度是len，容量是cap 的切片， make 关键字适用于 array, slice, map, channel 的内存分配</span></span><br><span class="line">slice7 := <span class="built_in">new</span>([]Type)  <span class="comment">// 也可以用 new 关键词定义一个 len == cap == 0 的slice，但是返回一个指向类型为 T，值为 0 的地址的指针，它适用于值类型如数组和结构体；它相当于 &amp;T&#123;&#125;。强烈建议不要使用 new 关键字声明 slice</span></span><br></pre></td></tr></table></figure><p>由于<code>slice</code> 是共享的底层数组，当一个slice 改变了底层数组的时候，和它共享底层数组的其他<code>slice</code> 也会受影响</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">6</span>]<span class="keyword">int64</span></span><br><span class="line"><span class="keyword">for</span> idx := <span class="keyword">range</span> arr &#123;</span><br><span class="line">arr[idx] = <span class="keyword">int64</span>(idx + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"The underlying array:%v \n"</span>, arr)</span><br><span class="line"></span><br><span class="line">s := arr[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Printf(<span class="string">"The slice:%v, length:%v, capacity:%v \n"</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line"></span><br><span class="line">s[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">fmt.Printf(<span class="string">"The underlying array after set value for slice :%v \n"</span>, arr)</span><br><span class="line">fmt.Printf(<span class="string">"The slice after set value:%v \n"</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><pre><code>The underlying array:[1 2 3 4 5 6 7 8 9 10]The slice 1:[4 5 6 7 8 9 10], length:7, capacity:7The slice 2:[5 6 7 8 9 10], length:6, capacity:6The underlying array after set value for slice :[1 2 3 4 5 1000 7 8 9 10]The slice 1 after set value:[4 5 1000 7 8 9 10]The slice 2 after set value:[5 1000 7 8 9 10]</code></pre><p>如果不想共享底层数据，可以使用内建的 <code>copy(resourceSlice, targetSlice)</code>函数 从原数组或者切片中拷贝一个新的切片，然后对新的切片的操作就不会因为共享底层数组影响其他切片了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个集合中排除掉第二个集合后的结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Subtract</span><span class="params">(c1 []<span class="keyword">interface</span>&#123;&#125;, c2 []<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(subtraction []<span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">subtraction = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(c1))</span><br><span class="line"><span class="built_in">copy</span>(subtraction, c1) <span class="comment">// copy c1 to subtraction</span></span><br><span class="line">subtraction = c1[:]</span><br><span class="line"><span class="keyword">for</span> _, elem2 := <span class="keyword">range</span> c2 &#123;</span><br><span class="line"><span class="keyword">for</span> idx, elem1 := <span class="keyword">range</span> subtraction &#123;</span><br><span class="line"><span class="keyword">if</span> elem2 == elem1 &#123;</span><br><span class="line">subtraction = <span class="built_in">append</span>(subtraction[:idx], subtraction[idx+<span class="number">1</span>:]...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在从数组或切片中生成新的切片的时候还可以指定新切片的容量<br>语法是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newSlice := arr[start:end:<span class="built_in">cap</span>]</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSliceCap</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := []<span class="keyword">int32</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">s1 := a[<span class="number">2</span>:]</span><br><span class="line">fmt.Printf(<span class="string">"a: %v, s1: %v\n"</span>, a, s1)</span><br><span class="line"></span><br><span class="line">s2 := a[<span class="number">0</span>:<span class="number">2</span>:<span class="number">2</span>]</span><br><span class="line">fmt.Printf(<span class="string">"a: %v, s2: %v\n"</span>, a, s2)</span><br><span class="line">s2 = <span class="built_in">append</span>(s2, <span class="number">100</span>)</span><br><span class="line">fmt.Printf(<span class="string">"a: %v, s1: %v, s2: %v\n"</span>, a, s1, s2)</span><br><span class="line"></span><br><span class="line">s3 := a[:<span class="number">2</span>:<span class="number">2</span>]</span><br><span class="line">s3 = <span class="built_in">append</span>(s3, <span class="number">101</span>)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"a: %v, s1: %v, s2: %v, s3:%v\n"</span>, a, s1, s2, s3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><pre><code>a: [1 2 3 4], s1: [3 4]a: [1 2 3 4], s2: [1 2]a: [1 2 3 4], s1: [3 4], s2: [1 2 100]a: [1 2 3 4], s1: [3 4], s2: [1 2 100], s3:[1 2 101]</code></pre><p>从上面的例子可以看到，限定了切片的容量之后，从同一数据产生的切片的</p><p><code>slice</code> 的基本操作和数组一致<br><code>slice</code> 不可以用 <code>==</code> 比较的， bytes 提供了 []byte 的比较方法, strings 提供了 []string 的比较方法</p><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>一个<code>无序</code>的K/V集合，其中所有的key 都是唯一的，在 <code>go</code> 中<code>map</code> 中的 <code>key</code> 必须是可比较的（支持 <code>==</code> 比较运算符）的数据类型, 所以 <code>key</code> 不能是 <code>map</code>、<code>slice</code> 或者 <code>func</code>, 而对于value 值没有任何要求</p><p>map 的定义和初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mapDemo <span class="keyword">map</span>[Key]Value</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[Key]Value, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure><p><code>map</code> 的 <code>key</code> 是完全无序的， 使用 <code>for</code> 循环遍历map 的时候每次的顺序都是随机的</p><p>判断 <code>map</code> m1 中是否包含 k1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m1 = <span class="built_in">make</span>(<span class="keyword">map</span>[Key][Value])</span><br><span class="line">val1, contains := m1[k1]</span><br><span class="line"><span class="keyword">if</span> contains &#123;</span><br><span class="line">fmt.Println(<span class="string">"the map m1 contains k1!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注意：对于 <code>slice</code> 可以直接往为 <code>nil</code> 的 <code>slice</code> 中存放数据，但是map 必须先使用 <code>make</code> 分配内存</em></p><h4 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体(struct)"></a>结构体(struct)</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个结构体</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">id <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体的 String 函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"name: %v, Id: %v"</span>, s.Name, s.id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个结构体</span></span><br><span class="line"><span class="keyword">var</span> s Student</span><br><span class="line"><span class="comment">// 访问结构体的数据</span></span><br><span class="line">s.Name = <span class="string">"test"</span></span><br></pre></td></tr></table></figure><p>结构体还可以组合, 下面我们尝试定义两个结构体，<code>Circle</code> 和 <code>Rectangle</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">x, y, r <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">x, y, <span class="built_in">len</span>, width <span class="keyword">int64</span> <span class="comment">// x,y 是左下角的点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>Rectangle</code> 和 <code>Circle</code> 都具有点的属性，可以提取出一个结构体 <code>Point</code><br>下面的代码中我们定义了三个结构体，分别是 <code>Point</code>、<code>Circle</code>、<code>Rectangle</code>， 其中<code>Circle</code> 和 <code>Rectangle</code> 中都组合了一个 <code>Point</code>, 这是访问属性的时候就需要先访问被组合的结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">x, y <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">c Point <span class="comment">// 原点</span></span><br><span class="line">r <span class="keyword">int64</span> <span class="comment">// 半径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">p          Point <span class="comment">// 左下角的点</span></span><br><span class="line"><span class="built_in">len</span>, width <span class="keyword">int64</span> <span class="comment">// 长和宽</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c1 := Circle&#123;c: Point&#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;, r: <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(c1)</span><br><span class="line"></span><br><span class="line">c2 := Circle&#123;&#125;</span><br><span class="line">c2.c.x = <span class="number">0</span></span><br><span class="line">c2.c.y = <span class="number">0</span></span><br><span class="line">c2.r = <span class="number">3</span></span><br><span class="line">fmt.Println(c2)</span><br><span class="line"></span><br><span class="line">r1 := Rectangle&#123;p: Point&#123;x:<span class="number">0</span>, y:<span class="number">0</span>&#125;, <span class="built_in">len</span>:<span class="number">4</span>, width:<span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(r1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go还支持在结构体中只声明属性的数据类型，而不只限定属性的名称, 这就是匿名成员，从下面的 代码中也能看到，匿名成员也不是没有名字，而是直接把数据类型作为了成员的名字</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">x <span class="keyword">int64</span></span><br><span class="line">y <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">Point   <span class="comment">// 原点</span></span><br><span class="line">r <span class="keyword">int64</span> <span class="comment">// 半径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">Point            <span class="comment">// 左下角的点</span></span><br><span class="line"><span class="built_in">len</span>, width <span class="keyword">int64</span> <span class="comment">// 长和宽</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c1 := Circle&#123;Point: Point&#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;, r: <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(c1)</span><br><span class="line"></span><br><span class="line">c2 := Circle&#123;&#125;</span><br><span class="line">c2.Point.x = <span class="number">0</span></span><br><span class="line">c2.Point.y = <span class="number">0</span></span><br><span class="line">c2.r = <span class="number">3</span></span><br><span class="line">fmt.Println(c2)</span><br><span class="line"></span><br><span class="line">r1 := Rectangle&#123;Point: Point&#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;, <span class="built_in">len</span>: <span class="number">4</span>, width: <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(r1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体是多个类型数据聚合的数据类型， 可以包含任何类型的属性，结构体的访问权限通过大小写来控制，只有大写开头的属性和结构体具有包外可见性，使用json序列化和反序列化数组的时候，小写开头的属性会被忽略。</p><p>结构体的比较取决于结构体的属性，当结构体的所有属性都是可比较的时候，结构体就是可比较的，当使用 <code>==</code> 比较两个结构体的示例的时候，这就是。针对包含不可比较的结构体，也可以使用<code>反射</code>的 <code>reflect.DeepEqual()</code></p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(param1 Type, param2 Type)</span> <span class="params">(result1 Type, result2 Type)</span></span> &#123;</span><br><span class="line"><span class="comment">// method body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的例子中，我们可以看到go 函数的一个显著特点：<code>多返回值</code>，<br>有时候一个方法的结果除了正常的结果外，还有不可预期的异常，这个时候就可以返回多个返回值，比如 <code>encode/json</code> 中的序列化的方法，正常情况下返回序列化的结果，而如果输入的参数无法序列化的时候则返回nil 和异常</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">e := &amp;encodeState&#123;&#125;</span><br><span class="line">err := e.marshal(v, encOpts&#123;escapeHTML: <span class="literal">true</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> e.Bytes(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们在返回值列表中写明变量名，就可以在return 语句中省略操作数， 上面的方法就可以改写成下面这种</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(res []<span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line">e := &amp;encodeState&#123;&#125;</span><br><span class="line">err = e.marshal(v, encOpts&#123;escapeHTML: <span class="literal">true</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span>  <span class="comment">// 等同于 return nil, err</span></span><br><span class="line">&#125;</span><br><span class="line">res = e.Bytes()</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// 等同于 return e.Bytes(), nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="method-is-first-class-value"><a href="#method-is-first-class-value" class="headerlink" title="method is first-class value"></a>method is <code>first-class value</code></h5><p>在 go 语言中函数也是 <code>first-class value</code>， <code>first-class value</code> 的定义如下：</p><ul><li>可以作为变量或者数据结构存储</li><li>可以作为参数传递给方法/函数</li><li>可以作为返回值从函数/方法返回</li><li>可以在运行期创建</li><li>有固有身份；“固有身份”是指实体有内部表示，而不是根据名字来识别，比如匿名函数，还可以通过赋值叫任何名字。大部分语言的基本类型的数值(int, float)等都是第一类对象；但是数组不一定，比如C中的数组，作为函数参数时，传递的是第一个元素的地址，同时还丢失了数组长度信息。对于大多数的动态语言，函数/方法都是第一类对象，比如Python，但是Ruby不是，因为不能返回一个方法。第一类函数对函数式编程语言来说是必须的。</li></ul><p>也就是说在 go语言中函数拥有类型，可以被赋值，可以作为函数的参数或返回值，还可以有匿名函数</p><h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(args ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">total := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, a := <span class="keyword">range</span> args &#123;</span><br><span class="line">total += a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(sum()) <span class="comment">// 0</span></span><br><span class="line">fmt.Println(sum(<span class="number">1</span>)) <span class="comment">// 1</span></span><br><span class="line">fmt.Println(sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(sum(arr...)) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h5 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h5><p>有时候我们需要在函数执行结束之前释放资源（如数据库链接）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseFromFile</span><span class="params">(fileName <span class="keyword">string</span>)</span> <span class="params">(res []<span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">    inputFile, err := os.Open(fileName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"An error occurred on opening the inputfile\n"</span> +</span><br><span class="line">            <span class="string">"Does the file exist?\n"</span> +</span><br><span class="line">            <span class="string">"Have you got acces to it?\n"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inputReader := bufio.NewReader(inputFile)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        inputString, err := inputReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">fmt.Printf(<span class="string">"The input was: %s"</span>, inputString)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">inputFile.Close()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">if</span> (err = checkLine(inputString)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">inputFile.Close()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">res = <span class="built_in">append</span>(res, inputString)     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在每个 <code>return</code> 语句之前，我们都需要调用 <code>inputFile.Close()</code>, 这样做是在太麻烦，go 为我们提供了 <code>refer</code> 关键字</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseFromFile</span><span class="params">(fileName <span class="keyword">string</span>)</span> <span class="params">(res []<span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">    inputFile, err := os.Open(fileName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"An error occurred on opening the inputfile\n"</span> +</span><br><span class="line">            <span class="string">"Does the file exist?\n"</span> +</span><br><span class="line">            <span class="string">"Have you got acces to it?\n"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">refer inputFile.Close() <span class="comment">// 在函数执行到return 之前被调用</span></span><br><span class="line"></span><br><span class="line">    inputReader := bufio.NewReader(inputFile)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        inputString, err := inputReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">fmt.Printf(<span class="string">"The input was: %s"</span>, inputString)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">if</span> (err = checkLine(inputString)); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">res = <span class="built_in">append</span>(res, inputString)     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="refer-执行顺序"><a href="#refer-执行顺序" class="headerlink" title="refer 执行顺序"></a>refer 执行顺序</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">"this is func 1\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func2</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">"this is func 2\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func3</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">"this is func 3\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func4</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">"this is func 4\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">"begin\n"</span>)</span><br><span class="line"><span class="keyword">defer</span> func1()</span><br><span class="line"><span class="keyword">defer</span> func2()</span><br><span class="line"><span class="keyword">defer</span> func3()</span><br><span class="line"><span class="keyword">defer</span> func4()</span><br><span class="line">log.Printf(<span class="string">"finished\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序的数据输出结果是：</p><pre><code>2018/04/17 08:11:41 begin2018/04/17 08:11:41 finished2018/04/17 08:11:41 this is func 42018/04/17 08:11:41 this is func 32018/04/17 08:11:41 this is func 22018/04/17 08:11:41 this is func 1</code></pre><p>可以看出来：<code>defer</code> 的执行顺序和定义顺序正好是相反的</p><h5 id="循环中的-defer"><a href="#循环中的-defer" class="headerlink" title="循环中的 defer"></a>循环中的 defer</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before process file</span></span><br><span class="line"><span class="keyword">for</span> _, filename := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">f, err := os.Open(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close() <span class="comment">// <span class="doctag">NOTE:</span> risky; could run out of file</span></span><br><span class="line"><span class="comment">// ...process f</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// after process file</span></span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>在上面的程序中我们遍历文件名称数组，一个个的处理文件，并在处理完之后希望去关闭文件； 但是 <code>defer</code> 是在函数执行完最后一步才触发，如果文件比较多可能会耗光系统的文件描述符</p><p>这里的解决方案是把 for 循环的循环体抽取成函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, filename := <span class="keyword">range</span> filenames &#123;</span><br><span class="line"><span class="keyword">if</span> err := doFile(filename); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doFile</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">f, err := os.Open(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"><span class="comment">// ...process f…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="init-函数"><a href="#init-函数" class="headerlink" title="init 函数"></a>init 函数</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// init something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>前面讲结构体的时候, 讲过可以给结构体定义方法, 事实上除了结构体我们还可以们可以给数值、字符串、map、数组定义一些自定义行为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义int 数组</span></span><br><span class="line"><span class="keyword">type</span> array []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给数组定义 sum 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a array)</span> <span class="title">sum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">total := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> a &#123;</span><br><span class="line">total += i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> arr1 = array&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">arrSum := arr1.sum()</span><br><span class="line">fmt.Println(arrSum)  <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line">arrSum2 := array.sum(arr1) <span class="comment">// 常规调动函数的方法</span></span><br><span class="line">fmt.Println(arrSum2)  <span class="comment">// 输出 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。</p><ol start="2"><li>内嵌结构体的函数</li><li>垃圾回收</li><li>协程池</li><li>并发</li><li>etcd</li></ol>]]></content>
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用通信端口总结</title>
      <link href="/2018/01/18/%E6%8A%80%E6%9C%AF/mac&amp;linux/netstat%E7%AE%80%E4%BB%8B/"/>
      <url>/2018/01/18/%E6%8A%80%E6%9C%AF/mac&amp;linux/netstat%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天在查看线上应用的时候发现一个不常见的端口占用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$netstat</span> -tlp | grep 99573</span><br><span class="line">tcp        0      0 0.0.0.0:24013           0.0.0.0:*               LISTEN      99573/java          </span><br><span class="line">tcp        0      0 0.0.0.0:17134           0.0.0.0:*               LISTEN      99573/java          </span><br><span class="line">tcp        0      0 0.0.0.0:sieve-filter    0.0.0.0:*               LISTEN      99573/java          </span><br><span class="line">tcp        0      0 0.0.0.0:18134           0.0.0.0:*               LISTEN      99573/java          </span><br><span class="line">tcp        0      0 localhost:19134         0.0.0.0:*               LISTEN      99573/java          </span><br><span class="line">tcp        0      0 0.0.0.0:commplex-main   0.0.0.0:*               LISTEN      99573/java</span><br></pre></td></tr></table></figure><p><code>sieve-filter</code> 这个是什么？<code>commplex-main</code> 又是什么？</p><h2 id="通用常用端口列表"><a href="#通用常用端口列表" class="headerlink" title="通用常用端口列表"></a>通用常用端口列表</h2><table><thead><tr><th>端口</th><th>使用协议</th><th>服务</th><th>说明</th></tr></thead><tbody><tr><td>5000</td><td>TCP/UDP</td><td>commplex-main</td><td></td></tr><tr><td>2000</td><td>TCP/UDP</td><td>sieve-filter</td><td></td></tr></tbody></table><p>结论：<br>        这里使用 <code>commplex-main</code> 和 <code>sieve-filter</code> 端口的是 <code>crashub</code></p>]]></content>
      
      <categories>
          
          <category> 端口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 端口 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>golang 环境变量和 golang 脚本工具</title>
      <link href="/2018/01/10/%E6%8A%80%E6%9C%AF/golang/golang%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8C%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/01/10/%E6%8A%80%E6%9C%AF/golang/golang%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8C%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<h1 id="golang-环境变量"><a href="#golang-环境变量" class="headerlink" title="golang 环境变量"></a>golang 环境变量</h1><p>想要了解 go 的环境变量，我们可以通过 <code>go help environment</code> 指令来查看详细介绍，这里尝试翻译这一些详细介绍，并给出一些个人的认识，如有错漏，欢迎指正</p><h2 id="通用环境变量-General-purpose-environment-variables"><a href="#通用环境变量-General-purpose-environment-variables" class="headerlink" title="通用环境变量(General-purpose environment variables)"></a>通用环境变量(General-purpose environment variables)</h2><h3 id="GCCGO"><a href="#GCCGO" class="headerlink" title="GCCGO"></a>GCCGO</h3><p><code>gccgo</code> 属于 <code>gcc</code> 编译器集合，是 <code>gcc</code> 针对go 语言的前端实现；<code>gccgo</code> 的编译速度比gc较慢一点，但是可以生成更优的代码，因此程序执行速度会更快。<br>golang 的默认编译器是 <code>gc</code>, <code>gc</code> 编译器已支持主流的处理器，而 <code>gccgo</code> 也对 <code>gc</code> 不支持的处理器进行了支持测试；<br>通过Go正式版本安装的go命令已经可以支持 <code>gccgo</code>，需要使用 -compiler选项：<code>go build -compiler=gccgo</code> 。<br>对于用户，如果需要更好编译优化，或者是使用 <code>gc</code> 所不支持的处理器或操作系统，<code>gccgo</code> 可能是一个更好的选择。</p><h3 id="GOARCH"><a href="#GOARCH" class="headerlink" title="GOARCH"></a>GOARCH</h3><p>编译源代码的机器的处理器架构，它的值可以是 386、amd64 或 arm。</p><h3 id="GOBIN"><a href="#GOBIN" class="headerlink" title="GOBIN"></a>GOBIN</h3><p><code>go install</code> 编译出来的可执行文件的存放位置，<code>GOBIN</code> 的默认值是<code>GOPATH/bin</code><br>如果 <code>GOBIN</code> 设置了值，编译出来的可执行脚本将放置到到 <code>GOBIN</code> 设置的文件夹，而不是 .go 文件所在的src 文件夹同级的 bin 文件夹</p><h3 id="GOOS"><a href="#GOOS" class="headerlink" title="GOOS"></a>GOOS</h3><p>编译源代码的机器的操作系统, 它的值可以是 linux, darwin, windows, netbsd。</p><h3 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h3><p><code>GOPATH</code> 列举了机器上所有go代码所在位置，在Unix系统中，该值是以冒号分隔的字符串。<br>在Unix 系统中<code>GOPATH</code> 默认值是 <code>%HOME/go</code>， windows 系统中默认值是 <code>%USERPROFILE%\go</code><br><code>GOPATH</code> 中文件夹结构如下:</p><pre><code>GOPATH=/home/user/go/home/user/go/ src/     foo/         bar/               (go code in package bar)             x.go         quux/              (go code in package main)             y.go bin/     quux                   (installed command) pkg/     linux_amd64/         foo/             bar.a          (installed package object)</code></pre><p><code>src</code>: 存放 go 源文件<br><code>bin</code>: package main 中的go 文件编译之后产生的可执行文件存放位置<br><code>pkg</code>: 非 package main 中的go 文件编译之后产生的静态库文件(*.a)存放位置</p><p>设计开发中，需要将所有存放go 代码的位置都添加到 <code>GOPATH</code> 中去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=:</span><br></pre></td></tr></table></figure><h3 id="GORACE"><a href="#GORACE" class="headerlink" title="GORACE"></a>GORACE</h3><p>竞争监测相关参数，详见 <a href="https://golang.org/doc/articles/race_detector.html" target="_blank" rel="noopener">https://golang.org/doc/articles/race_detector.html</a>.<br><em>待补充</em></p><h3 id="GOROOT"><a href="#GOROOT" class="headerlink" title="GOROOT"></a>GOROOT</h3><p>go 安装目录</p><h3 id="GOTMPDIR"><a href="#GOTMPDIR" class="headerlink" title="GOTMPDIR"></a>GOTMPDIR</h3><p>The directory where the go command will write<br>temporary source files, packages, and binaries.</p><h3 id="GOCACHE"><a href="#GOCACHE" class="headerlink" title="GOCACHE"></a>GOCACHE</h3><p>存放go 编译系统编译过程中产生的缓存文件，如果这个文件过大，可以执行 <code>go clean --cache</code> 去清理这个文件夹</p><h2 id="cgo-相关环境变量"><a href="#cgo-相关环境变量" class="headerlink" title="cgo 相关环境变量"></a>cgo 相关环境变量</h2><h3 id="CC"><a href="#CC" class="headerlink" title="CC"></a>CC</h3><p><code>cgo</code> 编译 c语言代码时候使用的编译器, 需要用户额外安装</p><h3 id="CGO-ENABLED"><a href="#CGO-ENABLED" class="headerlink" title="CGO_ENABLED"></a>CGO_ENABLED</h3><p>是否支持 cgo， 取值是 0 或者 1</p><h3 id="CGO-CFLAGS"><a href="#CGO-CFLAGS" class="headerlink" title="CGO_CFLAGS"></a>CGO_CFLAGS</h3><p>cgo 编译 c 代码时传递的参数</p><h3 id="CGO-CFLAGS-ALLOW"><a href="#CGO-CFLAGS-ALLOW" class="headerlink" title="CGO_CFLAGS_ALLOW"></a>CGO_CFLAGS_ALLOW</h3><p>出于安全考虑，cgo 编译 c 代码时只能允许有限的参数， <code>CGO_CFLAGS_ALLOW</code> 的取值是一个 <code>正则表达式</code>，涵盖所有允许的参数名称</p><h3 id="CGO-CFLAGS-DISALLOW"><a href="#CGO-CFLAGS-DISALLOW" class="headerlink" title="CGO_CFLAGS_DISALLOW"></a>CGO_CFLAGS_DISALLOW</h3><p>和 <code>CGO_CFLAGS_ALLOW</code> 相反，<code>CGO_CFLAGS_ALLOW</code> 的取值也是一个 <code>正则表达式</code>，涵盖所有不允许的参数名称</p><h3 id="CGO-CPPFLAGS-CGO-CPPFLAGS-ALLOW-CGO-CPPFLAGS-DISALLOW"><a href="#CGO-CPPFLAGS-CGO-CPPFLAGS-ALLOW-CGO-CPPFLAGS-DISALLOW" class="headerlink" title="CGO_CPPFLAGS, CGO_CPPFLAGS_ALLOW, CGO_CPPFLAGS_DISALLOW"></a>CGO_CPPFLAGS, CGO_CPPFLAGS_ALLOW, CGO_CPPFLAGS_DISALLOW</h3><p>类似于 <code>CGO_CFLAGS</code>, <code>CGO_CFLAGS_ALLOW</code>, <code>CGO_CFLAGS_DISALLOW</code>, 不过是用于 <code>c</code> 预处理器</p><h3 id="CGO-CXXFLAGS-CGO-CXXFLAGS-ALLOW-CGO-CXXFLAGS-DISALLOW"><a href="#CGO-CXXFLAGS-CGO-CXXFLAGS-ALLOW-CGO-CXXFLAGS-DISALLOW" class="headerlink" title="CGO_CXXFLAGS, CGO_CXXFLAGS_ALLOW, CGO_CXXFLAGS_DISALLOW"></a>CGO_CXXFLAGS, CGO_CXXFLAGS_ALLOW, CGO_CXXFLAGS_DISALLOW</h3><p>类似于 <code>CGO_CFLAGS</code>, <code>CGO_CFLAGS_ALLOW</code>, <code>CGO_CFLAGS_DISALLOW</code>, 不过是用于 <code>c++</code> 编译器</p><h3 id="CGO-FFLAGS-CGO-FFLAGS-ALLOW-CGO-FFLAGS-DISALLOW"><a href="#CGO-FFLAGS-CGO-FFLAGS-ALLOW-CGO-FFLAGS-DISALLOW" class="headerlink" title="CGO_FFLAGS, CGO_FFLAGS_ALLOW, CGO_FFLAGS_DISALLOW"></a>CGO_FFLAGS, CGO_FFLAGS_ALLOW, CGO_FFLAGS_DISALLOW</h3><p>类似于 <code>CGO_CFLAGS</code>, <code>CGO_CFLAGS_ALLOW</code>, <code>CGO_CFLAGS_DISALLOW</code>, 不过是用于 <code>Fortran</code> 编译器</p><h3 id="CGO-LDFLAGS-CGO-LDFLAGS-ALLOW-CGO-LDFLAGS-DISALLOW"><a href="#CGO-LDFLAGS-CGO-LDFLAGS-ALLOW-CGO-LDFLAGS-DISALLOW" class="headerlink" title="CGO_LDFLAGS, CGO_LDFLAGS_ALLOW, CGO_LDFLAGS_DISALLOW"></a>CGO_LDFLAGS, CGO_LDFLAGS_ALLOW, CGO_LDFLAGS_DISALLOW</h3><p>类似于 <code>CGO_CFLAGS</code>, <code>CGO_CFLAGS_ALLOW</code>, <code>CGO_CFLAGS_DISALLOW</code>, 不过是用于 <code>c</code> 链接器</p><h3 id="CXX"><a href="#CXX" class="headerlink" title="CXX"></a>CXX</h3><p>cgo 编译 <code>C++</code>的编译器</p><h3 id="PKG-CONFIG"><a href="#PKG-CONFIG" class="headerlink" title="PKG_CONFIG"></a>PKG_CONFIG</h3><p>取值是 指向 <code>pkg_config</code> 工具的绝对路径</p><h2 id="架构相关的特殊目的的环境变量"><a href="#架构相关的特殊目的的环境变量" class="headerlink" title="架构相关的特殊目的的环境变量"></a>架构相关的特殊目的的环境变量</h2><h3 id="GOARM"><a href="#GOARM" class="headerlink" title="GOARM"></a>GOARM</h3><p>当 <code>GOARCH=arm</code> 时，arm 架构的处理器，它的取值是 5,6,7</p><h3 id="GO386"><a href="#GO386" class="headerlink" title="GO386"></a>GO386</h3><p>当 <code>GOARCH=386</code> 时，浮点指令集，它的取值是  387, sse2</p><h3 id="GOMIPS"><a href="#GOMIPS" class="headerlink" title="GOMIPS"></a>GOMIPS</h3><p>当 <code>GOARCH=mips{,le}</code> 时，指定是软浮点还是硬浮点</p><h2 id="特殊目的的环境变量"><a href="#特殊目的的环境变量" class="headerlink" title="特殊目的的环境变量"></a>特殊目的的环境变量</h2><h3 id="GOROOT-FINAL"><a href="#GOROOT-FINAL" class="headerlink" title="GOROOT_FINAL"></a>GOROOT_FINAL</h3><p>当go 根目录和go 安装目录不一致时，将 <code>GOROOT_FINAL</code> 设置为go 的根目录</p><h3 id="GIT-ALLOW-PROTOCOL"><a href="#GIT-ALLOW-PROTOCOL" class="headerlink" title="GIT_ALLOW_PROTOCOL"></a>GIT_ALLOW_PROTOCOL</h3><p><code>go get</code> 指令使用 <code>git fetch/clone</code> 获取 go 代码的时候允许使用的 <code>schema</code>, 多个 <code>schema</code> 用冒号分割；<br>如果 <code>GIT_ALLOW_PROTOCOL</code> 不包含某个 <code>schema</code>， <code>go get</code> 认为它是不安全的</p><h3 id="GO-EXTLINK-ENABLED"><a href="#GO-EXTLINK-ENABLED" class="headerlink" title="GO_EXTLINK_ENABLED"></a>GO_EXTLINK_ENABLED</h3><p>Whether the linker should use external linking mode<br>when using -linkmode=auto with code that uses cgo.<br>Set to 0 to disable external linking mode, 1 to enable it.</p><h1 id="go-提供的脚本工具"><a href="#go-提供的脚本工具" class="headerlink" title="go 提供的脚本工具"></a>go 提供的脚本工具</h1><h1 id="gofmt"><a href="#gofmt" class="headerlink" title="gofmt"></a>gofmt</h1><p>格式化 go 语言代码</p><pre><code>使用示例: gofmt [flags] [path ...]-cpuprofile string    write cpu profile to this file-d    在控制台输出格式化后的代码和源代码的对比-e    report all errors (not just the first 10 on different lines)-l    list files whose formatting differs from gofmt&apos;s-r string    重写规则，如 &apos;a[b:len(a)] -&gt; a[b:]&apos; 将 `a[b:len(a)]` 替换成 `a[b:len(a)]`-s    简化源代码-w    将格式化结果写回源文件，而不是输出到控制台</code></pre><h3 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h3><h3 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a>go get</h3><h3 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h3><h4 id="交叉编译-cross-compile"><a href="#交叉编译-cross-compile" class="headerlink" title="交叉编译 (cross compile)"></a>交叉编译 (cross compile)</h4><p>Golang 支持交叉编译，在一个平台上生成另一个平台的可执行程序，这里备忘一下。</p><p>Mac 下编译 Linux 和 Windows 64位可执行程序</p><pre><code>CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.goCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go</code></pre><p>Linux 下编译 Mac 和 Windows 64位可执行程序</p><pre><code>CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build main.goCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go</code></pre><p>Windows 下编译 Mac 和 Linux 64位可执行程序</p><pre><code>SET CGO_ENABLED=0SET GOOS=darwinSET GOARCH=amd64go build main.goSET CGO_ENABLED=0SET GOOS=linuxSET GOARCH=amd64go build main.go</code></pre><p>GOOS：目标平台的操作系统（darwin、freebsd、linux、windows）<br>GOARCH：目标平台的体系架构（386、amd64、arm）<br>交叉编译不支持 CGO 所以要禁用它</p><h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3>]]></content>
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kafka 中的偏移量</title>
      <link href="/2017/12/10/%E6%8A%80%E6%9C%AF/kafka/2017-12-10-kafka%E5%A6%82%E4%BD%95%E6%8A%8A%E5%AE%9E%E7%8E%B0consumer%E6%8E%A7%E5%88%B6offset/"/>
      <url>/2017/12/10/%E6%8A%80%E6%9C%AF/kafka/2017-12-10-kafka%E5%A6%82%E4%BD%95%E6%8A%8A%E5%AE%9E%E7%8E%B0consumer%E6%8E%A7%E5%88%B6offset/</url>
      <content type="html"><![CDATA[<h1 id="kafka-中的偏移量"><a href="#kafka-中的偏移量" class="headerlink" title="kafka 中的偏移量"></a>kafka 中的偏移量</h1><h2 id="首先来了解一下Kafka所使用的基本术语："><a href="#首先来了解一下Kafka所使用的基本术语：" class="headerlink" title="首先来了解一下Kafka所使用的基本术语："></a>首先来了解一下Kafka所使用的基本术语：</h2><p><code>Topic</code>: Kafka将消息种子(Feed)分门别类，每一类的消息称之为一个主题(Topic).</p><p><code>Producer</code>: 发布消息的对象称之为主题生产者(Kafka topic producer)</p><p><code>Consumer</code>: 订阅消息并处理发布的消息的种子的对象称之为主题消费者(consumers)</p><p><code>Broker</code>: 已发布的消息保存在一组服务器中，称之为Kafka集群。集群中的每一个服务器都是一个代理(Broker). 消费者可以订阅一个或多个主题（topic），并从Broker拉数据，从而消费这些已发布的消息。</p><hr><h2 id="话题和日志-Topic和Log"><a href="#话题和日志-Topic和Log" class="headerlink" title="话题和日志 (Topic和Log)"></a>话题和日志 (Topic和Log)</h2><p>让我们更深入的了解Kafka中的Topic。</p><p>Topic是发布的消息的类别或者种子Feed名。对于每一个Topic，Kafka集群维护这一个分区的log，就像下图中的示例：</p><p><img src="/assets/picture/kafka-partition.png" alt="图片" title="Kafka partition log"></p><p>每一个分区都是一个顺序的、不可变的消息队列， 并且可以持续的添加。分区中的消息都被分了一个序列号，称之为<code>偏移量</code>(offset)，在每个分区中此<code>偏移量</code>都是唯一的。</p><p>Kafka集群保持所有的消息，直到它们过期， 无论消息是否被消费了。 实际上消费者所持有的仅有的元数据就是这个<code>偏移量</code>，也就是消费者在这个log中的位置。 这个<code>偏移量</code>由<code>消费者</code>控制：正常情况当消费者消费消息的时候，<code>偏移量</code>也线性的的增加。但是实际<code>偏移量</code>由消费者控制，消费者可以将<code>偏移量</code>重置为更老的一个<code>偏移量</code>，重新读取消息。 可以看到这种设计对消费者来说操作自如， 一个消费者的操作不会影响其它消费者对此log的处理。</p><p><img src="/assets/picture/kafka-offset.png" alt="图片" title="Kafka partition offset"></p><hr><h2 id="消费者-Consumers"><a href="#消费者-Consumers" class="headerlink" title="消费者(Consumers)"></a>消费者(Consumers)</h2><p>通常来讲，消息模型可以分为两种， <code>队列</code> 和 <code>发布-订阅</code> 式。 队列的处理方式是 一组消费者从服务器读取消息，一条消息只有其中的一个消费者来处理。在发布-订阅模型中，消息被广播给所有的消费者，接收到消息的消费者都可以处理此消息。Kafka为这两种模型提供了单一的消费者抽象模型： 消费者组 （consumer group）。 消费者用一个消费者组名标记自己。 一个发布在Topic上消息被分发给此消费者组中的一个消费者。 假如所有的消费者都在一个组中，那么这就变成了queue模型。 假如所有的消费者都在不同的组中，那么就完全变成了发布-订阅模型。 更通用的， 我们可以创建一些消费者组作为逻辑上的订阅者。每个组包含数目不等的消费者， 一个组内多个消费者可以用来扩展性能和容错。正如下图所示：<br>2个kafka集群托管4个分区（P0-P3），2个消费者组，消费组A有2个消费者实例，消费组B有4个。</p><p><img src="/assets/picture/kafka-customer-type.png" alt="图片" title="Kafka customer type"></p><p>正像传统的消息系统一样，Kafka保证消息的顺序不变。 再详细扯几句。传统的队列模型保持消息，并且保证它们的先后顺序不变。但是， 尽管服务器保证了消息的顺序，消息还是异步的发送给各个消费者，消费者收到消息的先后顺序不能保证了。这也意味着并行消费将不能保证消息的先后顺序。用过传统的消息系统的同学肯定清楚，消息的顺序处理很让人头痛。如果只让一个消费者处理消息，又违背了并行处理的初衷。 在这一点上Kafka做的更好，尽管并没有完全解决上述问题。 Kafka采用了一种分而治之的策略：分区。 因为Topic分区中消息只能由消费者组中的唯一一个消费者处理，所以消息肯定是按照先后顺序进行处理的。但是它也仅仅是保证Topic的一个分区顺序处理，不能保证跨分区的消息先后处理顺序。 所以，如果你想要顺序的处理Topic的所有消息，那就只提供一个分区。</p><hr><h2 id="偏移量-Offsets-的管理"><a href="#偏移量-Offsets-的管理" class="headerlink" title="偏移量(Offsets)的管理"></a>偏移量(Offsets)的管理</h2><p>如上文所述，kafka为分区中的每条消息保存一个 <code>偏移量（offset）</code>，这个<code>偏移量</code>是该分区中一条消息的唯一标示符。也表示消费者在分区的位置。例如，一个位置是5的消费者(说明已经消费了0到4的消息)，下一个接收消息的偏移量为5的消息。实际上有两个与消费者相关的“位置”概念：</p><p>消费者的位置给出了下一条记录的偏移量。它比消费者在该分区中看到的最大偏移量要大一个。 它在每次消费者在调用poll(long)中接收消息时自动增长。</p><p>“已提交”的位置是已安全保存的最后偏移量，如果进程失败或重新启动时，消费者将恢复到这个偏移量。消费者可以选择定期自动提交偏移量，也可以选择通过调用commit API来手动的控制(如：commitSync 和 commitAsync)。</p><h3 id="消费者如何提交-偏移量-Offsets"><a href="#消费者如何提交-偏移量-Offsets" class="headerlink" title="消费者如何提交 偏移量(Offsets)"></a>消费者如何提交 <code>偏移量(Offsets)</code></h3><ol><li>自动提交</li></ol><p>这种方式只要在启动时配置属性 <code>enable.auto.commit</code> 为 <code>true</code> 即可， 示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">props.put(<span class="string">"group.id"</span>, <span class="string">"test"</span>);</span><br><span class="line">props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"true"</span>);</span><br><span class="line">props.put(<span class="string">"auto.commit.interval.ms"</span>, <span class="string">"1000"</span>);</span><br><span class="line">props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">consumer.subscribe(Arrays.asList(<span class="string">"test"</span>));</span><br><span class="line">System.out.println(consumer);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">  ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">    System.out.printf(<span class="string">"offset = %d, key = %s, value = %s%n"</span>, record.offset(), record.key(),</span><br><span class="line">      record.value());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>手动提交</li></ol><p>在一些场景中，<code>消费者</code> 需要自行判定消息是否被消费了，如果没有判断为没有消费（ps:可能是消费失败了，需要重试），<code>消费者</code> 不会改变 offset；只有 <code>消费者</code> 判定消费成功是，才手动调用 <code>commitSync()</code> 或 <code>commitAsync()</code> 方法去提交 <code>偏移量</code>； 当然此时我们需要把 <code>enable.auto.commit</code> 置为 false。</p><p>下面给出个小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"> props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line"> props.put(<span class="string">"group.id"</span>, <span class="string">"test"</span>);</span><br><span class="line"> props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"false"</span>); <span class="comment">// 主动提交置为false</span></span><br><span class="line"> props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line"> props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line"> KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line"> consumer.subscribe(Arrays.asList(<span class="string">"test"</span>));</span><br><span class="line"> System.out.println(consumer);</span><br><span class="line"> <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"> ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line"> <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line"> System.out.printf(<span class="string">"offset = %d, key = %s, value = %s%n"</span>, record.offset(), record.key(),</span><br><span class="line"> record.value());</span><br><span class="line"> <span class="comment">// 逻辑处理</span></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (success) &#123; <span class="comment">// 如果判定消费成功，则手动提交offset到 broker</span></span><br><span class="line"> consumer.commitSync();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="消费者如果控制偏移量"><a href="#消费者如果控制偏移量" class="headerlink" title="消费者如果控制偏移量"></a>消费者如果控制偏移量</h3><p>在一些场景下，消费者需要控制自己要读取的偏移量，此时用户可以通过API手动设置开始读取的 <code>偏移量</code></p><p>API 中提供以下方法：</p><ol><li><p>指定到某个分区的具体 offset<br>org.apache.kafka.clients.consumer.KafkaConsumer#seek(TopicPartition partition, long offset)</p></li><li><p>指定到某些分区的开始<br>org.apache.kafka.clients.consumer.KafkaConsumer#seekToBeginning(Collection<topicpartition> partitions)</topicpartition></p></li><li><p>指定到某些分区的结束，从上次结束的位置开始消费<br>org.apache.kafka.clients.consumer.KafkaConsumer#seekToEnd(Collection<topicpartition> partitions)</topicpartition></p></li></ol><p>此时我们需要知道当前的 <code>Topic</code> 的偏移量信息，<code>Kafka</code> 为我们提供了很友好的工具 <code>Get Offset Shell</code></p><p><code>Get Offset Shell</code><br>get offsets for a topic</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-run-class.sh kafka.tools.GetOffsetShell</span><br></pre></td></tr></table></figure><p>required argument [broker-list], [topic]</p><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>–broker-list [hostname:port,….]</td><td>REQUIRED: The list of hostname and [hostname:port] port of the server to connect to.</td></tr><tr><td>–max-wait-ms [Integer: ms]</td><td>The max amount of time each fetch request waits. (default: 1000)</td></tr><tr><td>–offsets [Integer: count]</td><td>number of offsets returned (default: 1)</td></tr><tr><td>–partitions [partition ids]</td><td>comma separated list of partition ids. If not specified, will find offsets for all partitions (default)</td></tr><tr><td>–time [Long: timestamp in milliseconds]</td><td>-1(latest) / -2 (earliest) timestamp; offsets will come before this timestamp, as in getOffsetsBefore</td></tr><tr><td>–topic [topic]</td><td>REQUIRED: The topic to get offsets from.</td></tr></tbody></table><p>示例：</p><p>查询最近的offset</p><pre><code>➜  kafka_2.12-1.0.0 bin/kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list localhost:9092 -topic test --time -1</code></pre><p>输出</p><pre><code>test:0:52</code></pre><p>查询开始的的offset</p><pre><code>➜  kafka_2.12-1.0.0 bin/kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list localhost:9092 -topic test --time -2</code></pre><p>输出</p><pre><code>test:0:0</code></pre><h3 id="偏移量的存储"><a href="#偏移量的存储" class="headerlink" title="偏移量的存储"></a><code>偏移量</code>的存储</h3><p>新版本的 <code>Kafka</code> 将偏移量信息存储在名为 <code>__consumer_offsets</code> 的topic 中,<br>也支持将 <code>偏移量</code> 信息存储在 <code>Zookeeper</code> 中<br><br>通过设置属性 <code>offsets.storage</code> 控制，<code>offsets.storage</code> 属性可选值有 <code>kafka</code> 和 <code>zookeeper</code></p><p>消费者也可以不使用 <code>Kafka</code> 提供的偏移量存储方案，可自定义存储方式，详见<a href="http://kafka.apache.org/0101/javadoc/org/apache/kafka/clients/consumer/KafkaConsumer.html#rebalancecallback" title="官方文档" target="_blank" rel="noopener">官方文档</a></p>]]></content>
      
      <categories>
          
          <category> kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浮点数学习笔记</title>
      <link href="/2017/12/06/%E6%8A%80%E6%9C%AF/golang/2017-12-06-%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
      <url>/2017/12/06/%E6%8A%80%E6%9C%AF/golang/2017-12-06-%E6%B5%AE%E7%82%B9%E6%95%B0/</url>
      <content type="html"><![CDATA[<h2 id="浮点数学习笔记"><a href="#浮点数学习笔记" class="headerlink" title="浮点数学习笔记"></a>浮点数学习笔记</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近在工作中遇到汇率换算的问题，需要将用户订单中的的本币换算成美元，用 <code>golang</code> 写了个脚本进行换算，当把汇率变量的类型定义为 <code>float32</code> 的时候，计算结果存在不能接受的误差<br>查看了一下 <code>golang</code> 的官方文档，发现 <code>golang</code> 实现的浮点型数据是基于 <code>IEEE 754标准</code>，这一标准在存储小数的时候先天就 <code>存在误差</code>，下面会一一介绍。</p><h3 id="float-精度问题"><a href="#float-精度问题" class="headerlink" title="float 精度问题"></a><code>float</code> 精度问题</h3><p>先来个小例子，抛出问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">64.35</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">64.35</span>  <span class="comment">// 默认类型是 float64</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"this is a float32 %f \n"</span>, a)</span><br><span class="line">fmt.Printf(<span class="string">"this is a float64 %f \n"</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果：</p><pre><code>this is a float32 64.349998this is a float64 64.350000</code></pre><p>可以看到, 使用 <code>float32</code> 类型的时候， 小数 <code>64.35</code> 存储的并不精准；不难想象，对 <code>float32</code> 进行逻辑计算的时候肯定会产生误差；那么使用 <code>float64</code> 类型数据的时候，计算结果就一定精准吗？答案显然是<code>否定</code>的，下面给将给出答案</p><h3 id="为什么叫-浮点数"><a href="#为什么叫-浮点数" class="headerlink" title="为什么叫 浮点数"></a>为什么叫 <code>浮点数</code></h3><p>为什么叫 <code>浮点数</code>， <code>浮点数</code> 这个名词是相对 <code>定点数</code>来说的，从这两个名词中可以看出，这两个概念的差别就在于 <code>点</code>， 这里的 <code>点</code> 指的是小数中的 <code>小数点</code>；</p><p>大家都知道，计算机都是使用 <code>二进制</code> 的形式来存储和计算数据的，对于小数的处理也是如此；</p><p>存储小数的时候，计算机将小数分为 <code>整数</code> 和 <code>小数</code> 两个部分进行处理：</p><p><code>定点数</code> 就是将小数点的位置固定，分别分配固定的位数用于存储 <code>整数</code> 和 <code>小数</code> 部分，<br>例如，我们用 32bit 存储小数，第31位存储符号，23<del>30位存储 <code>整数</code>，0</del>22 位存储小数，如下图，</p><table><thead><tr><th>0</th><th>0000 1111</th><th>0100 0000 0000 0000 0000 000</th><th>15.25</th></tr></thead><tbody><tr><td>31bit符号位</td><td>23~30bit保存整数部分</td><td>0~22bit保存小数部分</td><td>十进制小数</td></tr></tbody></table><p>上面这个例子中 <code>定点数</code> 将小数点固定在 22bit 和 23bit 之间；可以很明显的看出，这种存储方式受到位数的限制，能表示的数字范围很小，上例中小数的范围就是 -255.xxx ~ 255.xxx <br><br>(ps：寡人太懒了，不想算[1/2 + 1/4 + … + 1/2<sup>-23</sup>])<br>也正是这个原因，计算机放弃了这种方式，采用了 <code>浮点数</code> 的方式。</p><p><code>浮点数</code> 从名称上来解释的就是，小数点的位置是浮动的；简单来说浮点数就是将一个数字用<code>科学计数法</code>表示，先将数字分为 <code>基数</code>、<code>指数</code>； 再将<code>基数</code>分为整数部分和小数部分，例如:<br>12345 = 1.2345 x 10<sup>4</sup>；当然这里是十进制，而计算机在存储<code>浮点数</code>的时候当然还是二进制</p><p>15.25 = 1111.01 = 1.11101 x 2<sup>3</sup></p><p>让我们用32bit 保存小数：</p><table><thead><tr><th>0</th><th>1000 0010</th><th>1110 1000 0000 0000 0000 000</th><th>15.25</th></tr></thead><tbody><tr><td>31bit符号位</td><td>23~30bit保存指数部分</td><td>0~22bit保存小数部分</td><td>十进制小数</td></tr></tbody></table><p>你能从这个二进制中看出小数点的位置吗？<br><br>这里大家要注意： <strong>浮点数不仅仅可以保存小数！整数也是可以的</strong>，但是用浮点数表示整数这种行为不鼓励，毕竟浮点数表示数字是不精确的</p><h3 id="IEEE-754-存储-浮点数"><a href="#IEEE-754-存储-浮点数" class="headerlink" title="IEEE 754 存储 浮点数"></a><code>IEEE 754</code> 存储 <code>浮点数</code></h3><p>上面讲<code>浮点数</code>的时候也基本介绍了 <code>IEEE 754</code> 标准<br><br><code>IEEE 754</code> 标准依赖于 <code>科学计数法</code>，将一个数字用二进制科学计数法表示，将一个数字分为<code>指数</code>和<code>基数</code>，用一位表示符号位，再将基数分为整数（二进制的整数部分当然是1了）和小数部分；<code>IEEE 754</code>规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80位实现）；如下：</p><table><thead><tr><th>表示方式</th><th>符号位（Sign,S）</th><th>指数部分(Exponent,E)</th><th>小数部分(Fraction,F)</th></tr></thead><tbody><tr><td>单精确度（32位）</td><td>1bit</td><td>8bit</td><td>23bit</td></tr><tr><td>双精确度（64位）</td><td>1bit</td><td>11bit</td><td>52bit</td></tr></tbody></table><p>一个单精确度（32位）浮点数的表达公式如下:<br><br><strong>ｘ＝(－1)<sup>S</sup>×(1.F)×2<sup>Ｅ－127</sup> 　 　e＝Ｅ－127</strong></p><p><code>Sign</code>: 简写为S，符号位，很简单就是 1:负数 0:正数<br><br><code>Exponent</code>: 简写为E，指数部分，计算公式是：<code>指数+接码偏移量(127)</code><br><br><code>Fraction</code>: 简写为F，小数部分</p><p>到这里大家就很自然的会想到一个问题 <strong>阶码偏移量为何用127?</strong></p><p>这个问题也困扰我很久，看了<code>维基百科</code>等资料，最后在<code>知乎</code>上找到了一个比较靠谱的答案，引用如下：</p><p>主要是为了让表示的范围能够对称起来<br>这个算一算就清楚了。当阶码E 为全0且尾数M 也为全0时，表示的真值x 为零，结合符号位S 为0或1，有正零和负零之分。当阶码E 为全1且尾数M为全0时，表示的真值x 为无穷大，结合符号位S 为0或1，也有+∞和-∞之分。这样在32位浮点数表示中，要除去E，用全0和全1(255)10表示零和无穷大的特殊情况，指数的偏移值不选128(10000000)，而127(01111111)。对于规格化浮点数，阶码E范围是1<del>254。 分两种情况计算如下： 1）偏移值为127时，绝对值范围大致是：1.2*10^(-38)</del>3.4<em>10^(+38)； 2）如果偏移值取为128时， 绝对值范围大致是：5.9</em>10^(-39)~1.7*10^(+38)； 可见偏移值取127时，上下范围基本对称，相对合理点。</p><p>作者：yuanyuany<br>链接：<a href="https://www.zhihu.com/question/24784136/answer/144601879" target="_blank" rel="noopener">https://www.zhihu.com/question/24784136/answer/144601879</a><br><br>来源：知乎</p><p>如果是双精确度（64位）</p><h3 id="十进制-和-IEEE-754浮点数-相互转化"><a href="#十进制-和-IEEE-754浮点数-相互转化" class="headerlink" title="十进制 和 IEEE 754浮点数 相互转化"></a><code>十进制</code> 和 <code>IEEE 754浮点数</code> 相互转化</h3><p>下面来个小例子， 我们将 <code>64.35</code> 转化成<code>IEEE 754浮点数</code></p><ol><li>现将 <code>64.35</code> 用转化成 <code>二进制</code></li></ol><p>先看整数部分 <code>64</code> = <code>0100 0000</code></p><p>再来转化小数部分转二进制</p><p>0.35x2 = 0.7  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0 // 取计算结果整数部分<br><br>0.70x2 = 1.4  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1 // 取上一计算结果的小数部分乘以2 <br><br>0.40x2 = 0.8  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0 <br><br>0.80x2 = 1.6  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1 <br><br>0.60x2 = 1.2  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1 <br><br>0.20x2 = 0.4  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0 <br><br>0.40x2 = 0.8  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0 <br><br>0.80x2 = 1.6  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1 <br><br>0.60x2 = 1.2  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1 <br><br>0.40x2 = 0.8  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0 // 到这里已经是循环重复了，这里永远不会算出1.0，所以用 <code>IEEE 754</code> 表示的时候是无限循环 <br></p><p>小数部分： <code>0.35</code> = <code>01 0110 0110 ...</code></p><p>二进制结果  <code>64.35</code> = <code>1000000.0101100110...</code> = <em><em>1.0000 0001 0110 0110 0110… x 2<sup>6</sup></em></em></p><p>用 32bit <code>IEEE 754</code> 存储 <code>64.35</code><br><br>s = 0<br><br>expr = 127 + 6 = 133 = <code>1000 0101</code> <br><br>frag = <code>0000 0001 0110 0110 0110 011</code><br></p><p><code>IEEE 754</code> 32位存储 <code>64.35</code> 的情况如下<br><br><code>64.35</code> = <code>0 | 1000 0101 | 0000 0001 0110 0110 0110 011</code></p><p>用 64bit <code>IEEE 754</code> 存储 <code>64.35</code><br><br>s = 0<br><br>expr = 1023 + 6 = 1029 = <code>1000 0000 0101</code> <br><br>frag = <code>0000 0001 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110</code><br></p><p><code>IEEE 754</code> 64位存储 <code>64.35</code> 的情况如下<br><br><code>64.35</code> = <code>0 | 1000 0000 0101 | 0000 0001 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110</code></p><p>我们再将<code>IEEE 754浮点数</code> 还原成小数,</p><p>先看看32bit 的情况<br>看看，算出指数  1000 0101 - 1111111 = 133 - 127 = 6<br><br>然后这个浮点数的二进制表示就是 <code>1.0000 0001 0110 0110 0110 011 x 2&lt;sup&gt;6&lt;/sup&gt;</code><br><br>下面就是换算成<code>十进制</code><br>1.0000 0001 0110 0110 0110 011 x 2<sup>6</sup> = 100 0000.0101 1001 1001 1001 1</p><p>先看整数部分  0100 0000 = 64<br>在看小数部分 0.0101 1001 1001 1001 1 转十进制</p><p>1/2<sup>2</sup> + 1/2<sup>4</sup> + 1/2<sup>5</sup> + 1/2<sup>8</sup> + 1/2<sup>9</sup> + 1/2<sup>12</sup> + 1/2<sup>13</sup> + 1/2<sup>16</sup> + 1/2<sup>17</sup> = 0.349052429199219</p><p>结论: <code>0 | 1000 0101 | 0000 0001 0110 0110 0110 011</code> = <code>64.349052429199219</code></p><p>再看 64bit 的情况：<br><br>1.0000 0001 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 x 2<sup>6</sup> = 100 0000.0101 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 10</p><p>0.0101 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 10 =<br>1/2<sup>2</sup> + 1/2<sup>4</sup> + 1/2<sup>5</sup> + 1/2<sup>8</sup> + 1/2<sup>9</sup> + 1/2<sup>12</sup> + 1/2<sup>13</sup> + 1/2<sup>16</sup> + 1/2<sup>17</sup> + 1/2<sup>20</sup> + 1/2<sup>21</sup> + 1/2<sup>24</sup> + 1/2<sup>25</sup> + 1/2<sup>28</sup> + 1/2<sup>29</sup> + 1/2<sup>32</sup> + 1/2<sup>33</sup> + 1/2<sup>36</sup> + 1/2<sup>37</sup> + 1/2<sup>40</sup> + 1/2<sup>41</sup> + 1/2<sup>44</sup> + 1/2<sup>45</sup> = 0.349999999999994</p><p>结论: <code>0 | 1000 0000 0101 | 0000 0001 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110</code> = <code>64.349999999999994</code></p><p>从这里也可以看出浮点数都不精确！当对精确有要求的时候尽量避免使用浮点数。</p>]]></content>
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浮点数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker常用指令</title>
      <link href="/2017/11/23/%E6%8A%80%E6%9C%AF/docker/2017-11-23-Docker%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
      <url>/2017/11/23/%E6%8A%80%E6%9C%AF/docker/2017-11-23-Docker%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h3 id="Docker-常用指令"><a href="#Docker-常用指令" class="headerlink" title="Docker 常用指令"></a>Docker 常用指令</h3><p>作为一个开发最近才开始使用docker ，深感惭愧！<br>最近在学习 <code>CloudMan</code> 大佬的 <a href="http://mp.weixin.qq.com/s/7o8QxGydMTUe4Q7Tz46Diw" target="_blank" rel="noopener"><em>《每天5分钟玩转 Docker 容器技术》</em></a>, 通俗易懂，每天积累一点点，积累，这里记录一下常用的 docker 相关知识，仅做笔记用。</p><ol><li><p>查看本地的所有 <code>docker</code>镜像</p><pre><code>docker images</code></pre></li><li><p>查看指定镜像信息</p><pre><code>docker images ubuntu</code></pre></li><li><p>查看指定tag 的镜像信息</p><pre><code>docker images ubuntu:latest</code></pre></li></ol><ol start="4"><li><p>从 <code>Docker Hub</code> 下载镜像</p><pre><code>docker pull hello-world</code></pre></li><li><p>交互运行一个 container</p><pre><code>docker run -it ubuntu</code></pre></li></ol>]]></content>
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算广告学习笔记之名词汇总</title>
      <link href="/2017/09/01/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%90%8D%E8%AF%8D%E6%B1%87%E6%80%BB/"/>
      <url>/2017/09/01/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%90%8D%E8%AF%8D%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近看了刘鹏老师的《计算广告》，叹为惊止，对于接触广告投放业务不到一年的我产生了很大帮助，决定好好研读这本广告 <code>圣经</code></p><h4 id="计算广告名词汇总"><a href="#计算广告名词汇总" class="headerlink" title="计算广告名词汇总"></a>计算广告名词汇总</h4><p><code>广告主（Advisiter）</code>： 买广告位的个人或公司<br><code>媒体（media）</code>：卖广告位的个体<br><code>受众（audience）</code>：看广告的人</p><p>在线广告创意类型</p><ol><li><code>横幅广告</code></li><li><code>文字链广告</code></li><li><code>富媒体广告</code></li><li><code>视屏广告</code></li><li><code>社交广告</code>：社交广告是指几月社交信息，在用户的社交信息流中展示的广告，如你的还有对汽车很感兴趣，你们有很多的相似点，你将在你的朋友圈看到汽车广告</li><li><code>移动广告</code>：移动端的广告</li><li><code>邮件定向营销广告</code>：类似产品有通过广告、imessage等方式投放的广告</li></ol><p><code>展示广告（Display  Advertising）</code>：纸媒上的广告方式迁移到网页中<br><code>合约广告（Agreement-based Advertising）</code>: 采用合同方式约定某一个广告位在某一时间段为某特定广告主主所独占； CPT 结算方式<br><code>受众广告（Target  Advertising）</code>：针对不同用户投放不同的广告<br><code>受众定向（Audience  Targeting）</code>：收集用户信息，进行归类、贴标签<br><code>广告投放 （Advertising Serving）</code>：从静态页面变为实时从服务器获取要展示的广告信息</p><p><code>担保式投放（Guaranteed Delivery, GD）</code>：在合约广告的基础上，媒体向广告主保证，某个投放量，并确定投放量未完成的情况下 的赔偿方案。<br><code>按千次展现付费 (Cost per Mille, CPM)</code><br><code>在线分配(online allocation)</code>：对于每一次在线广告的展现进行实时决策，有效的将流量分配到各个合约互相交叉的人群覆盖上</p><p><code>竞价广告（auction-based advertising）</code><br><code>搜索广告（search advertising）</code>：用户输入关键词，根据关键词精确定位广告；广告主通过购买关键词来购买广告位资源<br><em>疑问：搜索广告和上下文广告中，广告主都是针对关键词出价，如果两个广告主都买了同一个广告词时，如果选择展示哪个广告？按照 eCPM 排序吗？</em><br><code>上下文广告（search advertising）</code>：将搜索广告中的搜索词换成页面的关键词，通过页面关键词定位广告</p><p><code>广义第二高价(Generalized Second Price, GSP)</code></p><p><code>ADN（AD Network）</code>：广告网络，批量运营媒体的广告位资源，按照人群或者上下文标签售卖给需求方，并用竞价的方式决定流量分配；在广告市场中广告网络的出现是为了批量聚合各媒体方的<code>剩余流量</code>，批量卖给需求方实现变现，因此广告网络提供的流量一般质量较差，广告网络先天性不适合投放品牌广告；国内主要公司产品：百度网盟</p><p><code>竞价广告网络</code>: 竞价售卖方式的广告网络，淡化广告位标的，售卖标的是根据标签划分的人群。产品特点如下</p><ol><li>竞价方式不向广告主做出量的约定，使得广告网络可以专注于对eCPM的估计</li><li>广告网络的出现就是为了批量聚合各媒体的<code>剩余流量</code>，淡化广告位，按人群售卖，很难拿到品牌溢价高的广告位，一般不适合品牌类广告</li><li>竞价广告的结算方式首推CPC, 屏蔽了广告位的概念之后，广告主无法估计每次展现出价，当使用CPC结算时，广告主只需要根据点击出价</li></ol><p><code>竞价广告需求方产品</code>: 1. 挑选广告合适的目标人群 2.针对目标人群给出合理的出价； 上述两个问题的根本就是优化<code>ROI</code><br>a) <code>搜索引擎营销(SEM Search Engine Marketing)</code>：选择合适的关键词；对关键词出价</p><p><code>CPC（Cost per click）</code>：按点击收费<br><code>TD（Trading Desk）</code>：交易终端，面对多个ADN或者媒体按人群一站式采买的广告并优化投入产出比的需求方产品</p><p><code>RTB（Real Time Bidding）</code>：实时竞价，针对每一次广告展现，向需求方产品发送广告位及用户标识，从需求方获取报价，比较各需求方的价格，选出最优价格，展示该需求方的广告<br><code>ADX (Advertising Exchange)</code>：广告交易平台，大量聚合媒体的剩余流量，并且通过实时竞价的方式将它们变现的产品形态<br><code>DSP（Demand Side Platform）</code>：需求方平台，通过实时竞价的方式，按照定制化的人群标签购买广告； 需求方平台将非竞价广告中需要广告交易平台来实现的对人群进行定制化标签划分工作给接管了，DSP 根据自身的第一方数据（来自DMP)面对市场提供的开放竞价接口，出价采买合适的广告<br><code>DMP (Data Management Platform)</code>：数据管理平台，收集第一方数据，为自身平台收集数据信息<br><code>数据交易平台 (Data Exchange Platform, DEP)</code> 数据交易平台，收集管理交易第三方数 据</p><p>第一方数据：广告主自身的数据<br>第二方数据：广告平台的数据<br>第三方数据：不直接参与广告交易的其他数据提供方的数据</p><p><code>重定向</code>: 针对在广告主网站有过操作的用户，精确投放操作相关的广告，提高转化率；缺点是只能提高ROI，无法获取新用户</p><ol><li>个性化重定向， 类似于站外推荐，依赖根据用户信息的精确推荐引擎，对于电商系统动态库存查询接口也是必要的</li></ol><p><code>新客推荐</code>: 在第一方数据的基础上，依赖第二方数据，针对“对自己的产品可能感兴趣”的用户进行广告投放，针对的是没有关注广告主网站的用户。</p><p><em><em>ADN 和 ADX 的差别在于，ADN将媒体资源分类后打包出售，而 ADX 针对每一次广告展现通过实时竞价的方式，单次售卖每一次广告展现</em></em></p><p><em><em>TD 和 DSP 的差别在于，TD 批量的从ADN 或者媒体采买广告，而 DSP 需要尽可能的估计每一次广告展现带来的期望价值，计算出一个合理的报价，通过实时竞价从ADX 购买广告</em></em></p><p><code>程序化交易(programmatic trade)</code></p><p><code>优选(preferred deals)</code>: 允许单个广告主按照自己的意愿挑选广告</p><p><code>私有交易市场(Private Market Place, PMP)</code>：邀请部分优质广告主，通过竞价方式，进行广告交易</p><p><code>媒介采买平台(media buying Platform)</code></p><p><code>原生广告(Native Advertising)</code>：将广告内容和页面信息尽量做到意向近似或展示形式近似</p><p><code>eCPM(expected Cost per Mille)</code>：千次展现期望收入，点击率和点击价值的乘积, <code>eCPM</code>的基础是对每次广告展现进行点击率预估</p><p><code>广告安全(AD safety)</code>：让合适的广告出现在合适的媒体上</p><p><code>CTR (Click Through Rate)</code>：点击率，广告点击和广告展现的比率</p><p><code>CVR (Conversion Rate)</code>：转化率，转化次数和到达次数的比例</p><pre><code>eCPM =  r(a,u,c) = μ(a,u,c) * v(a,u,c)(a:广告 u:用户 c:环境 r: 总收入 μ:点击率 v:点击价值)</code></pre><p>从上述表达式得出: 当点击价值恒定是，CTR == eCPM<br>eCPM代表DSP的出价，为了快速花完预算，可以将eCPM 预估的高于市场价；为了获得性价比高的流量，将eCPM定位在市场价较低的地方</p><p><em><em>eCPM 一般指的是估计的千次展现收益; RPM 指的是千次展现收入; CPM 是千次展示成本</em></em></p><p>广告结算方式</p><ol><li><code>CPM 结算</code>：按照千次展示结算，供给方和需求方约定好前次展示的计费标准，展示的收益效果由需求方把控</li><li><code>CPC 结算</code>：即按点击结算，供给方（或中间市场）提供点击率数据，需求方估计点击价值，并且通过点击出价的方式向市场通知自己的估价。优点是，供给方通过大量收集用户行为数据可以相对准确的估计点击率；广告主通过分析用户的站内行为数据，对点击价值作出评估。</li><li><code>CPS(Cose per sale)/ CPA(Cost Per Action)/ROI(Return Of Investment) 结算</code>：需求方按照转化收益结算，对需求方来说极大的规避了风险，对供给方来说既要估计点击率又要估计点击价值；在一些场景中供给方无法准确估计点击价值，该结算方式要求供给方能够较准确的估计点击价值或者能借助完善的第三方转化监测估计点击价值。</li><li><code>CPT(Cost per Time)</code>：将某个广告位在某段时间内以独占的方式售卖给广告主，价格由双方约定，无需计量；是品牌广告的不二选择</li></ol><p><code>垂直广告网络(vertical ad network)</code>：特定主题的广告网络，适用<code>CPS(Cose per sale)/ CPA(Cost Per Action)/ROI(Return Of Investment) 结算</code></p><p><code>合约广告产品</code>: 按照时段售卖的CPT 广告和按照约定展示量售卖的CPM广告<br><code>竞价广告产品</code>: 主要是搜索广告</p><p><code>流量预测</code>: 在担保式投放中，合约中明确约定了投放的量；那么对于供应方系统和广告交易系统来说，精准的<code>流量预测</code>能够让供应方在售卖流量的时候不会因为低估流量而导致流量浪费，也不会因为高估流量导致无法完成合同约定的投放量，总而言之，就是指导媒体方售卖流量；媒体方大多数情况下会和多个广告主之间签订担保投放合同，当一次广告展示符合多个合约的要求，如何决策分配给那个合约能达到整体满足所有合约的目的？在线分配强依赖于<code>流量预测</code>的结果，提高在线分配的效率和准确性；而在竞价广告中供应方不在担保投放量，此时需要广告主根据自己估计的流量预估出价；</p><p><code>流量塑形(traffic shaping)</code>: 在有些情况下我们需要主动地影响流量，如修改首页链接入口（待续！）</p><p><code>在线分配</code>: 在担保式投放中，多个合约覆盖的人群可能有……待续</p><p><code>位置拍卖</code>: 针对一次展现的一组广告位，按照其经验价值排名，在某次广告请求中去除前S个高出价的广告一次放到排序号的S个广告位上，此时可以假设点击率仅与位置s有关，点击价值仅与广告a有关</p><p><code>第二高价</code>: 在一个广告位的多轮竞价中，广告主会倾向于逐步降低自己的出价，降到比第二高价高一点点即可成为最高价，为了避免这一现象，我们按照竞价对垒中的第二高价进行收费，此时广告主A出价1元，广告主B出价2元时，广告主A没有降价的动力，广告主B如果降价可能会比广告主A更低，而且降价后加个不会低于1元，保证了市场的收益。<br><code>广义第二高价(GSP， Generalized Second Price)</code>: 将<code>第二高价</code>推广到一系列广告位的竞拍中，对赢得每个位置的广告主，都按照他的下一位的广告位置出价来收取费用。</p><p><code>VCG定价</code>: 对于赢得了某个位置的广告主，其所付出的成本应该等于他占据的位置给其他市场参与者带来的价值损害。</p><p><code>市场保留价(MRP, Market Reserve Price)</code>:对拍的一个广告位的最低价格，当竞争充分、广告主深度足够时，MRP可以设置的比较高；针对不同流量可以设置不同的MRP。</p><p><code>价格挤压</code><br>    r = μ^k * bid(cpc)<br>    k：一个大于0的实数，当k接近正无穷的时候，价格r只与点击率有关；当k接近于0的时候，价格只与cpc出价有关，称为<code>价格挤压因子</code></p><p><code>单位流量变现能力(Revenue per Mille, RMP)</code>: 中小媒体没有优秀的品牌价值，无法销售优质品牌溢价广告，只能重点关注单位流量的变现能努力</p><blockquote><p><code>广告投放引擎</code>: 实时响应广告请求，并决策广告的投放，并且从全局优化的角度管理整体收益；采用的还是类搜索架构（检索+排序）</p><blockquote><p><code>广告投放机</code>: 结合<code>广告投放引擎</code>的其他模块，接受广告前端web服务器发送来的请求，完成广告投放决策并返回最后页面片段的主逻辑</p></blockquote><blockquote><p><code>广告检索</code>: 在线时根据<code>用户标签</code>和<code>页面标签</code>从<code>广告索引</code>中查找符合条件的广告候选，送入<code>广告排序</code>模块</p></blockquote><blockquote><p><code>广告排序</code>: 结合离线特征（<code>CTR模型和特征</code>）和在线特征（<code>实时点击率特征</code>）预估点击率，实时计算出eCPM，并按此排序</p></blockquote><blockquote><p><code>收益管理</code>: 将部分<code>广告排序</code>的结果进一步调整，尽量调整到全局收益最优</p></blockquote><blockquote><p><code>广告请求接口</code>: 接受广告请求，并且将决策好的广告返回给媒体</p></blockquote><blockquote><p><code>定制化用户划分</code>: 根据广告主的逻辑来划分用户群；从广告主处收集用户信息和产品接口，数据经过复杂的加工之后，通过 <code>数据高速公路</code>导入<code>受众定向</code>模块</p></blockquote><p><code>离线数据处理平台</code>: 生成报表；通过数据挖掘、机器学习进行受众定向、点击率评估、分配策略规划</p><blockquote><p><code>用户会话日志生成</code>: 从各个渠道收集到的日志（点击日志等）先整理成已维护ID为键的统一存储格式。</p></blockquote><blockquote><p><code>行为定向</code>: 根据日志中的行为给用户打上<code>结构化标签库</code>中的某些标签，并将结果存储在用户标签的在线缓存中，供广告投放机使用</p></blockquote><blockquote><p><code>上下文定向</code>: 结合<code>半在线页面抓取</code>和上下文页面标签的缓存，与行为定向互相配合，给上下文页面打上标签，并将结果存储到<code>页面标签</code>的在线缓存中，供广告投放机使用</p></blockquote><blockquote><p><code>点击率建模</code>: 在<code>分布式计算平台</code>上训练得到点击率的模型参数和相应特征，加载到缓存中供线上投放系统决策时使用</p></blockquote><blockquote><p><code>分配规划</code>: 根据广告系统全局优化的具体要求，利用离线日志数据进行规划，得到适合线上执行<code>分配方案</code></p></blockquote><blockquote><p><code>商业智能</code>:</p></blockquote></blockquote><p><code>广告排期系统</code>: 一般技术方案是将广告素材按预先确定的排期直接插入媒体页面，并通过<code>内容分发网络(Content Delivery Network CDN)</code>加速访问</p><p><code>奇异值分析</code><br><code>潜在语义分析</code></p>]]></content>
      
      <categories>
          
          <category> 计算广告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算广告 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql常用指令</title>
      <link href="/2017/05/22/%E6%8A%80%E6%9C%AF/mysql/2017-05-22-mysql%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
      <url>/2017/05/22/%E6%8A%80%E6%9C%AF/mysql/2017-05-22-mysql%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h3 id="执行-sql-文件"><a href="#执行-sql-文件" class="headerlink" title="执行 .sql 文件"></a>执行 <code>.sql</code> 文件</h3><p><em>方法1</em></p><pre><code>mysql -h1.1.1.1 -P3306 -uadmin -ppwd db_name &lt; test.sql</code></pre><p><em>方法2</em></p><ol><li>使用 <code>mysql-client</code> 登录到 mysql 服务器</li><li>source /root/path/to/.sql</li></ol><h3 id="mysql-查看-binlog"><a href="#mysql-查看-binlog" class="headerlink" title="mysql 查看 binlog"></a>mysql 查看 binlog</h3><p><code>mysql</code> 提供了 <code>mysqlbinlog</code> 指令，用于查看binlog</p><p>先来一个小例子, 查看某一段时间的 bin log</p><pre><code>mysqlbinlog -h[host]  -P[port] -u[username] -p[password] --read-from-remote-server [binlog file name]--base64-output=decode-rows --start-datetime=&apos;2017-11-02 00:00:00&apos;--stop-datetime=&apos;2017-11-02 00:10:00&apos;</code></pre><p>看了上面这个小例子，发现一个小问题: <em><em>binlog file name 从哪来？</em></em><br>这个需要我们去mysql中去查看</p><pre><code>mysql&gt; mysql -u[username] -p[password]    ## 登录mysqlmysql&gt; show variables like &apos;log_bin&apos;;+---------------+-------+| Variable_name | Value |+---------------+-------+| log_bin       | OFF   | # 这个参数说明当前mysql 没有开启binlog 日志+---------------+-------+</code></pre><p>这里又引入一个问题: <em><em>如何开启 mysql 的 binlog</em></em></p><p>在 <code>mysql</code> 的 <code>官方文档</code> 中，对于 <code>binlog</code> 的开启只有一段内容</p><pre><code>Binary logging is enabled by default (the log_bin system variable is set to ON). The exception is if you use mysqld to initialize the data directory manually by invoking it with the --initialize or --initialize-insecure option, when binary logging is disabled by default, but can be enabled by specifying the --log-bin option.二进制日志是默认启用（系统变量log_bin默认设置为ON）。唯一的例外是如果你使用mysqld来初始化数据目录手动调用它的 --initialize 或 --initialize-insecure 选项，当二进制日志默认是禁用的，但可以通过指定 `--log-bin` 选项启用。</code></pre><p>我们开始设置 <code>mysql</code> 的启动配置， 这里有两种方式</p><ol><li><p>直接在启动命令行中添加参数</p><pre><code>sudo /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --log-bin=mysql-bin --user=\_mysql</code></pre></li><li><p>在 mysql 配置文件中增加配置信息<br>这个时候我们遇到一个问题: Mysql 的配置文件在哪？</p><pre><code>&gt; sudo mysqld --verbose --help | grep -A2 &quot;Default options are read from the following files in the given order:&quot;Default options are read from the following files in the given order:/etc/my.cnf /etc/mysql/my.cnf /usr/local/mysql/etc/my.cnf ~/.my.cnf</code></pre></li></ol><p>从上面可以看到 <code>mysql</code> 的配置文件如下：</p><pre><code>/etc/my.cnf /etc/mysql/my.cnf /usr/local/mysql/etc/my.cnf ~/.my.cnf</code></pre><p>在 <code>/etc/my.cnf</code> 添加配置如下</p><pre><code>[mysqld]basedir=/usr/local/mysqldatadir=/usr/local/mysql/dataplugin-dir=/usr/local/mysql/lib/pluginuser=\_mysqllog-bin=mysql-binport=3306</code></pre><p>我们来尝试启动 <code>mysql</code>，但是却没能启动成功， 报错信息如下</p><pre><code>[ERROR] You have enabled the binary log, but you haven&apos;t provided the mandatory server-id. Please refer to the proper server start-up parameters documentation</code></pre><p>遇到问题，我们再去看看官方文档，在官方文档中有如下介绍，在 mysql 5.7 及以上版本中，需要设置参数 <code>server-id</code></p><pre><code>In MySQL 5.7, a server ID had to be specified when binary logging was enabled, or the server would not start. The server_id system variable is set to 1 by default. The server can be started with this default ID when binary logging is enabled, but a warning message is issued if you do not specify a server ID explicitly using the --server-id option. For servers that are used in a replication topology, you must specify a unique non-zero server ID for each server.在MySQL 5.7中，当启用二进制日志时，必须指定服务器ID，否则服务器将无法启动。系统变量 server_id 默认设置为1。当启用二进制日志记录时，服务器可以以这个默认ID启动，但如果未显式使用服务器ID选项指定服务器ID，则会发出警告消息。对于复制拓扑中使用的服务器，必须为每个服务器指定唯一的非零服务器ID。</code></pre><p>将 <code>/etc/my.cnf</code> 配置修改如下：</p><pre><code>[mysqld]basedir=/usr/local/mysqldatadir=/usr/local/mysql/dataplugin-dir=/usr/local/mysql/lib/pluginuser=\_mysqllog-bin=mysql-binport=3306server-id=1</code></pre><p>再次启动mysql，成功了！但是有个问题，mysql 的日志直接输出在控制台中，需要输出到指定文件夹中，在 <code>/etc/my.cnf</code> 的 <code>[mysqld]</code> 中增加配置</p><pre><code>log-error=/usr/local/mysql/data/local.err</code></pre><p>我们开启了binlog之后，可以使用 <code>mysqlbinlog</code> 来查看binlog了！<br>回到第一个问题 <em><em>binlog file name 从哪来？</em></em></p><pre><code>mysql&gt; show master status;+------------------+-----------+--------------+------------------+-------------------------------------------------+| File             | Position  | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set                               |+------------------+-----------+--------------+------------------+-------------------------------------------------+| mysql-bin.000065 | 516819919 |              |                  | 63c58e9d-e063-11e6-8a0e-6c92bf324c90:1-19804498 |+------------------+-----------+--------------+------------------+-------------------------------------------------+1 row in set (0.00 sec)</code></pre><p>这里第一列就是 binlog 日志文件的名称了！</p><pre><code>mysqlbinlog-?, --help          Display this help and exit.                    查看帮助信息--base64-output=name                    Determine when the output statements should be                    base64-encoded BINLOG statements: &apos;never&apos; disables it and                    works only for binlogs without row-based events;                    &apos;decode-rows&apos; decodes row events into commented                    pseudo-SQL statements if the --verbose option is also                    given; &apos;auto&apos; prints base64 only when necessary (i.e.,                    for row-based events and format description events).  If                    no --base64-output[=name] option is given at all, the                    default is &apos;auto&apos;.--bind-address=name IP address to bind to.--character-sets-dir=name                    Directory for character set files.-d, --database=name 指明查询binlog 的数据库，如：-dtest，查看test 数据库--rewrite-db=name   Rewrite the row event to point so that it can be applied                    to a new database-#, --debug[=#]     This is a non-debug version. Catch this and exit.--debug-check       This is a non-debug version. Catch this and exit.--debug-info        This is a non-debug version. Catch this and exit.--default-auth=name Default authentication client-side plugin to use.-D, --disable-log-bin                    Disable binary log. This is useful, if you enabled                    --to-last-log and are sending the output to the same                    MySQL server. This way you could avoid an endless loop.                    You would also like to use it when restoring after a                    crash to avoid duplication of the statements you already                    have. NOTE: you will need a SUPER privilege to use this                    option.-F, --force-if-open Force if binlog was not closed properly.                    (Defaults to on; use --skip-force-if-open to disable.)-f, --force-read    Force reading unknown binlog events.-H, --hexdump       Augment output with hexadecimal and ASCII event dump.-h, --host=name     Get the binlog from server.-i, --idempotent    Notify the server to use idempotent mode before applying                    Row Events-l, --local-load=name                    Prepare local temporary files for LOAD DATA INFILE in the                    specified directory.-o, --offset=#      Skip the first N entries.-p, --password[=name]                    Password to connect to remote server.--plugin-dir=name   Directory for client-side plugins.-P, --port=#        Port number to use for connection or 0 for default to, in                    order of preference, my.cnf, $MYSQL_TCP_PORT,                    /etc/services, built-in default (3306).--protocol=name     The protocol to use for connection (tcp, socket, pipe,                    memory).-R, --read-from-remote-server                    Read binary logs from a MySQL server. This is an alias                    for read-from-remote-master=BINLOG-DUMP-NON-GTIDS.--read-from-remote-master=name                    Read binary logs from a MySQL server through the                    COM_BINLOG_DUMP or COM_BINLOG_DUMP_GTID commands by                    setting the option to either BINLOG-DUMP-NON-GTIDS or                    BINLOG-DUMP-GTIDS, respectively. If                    --read-from-remote-master=BINLOG-DUMP-GTIDS is combined                    with --exclude-gtids, transactions can be filtered out on                    the master avoiding unnecessary network traffic.--raw               Requires -R. Output raw binlog data instead of SQL                    statements, output is to log files.-r, --result-file=name                    Direct output to a given file. With --raw this is a                    prefix for the file names.--secure-auth       Refuse client connecting to server if it uses old                    (pre-4.1.1) protocol. Deprecated. Always TRUE--server-id=#       Extract only binlog entries created by the server having                    the given id.--server-id-bits=#  Set number of significant bits in server-id--set-charset=name  Add &apos;SET NAMES character_set&apos; to the output.-s, --short-form    Just show regular queries: no extra info and no row-based                    events. This is for testing only, and should not be used                    in production systems. If you want to suppress                    base64-output, consider using --base64-output=never                    instead.-S, --socket=name   The socket file to use for connection.--ssl-mode=name     SSL connection mode.--ssl               Deprecated. Use --ssl-mode instead.                    (Defaults to on; use --skip-ssl to disable.)--ssl-verify-server-cert                    Deprecated. Use --ssl-mode=VERIFY_IDENTITY instead.--ssl-ca=name       CA file in PEM format.--ssl-capath=name   CA directory.--ssl-cert=name     X509 cert in PEM format.--ssl-cipher=name   SSL cipher to use.--ssl-key=name      X509 key in PEM format.--ssl-crl=name      Certificate revocation list.--ssl-crlpath=name  Certificate revocation list path.--tls-version=name  TLS version to use, permitted values are: TLSv1, TLSv1.1--start-datetime=name                    Start reading the binlog at first event having a datetime                    equal or posterior to the argument; the argument must be                    a date and time in the local time zone, in any format                    accepted by the MySQL server for DATETIME and TIMESTAMP                    types, for example: 2004-12-25 11:25:56 (you should                    probably use quotes for your shell to set it properly).-j, --start-position=#                    Start reading the binlog at position N. Applies to the                    first binlog passed on the command line.--stop-datetime=name                    Stop reading the binlog at first event having a datetime                    equal or posterior to the argument; the argument must be                    a date and time in the local time zone, in any format                    accepted by the MySQL server for DATETIME and TIMESTAMP                    types, for example: 2004-12-25 11:25:56 (you should                    probably use quotes for your shell to set it properly).--stop-never        Wait for more data from the server instead of stopping at                    the end of the last log. Implicitly sets --to-last-log                    but instead of stopping at the end of the last log it                    continues to wait till the server disconnects.--stop-never-slave-server-id=#                    The slave server_id used for --read-from-remote-server                    --stop-never. This option cannot be used together with                    connection-server-id.--connection-server-id=#                    The slave server_id used for --read-from-remote-server.                    This option cannot be used together with                    stop-never-slave-server-id.--stop-position=#   Stop reading the binlog at position N. Applies to the                    last binlog passed on the command line.-t, --to-last-log   Requires -R. Will not stop at the end of the requested                    binlog but rather continue printing until the end of the                    last binlog of the MySQL server. If you send the output                    to the same MySQL server, that may lead to an endless                    loop.-u, --user=name     链接数据库的用户名-v, --verbose       Reconstruct pseudo-SQL statements out of row events. -v                    -v adds comments on column data types.-V, --version       查看 `mysqlbinlog` 版本信息--open-files-limit=#                    Used to reserve file descriptors for use by this program.-c, --verify-binlog-checksum                    Verify checksum binlog events.--binlog-row-event-max-size=#                    The maximum size of a row-based binary log event in                    bytes. Rows will be grouped into events smaller than this                    size if possible. This value must be a multiple of 256.--skip-gtids        Do not preserve Global Transaction Identifiers; instead                    make the server execute the transactions as if they were                    new.--include-gtids=name                    打印binlog 信息时，只打印指定的部分全局事务id对应的binglog 信息--exclude-gtids=name                    打印binlog 信息时，排除部分全局事务id对应的binglog 信息</code></pre><h4 id="待解决问题"><a href="#待解决问题" class="headerlink" title="待解决问题"></a>待解决问题</h4><p>如果在 mac os 的设置中启动了mysql 而且勾选了 <code>Automatically Start MySQL Server on Startup</code>, 当你想要关闭 mysql 的时候，mysql 会自动重启！！！<br>这个问题找了好久才发现，至于这个不断重启功能的实现待研究…</p><h3 id="mysql-查看存储过程"><a href="#mysql-查看存储过程" class="headerlink" title="mysql 查看存储过程"></a>mysql 查看存储过程</h3><h4 id="查看存储过程状态"><a href="#查看存储过程状态" class="headerlink" title="查看存储过程状态"></a>查看存储过程状态</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">procedure</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure><p>输出结果：</p><pre><code>mysql&gt; show procedure status\G*************************** 1. row ***************************              Db: db_name            Name: procedure_name            Type: PROCEDURE         Definer: root@localhost        Modified: 2017-05-10 14:10:00         Created: 2017-05-10 14:10:00   Security_type: DEFINER         Comment:character_set_client: utf8mb4collation_connection: utf8mb4_general_ciDatabase Collation: utf8_general_ci1 row in set (0.02 sec)</code></pre><h4 id="查看存储过程具体定义"><a href="#查看存储过程具体定义" class="headerlink" title="查看存储过程具体定义"></a>查看存储过程具体定义</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> %procedure_name%;</span><br></pre></td></tr></table></figure><h4 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h4><p><strong><em>注意：在创建存储过程的时候，语句中的分号会导致报错，需要用 <code>DELIMITER</code> 重新定义分隔符</em></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="comment">-- to create procedure</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h4 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> &#123;<span class="keyword">PROCEDURE</span> | <span class="keyword">FUNCTION</span>&#125; [<span class="keyword">IF</span> <span class="keyword">EXISTS</span>] sp_name</span><br></pre></td></tr></table></figure><h3 id="mysql-查看数据库和表容量大小"><a href="#mysql-查看数据库和表容量大小" class="headerlink" title="mysql 查看数据库和表容量大小"></a>mysql 查看数据库和表容量大小</h3><p><code>information_schema</code> 库中有个 <code>TABLES</code> 表</p><pre><code>mysql&gt; show create table TABLES\G*************************** 1. row ***************************Table: TABLESCreate Table: CREATE TEMPORARY TABLE `TABLES` (`TABLE_CATALOG` varchar(512) NOT NULL DEFAULT &apos;&apos;,`TABLE_SCHEMA` varchar(64) NOT NULL DEFAULT &apos;&apos;,`TABLE_NAME` varchar(64) NOT NULL DEFAULT &apos;&apos;,`TABLE_TYPE` varchar(64) NOT NULL DEFAULT &apos;&apos;,`ENGINE` varchar(64) DEFAULT NULL,`VERSION` bigint(21) unsigned DEFAULT NULL,`ROW_FORMAT` varchar(10) DEFAULT NULL,`TABLE_ROWS` bigint(21) unsigned DEFAULT NULL,`AVG_ROW_LENGTH` bigint(21) unsigned DEFAULT NULL,`DATA_LENGTH` bigint(21) unsigned DEFAULT NULL,`MAX_DATA_LENGTH` bigint(21) unsigned DEFAULT NULL,`INDEX_LENGTH` bigint(21) unsigned DEFAULT NULL,`DATA_FREE` bigint(21) unsigned DEFAULT NULL,`AUTO_INCREMENT` bigint(21) unsigned DEFAULT NULL,`CREATE_TIME` datetime DEFAULT NULL,`UPDATE_TIME` datetime DEFAULT NULL,`CHECK_TIME` datetime DEFAULT NULL,`TABLE_COLLATION` varchar(32) DEFAULT NULL,`CHECKSUM` bigint(21) unsigned DEFAULT NULL,`CREATE_OPTIONS` varchar(255) DEFAULT NULL,`TABLE_COMMENT` varchar(2048) NOT NULL DEFAULT &apos;&apos;) ENGINE=MEMORY DEFAULT CHARSET=utf81 row in set (0.00 sec)</code></pre><p>其中主要字段是</p><p><code>TABLE_SCHEMA</code>: 数据库名称<br><code>TABLE_NAME</code>: 表名称<br><code>DATA_LENGTH</code>: 数据占用的空间大小，单位是字节<br><code>INDEX_LENGTH</code>: 索引占用的空间大小，单位是字节</p><h4 id="查看数据库占用空间大小"><a href="#查看数据库占用空间大小" class="headerlink" title="查看数据库占用空间大小"></a>查看数据库占用空间大小</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (<span class="keyword">SUM</span>(DATA_LENGTH) + <span class="keyword">SUM</span>(INDEX_LENGTH)) / <span class="number">1024</span> / <span class="number">1024</span></span><br><span class="line"><span class="keyword">FROM</span> information_schema.TABLES</span><br><span class="line"><span class="keyword">WHERE</span> TABLE_SCHEMA = <span class="string">'database_name'</span>;</span><br></pre></td></tr></table></figure><h4 id="查看表占用空间大小"><a href="#查看表占用空间大小" class="headerlink" title="查看表占用空间大小"></a>查看表占用空间大小</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (<span class="keyword">SUM</span>(DATA_LENGTH) + <span class="keyword">SUM</span>(INDEX_LENGTH)) / <span class="number">1024</span> / <span class="number">1024</span></span><br><span class="line"><span class="keyword">FROM</span> information_schema.TABLES</span><br><span class="line"><span class="keyword">WHERE</span> TABLE_NAME = <span class="string">'table_name'</span>;</span><br></pre></td></tr></table></figure><h3 id="mysql-求时间差距"><a href="#mysql-求时间差距" class="headerlink" title="mysql 求时间差距"></a>mysql 求时间差距</h3><p><code>timestampdiff(unit,datetime_expr1,datetime_expr2)</code> 比较两个 timestamp 时间间隔，返回单位是unit 的数值</p><p>例如</p><p><code>timestampdiff(second,&#39;2018-01-01 00:00:00&#39;,&#39;2018-01-01 00:00:02&#39;)</code> 得到 2</p><h3 id="表结构常用修改语句"><a href="#表结构常用修改语句" class="headerlink" title="表结构常用修改语句"></a>表结构常用修改语句</h3><h4 id="重置-AUTO-INCREMENT"><a href="#重置-AUTO-INCREMENT" class="headerlink" title="重置 AUTO_INCREMENT"></a>重置 AUTO_INCREMENT</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;<span class="keyword">Table</span> <span class="keyword">Name</span>&gt; AUTO_INCREMENT = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何正确的创建 prototype 类型的 bean</title>
      <link href="/2017/03/01/%E6%8A%80%E6%9C%AF/spring/2017-03-01-Spring%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2017/03/01/%E6%8A%80%E6%9C%AF/spring/2017-03-01-Spring%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这里把使用 <code>Spring</code> 过程中遇到的问题做个记录，有些给出了解决方案，有些没有，欢迎同道读者斧正！</p><h2 id="如何正确的创建-prototype-类型的-Spring-bean"><a href="#如何正确的创建-prototype-类型的-Spring-bean" class="headerlink" title="如何正确的创建 prototype 类型的 Spring bean"></a>如何正确的创建 <code>prototype</code> 类型的 <code>Spring bean</code></h2><p>这里先尝试的去创建一个 <code>prototype</code> 的 <code>bean</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtoTypeComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> random;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ProtoTypeComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// random 值设置为一个随机值，</span></span><br><span class="line">    <span class="keyword">this</span>.random = ThreadLocalRandom.current().nextInt(<span class="number">100000</span>);</span><br><span class="line">    LOGGER.info(<span class="string">"create a new ProtoTypeComponent with random:&#123;&#125;"</span>, random);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> random;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们在Controller 中注入这个 <code>prototype bean</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> ProtoTypeComponent protoTypeComponent;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>)</span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&#123;\"class\": \""</span> + protoTypeComponent + <span class="string">"\", \"random\":\""</span></span><br><span class="line">        + protoTypeComponent.getRandom() + <span class="string">"\"&#125;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们开始请求这个 http 接口</p><p><img src="/assets/picture/prototypebeaninfo.png" alt title="请求上方 /hello 接口获取 prototype bean 信息"></p><p>不断的刷新页面，返回的结果都是一模一样！我们再来看看日志</p><p><img src="/assets/picture/prototypecomponent.png" alt title="请求上方 /hello 接口时的日志信息"></p><p>从上面的日志上我们看到这个 <code>prototype bean</code> 的构造方法只被调用了一次！</p><p>到这里，我感到奇怪了，为什么这个 <code>prototype bean</code> 成了 <code>singleton bean</code> 了？</p><p>这个时候我想了 《Spring揭秘》 中看到的正解， 之前这个现象出现的原因是 <code>HelloController</code> 是 <code>singleton</code> 类型的，这个 <code>bean</code> 只会被初始化一次， 而 <code>HelloController</code> 依赖的 <code>ProtoTypeComponent</code> 也只会被注入一次！<br>到这里，谜底揭晓：</p><p><em><code>singleton bean</code> 依赖的 <code>prototype bean</code> 会 “变成” <code>singleton bean</code></em></p><p>这里，解决这个问题的第一个方案也出现了：</p><h6 id="依赖-prototype-bean-也必须是-prototype-bean"><a href="#依赖-prototype-bean-也必须是-prototype-bean" class="headerlink" title="依赖 prototype bean 也必须是 prototype bean"></a>依赖 <code>prototype bean</code> 也必须是 <code>prototype bean</code></h6><p>很明显这个方案不能解决很多状况， 我们继续这个问题</p><p>再来翻翻 <code>《Spring 揭秘》</code> 找找答案<br>我们看到了两个答案</p><ol><li>使用方法注入</li><li>继承 ApplicationContextAware 每次去获取bean</li></ol><h5 id="使用方法注入"><a href="#使用方法注入" class="headerlink" title="使用方法注入"></a>使用方法注入</h5><p>在传统的 xml 配置方式中我们需要这样配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"protoTypeBean"</span> <span class="attr">class</span>=<span class="string">"...impl.ProtoTypeService"</span> <span class="attr">singleton</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span> = <span class="string">"...impl.SimpleServiceImpl"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">"getProtoTypeBean"</span> <span class="attr">bean</span>=<span class="string">"protoTypeBean"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>getProtoTypeBean 方法定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ProtoTypeService protoTypeBean;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProtoTypeService <span class="title">getProtoTypeBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> protoTypeBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们更倾向于使用注解，那么基于注解怎么实现上面这种方式呢？<br>我们这里引入 <code>@Lookup</code> 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An annotation that indicates 'lookup' methods, to be overridden by the container</span></span><br><span class="line"><span class="comment"> * to redirect them back to the &#123;<span class="doctag">@link</span> org.springframework.beans.factory.BeanFactory&#125;</span></span><br><span class="line"><span class="comment"> * for a &#123;<span class="doctag">@code</span> getBean&#125; call. This is essentially an annotation-based version of the</span></span><br><span class="line"><span class="comment"> * XML &#123;<span class="doctag">@code</span> lookup-method&#125; attribute, resulting in the same runtime arrangement.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The resolution of the target bean can either be based on the return type</span></span><br><span class="line"><span class="comment"> * (&#123;<span class="doctag">@code</span> getBean(Class)&#125;) or on a suggested bean name (&#123;<span class="doctag">@code</span> getBean(String)&#125;),</span></span><br><span class="line"><span class="comment"> * in both cases passing the method's arguments to the &#123;<span class="doctag">@code</span> getBean&#125; call</span></span><br><span class="line"><span class="comment"> * for applying them as target factory method arguments or constructor arguments.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Such lookup methods can have default (stub) implementations that will simply</span></span><br><span class="line"><span class="comment"> * get replaced by the container, or they can be declared as abstract - for the</span></span><br><span class="line"><span class="comment"> * container to fill them in at runtime. In both cases, the container will generate</span></span><br><span class="line"><span class="comment"> * runtime subclasses of the method's containing class via CGLIB, which is why such</span></span><br><span class="line"><span class="comment"> * lookup methods can only work on beans that the container instantiates through</span></span><br><span class="line"><span class="comment"> * regular constructors: i.e. lookup methods cannot get replaced on beans returned</span></span><br><span class="line"><span class="comment"> * from factory methods where we cannot dynamically provide a subclass for them.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;Concrete limitations in typical Spring configuration scenarios:&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * When used with component scanning or any other mechanism that filters out abstract</span></span><br><span class="line"><span class="comment"> * beans, provide stub implementations of your lookup methods to be able to declare</span></span><br><span class="line"><span class="comment"> * them as concrete classes. And please remember that lookup methods won't work on</span></span><br><span class="line"><span class="comment"> * beans returned from &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; methods in configuration classes; you'll have</span></span><br><span class="line"><span class="comment"> * to resort to &#123;<span class="doctag">@code</span> <span class="doctag">@Inject</span> Provider&amp;lt;TargetBean&amp;gt;&#125; or the like instead.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.BeanFactory#getBean(Class, Object...)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.BeanFactory#getBean(String, Object...)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Lookup &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This annotation attribute may suggest a target bean name to look up.</span></span><br><span class="line"><span class="comment"> * If not specified, the target bean will be resolved based on the</span></span><br><span class="line"><span class="comment"> * annotated method's return type declaration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br></pre></td></tr></table></figure><p>从上面的代码能看出：<br>这个注解只能修饰方法，根据方法的返回值类型创建对应的Bean，底层机制是调用 <code>org.springframework.beans.factory.BeanFactory#getBean(Class, Object...)</code> 或 <code>org.springframework.beans.factory.BeanFactory#getBean(String, Object...)</code></p><p>先来使用 <code>@Lookup</code> 注解改成一下我们尝试创建 有状态的 <code>prototype bean</code></p><p>修正的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ProtoTypeComponent protoTypeComponent;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>)</span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ProtoTypeComponent component = getProtoTypeComponent();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&#123;\"class\": \""</span> + component + <span class="string">"\", \"random\":\""</span></span><br><span class="line">        + component.getRandom() + <span class="string">"\"&#125;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Lookup</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ProtoTypeComponent <span class="title">getProtoTypeComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> protoTypeComponent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们运行起 <code>tomcat</code> 看看结果：</p><p><img src="/assets/picture/realProtoTypeComponent1.png" alt><br><img src="/assets/picture/realProtoTypeComponent2.png" alt></p><p>很明显，我们成功的创建了 <code>prototype bean</code>!</p><h5 id="继承-ApplicationContextAware-每次去获取bean"><a href="#继承-ApplicationContextAware-每次去获取bean" class="headerlink" title="继承 ApplicationContextAware 每次去获取bean"></a>继承 ApplicationContextAware 每次去获取bean</h5><p>这里不推荐使用 <code>ApplicationContextAware</code> 所以不给出方法了。</p>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Maven 继承方式： scope import</title>
      <link href="/2017/02/12/%E6%8A%80%E6%9C%AF/maven/Maven%20scope%20import/"/>
      <url>/2017/02/12/%E6%8A%80%E6%9C%AF/maven/Maven%20scope%20import/</url>
      <content type="html"><![CDATA[<h3 id="使用-scope-import-解决Maven-单继承问题"><a href="#使用-scope-import-解决Maven-单继承问题" class="headerlink" title="使用 scope import 解决Maven 单继承问题"></a>使用 <code>scope import</code> 解决Maven 单继承问题</h3><p><code>Maven</code> 本身支持继承，很多时候我们会创建多模块项目，而多个模块会引入相同的依赖项，这个时候我们就能使用 <code>Maven</code> 的父子工程结构，<br>创建一个父 pom 文件，其他子项目中的 pom 文件继承父pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>base.parent<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>--&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent.management<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样我们就能是的依赖项的管理更加有条理</p><p>但是 <code>Maven</code> 父子项目结构和 Java继承一样，都是单继承，一个子项目只能制定一个父 pom</p><p>很多时候，我们需要打破这种 <code>单继承</code></p><p>例如使用 <code>spring-boot</code> 的时候， 官方推荐的方式是继承父pom <code>spring-boot-starter-parent</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是如果项目中已经有了其他父pom， 又想用 <code>spring-boot</code> 怎么办呢？</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>就是使用 <code>scope import</code>， 还需要指定 <code>type pom</code></p><p><em>注意：<code>scope import</code> 只能在 <code>dependencyManagement</code> 中的使用</em></p>]]></content>
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Boot 初涉</title>
      <link href="/2017/02/12/%E6%8A%80%E6%9C%AF/spring/2017-02-12-SpringBoot/"/>
      <url>/2017/02/12/%E6%8A%80%E6%9C%AF/spring/2017-02-12-SpringBoot/</url>
      <content type="html"><![CDATA[<h4 id="使用-Maven-构建-Spring-Boot-项目"><a href="#使用-Maven-构建-Spring-Boot-项目" class="headerlink" title="使用 Maven 构建 Spring-Boot 项目"></a>使用 <code>Maven</code> 构建 Spring-Boot 项目</h4><ol><li>继承 父pmo 构建 Spring-Boot 项目</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- ...... the artifactId and groupId of the application --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 继承 spring-boot-starter-parent 使用 spring-boot的最优方法； 也可以不继承这个父pom，使用其他方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置插件，打包jar包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- ...... the artifactId and groupId of the application --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- Override Spring Data release train provided by Spring Boot --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-releasetrain<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>Fowler-SR2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">              <span class="comment">&lt;!--  --&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置插件，打包jar包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="dev-tools"><a href="#dev-tools" class="headerlink" title="dev-tools"></a>dev-tools</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 设置插件，打包jar包 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用 dev-tools 需要禁用默认的 excludeDevtools --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeDevtools</span>&gt;</span>false<span class="tag">&lt;/<span class="name">excludeDevtools</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>DevToolsPropertyDefaultsPostProcessor</p>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMVC 容器 和 Spring 容器</title>
      <link href="/2017/01/21/%E6%8A%80%E6%9C%AF/spring/2017-01-21-SpringMvc%E5%92%8CSpring%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8/"/>
      <url>/2017/01/21/%E6%8A%80%E6%9C%AF/spring/2017-01-21-SpringMvc%E5%92%8CSpring%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8/</url>
      <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>在使用 <code>Spring MVC</code> 的过程中，遇到一个问题，在 <code>Spring 容器</code> 中注册的属性文件， 在 <code>SpringMVC 容器</code> 中无法用 <code>@Value</code> 标签引入！<br>按理说， <code>SpringMVC 容器</code> 应该能继承父容器中的所有Bean， 为什么不能使用父容器中引入的配置文件信息呢？</p><p><em>很遗憾，这个问题暂时没能找到答案，如果哪位大神能解答，请告知</em></p><p>但是问题还是要解决的， 我们只能换个思路解决。 如果 <code>SpringMVC 子容器</code> 和 <code>Spring 父容器</code> 如果合一了，不就不存在需要重复引入的问题吗？<br>那么问题来了：</p><h3 id="SpringMVC-容器和-Spring-容器能合一吗？"><a href="#SpringMVC-容器和-Spring-容器能合一吗？" class="headerlink" title="SpringMVC 容器和 Spring 容器能合一吗？"></a>SpringMVC 容器和 Spring 容器能合一吗？</h3><p>先来看看一般我们使用 <code>SpringMVC</code> 的 <code>web.xml</code> 配置文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE web-app PUBLIC</span><br><span class="line">        &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span><br><span class="line">        &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;</span><br><span class="line"></span><br><span class="line">&lt;web-app&gt;</span><br><span class="line">    &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- spring 父容器配置文件路径 --&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;classpath:spring/spring-root.xml&lt;/param-value&gt;</span><br><span class="line">    &lt;/context-param&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- listener：加载spring 父容器 --&gt;</span><br><span class="line">    &lt;listener&gt;</span><br><span class="line">        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">    &lt;/listener&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;!-- spring mvc 子容器配置文件路径，如果不配置默认为 /WEB-INF/*-servlet.xml --&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">            &lt;param-value&gt;classpath:spring/spring-mvc.xml&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">    &lt;error-page&gt;</span><br><span class="line">        &lt;error-code&gt;500&lt;/error-code&gt;</span><br><span class="line">        &lt;location&gt;/error.jsp&lt;/location&gt;</span><br><span class="line">    &lt;/error-page&gt;</span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><p><code>Tomcat</code> 在解析 <code>web.xml</code> 的时候先后加载 <code>listener</code> -&gt; <code>filter</code> -&gt; <code>servlet</code><br>先记载 <code>ContextLoaderListener</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 覆写 `ServletContextListener` 中的 `contextInitialized` 方法，</span></span><br><span class="line"><span class="comment">* 实现时，调用父类的 `initWebApplicationContext` 方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">initWebApplicationContext(event.getServletContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> servletContext 当前 web 容器上下文</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> spring 容器上下文</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #ContextLoader(WebApplicationContext)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #CONTEXT_CLASS_PARAM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #CONFIG_LOCATION_PARAM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="string">"Cannot initialize context because there is already a root application context present - "</span> +</span><br><span class="line"><span class="string">"check whether you have multiple ContextLoader* definitions in your web.xml!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Log logger = LogFactory.getLog(ContextLoader.class);</span><br><span class="line">servletContext.log(<span class="string">"Initializing Spring root WebApplicationContext"</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Root WebApplicationContext: initialization started"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 创建一个 WebApplicationContext 实例</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.context == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.context = createWebApplicationContext(servletContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.context <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) <span class="keyword">this</span>.context;</span><br><span class="line"><span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line"><span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line"><span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line"><span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// The context instance was injected without an explicit parent -&gt;</span></span><br><span class="line"><span class="comment">// determine parent for root web application context, if any.</span></span><br><span class="line">ApplicationContext parent = loadParentContext(servletContext);</span><br><span class="line">cwac.setParent(parent);</span><br><span class="line">&#125;</span><br><span class="line">configureAndRefreshWebApplicationContext(cwac, servletContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前创建的spring 父容器注册到 web 容器中， 属性名称是： org.springframework.web.context.WebApplicationContext.ROOT</span></span><br><span class="line">servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.context);</span><br><span class="line"></span><br><span class="line">ClassLoader ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line"><span class="keyword">if</span> (ccl == ContextLoader.class.getClassLoader()) &#123;</span><br><span class="line">currentContext = <span class="keyword">this</span>.context;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ccl != <span class="keyword">null</span>) &#123;</span><br><span class="line">currentContextPerThread.put(ccl, <span class="keyword">this</span>.context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Published root WebApplicationContext as ServletContext attribute with name ["</span> +</span><br><span class="line">WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line"><span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">logger.info(<span class="string">"Root WebApplicationContext: initialization completed in "</span> + elapsedTime + <span class="string">" ms"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.context;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">logger.error(<span class="string">"Context initialization failed"</span>, err);</span><br><span class="line">servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);</span><br><span class="line"><span class="keyword">throw</span> err;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>DispatcherServlet</code> 继承 <code>FrameworkServlet</code>, <code>FrameworkServlet</code> 继承 <code>HttpServletBean</code><br><code>HttpServletBean</code> 继承 <code>HttpServlet</code>, 并且提供 <code>init</code> 方法</p><p>HttpServletBean 中的 <code>init</code> 方法调用抽象方法 <code>initServletBean</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Initializing servlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">initServletBean();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Servlet '"</span> + getServletName() + <span class="string">"' configured successfully"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FrameworkServlet</code> 实现 <code>initServletBean</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="comment">// ...... 忽略</span></span><br><span class="line"><span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">initFrameworkServlet();</span><br><span class="line"><span class="comment">// ...... 忽略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 在 web 容器  ServletContext 中查找 属性为 org.springframework.web.context.WebApplicationContext.ROOT 的 WebApplicationContext Spring 父容器</span></span><br><span class="line">WebApplicationContext rootContext =</span><br><span class="line">WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">WebApplicationContext wac = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前以及创建了  SpringMVC 子容器</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line"><span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line"><span class="comment">// 如果 springmvc 子容器是 ConfigurableWebApplicationContext, 并且没有激活，设置 spring 父容器和 springmvc 子容器之前的父子容器关系</span></span><br><span class="line">ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line"><span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line"><span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">cwac.setParent(rootContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 配置刷下spring mvc 子容器</span></span><br><span class="line">configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前没有创建 springmvc 子容器</span></span><br><span class="line"><span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 在 web 容器  ServletContext 中查找 属性为 org.springframework.web.context.WebApplicationContext.ROOT 的 spring 容器， 将这个父容器作为 spring mvc 子容器， 这种情况下， spring mvc 子容器和 spring 父容器就合一了！</span></span><br><span class="line">wac = findWebApplicationContext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果上一步没有在 web 容器  ServletContext 中查找到 属性为 org.springframework.web.context.WebApplicationContext.ROOT 的 WebApplicationContext Spring 容器；创建 contextConfigLocation 设置的配置文件注定的 springmvc 子容器</span></span><br><span class="line"><span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">wac = createWebApplicationContext(rootContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...... 忽略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们找到了 两个容器合一的方法！ 果然是 <code>Time is cheap, show me the code</code>, 源码能告诉我们一切！<br>到这里， 找到了配置方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE web-app PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span><br><span class="line"><span class="meta">        "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/spring-root.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- listener --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- spring mvc --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 该servlet的spring上下文采用WebApplicationContext，不再重复生成上下文 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextAttribute<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>org.springframework.web.context.WebApplicationContext.ROOT<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p>下面在回头来看看之前没有解决的问题：</p><h3 id="为什么-SpringMVC-子容器-不能继承-Spring-父容器-引入的属性文件"><a href="#为什么-SpringMVC-子容器-不能继承-Spring-父容器-引入的属性文件" class="headerlink" title="为什么 SpringMVC 子容器 不能继承 Spring 父容器 引入的属性文件"></a>为什么 <code>SpringMVC 子容器</code> 不能继承 <code>Spring 父容器</code> 引入的属性文件</h3><p><em>待解决…</em></p>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring MVC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql 避免重复插入</title>
      <link href="/2017/01/14/%E6%8A%80%E6%9C%AF/mysql/2017-01-14-mysql%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%8F%92%E5%85%A5/"/>
      <url>/2017/01/14/%E6%8A%80%E6%9C%AF/mysql/2017-01-14-mysql%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%8F%92%E5%85%A5/</url>
      <content type="html"><![CDATA[<h3 id="mysql-避免重复插入"><a href="#mysql-避免重复插入" class="headerlink" title="mysql 避免重复插入"></a>mysql 避免重复插入</h3><p><code>mysql</code> 避免重复插入的方式有这样几种</p><ol><li>使用 <code>ignore</code> 关键字</li><li>使用 <code>replace</code> 关键字</li><li>使用 <code>on duplicate key update</code></li></ol><hr><h4 id="使用-ignore-关键字"><a href="#使用-ignore-关键字" class="headerlink" title="使用 ignore 关键字"></a>使用 <code>ignore</code> 关键字</h4><p>当表中存在<code>主键</code>或者<code>唯一索引</code>的时候, 避免重复插入的时候，就可以使用以下命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">ignore</span> <span class="keyword">into</span> table_name <span class="keyword">set</span> <span class="keyword">name</span> = ?, <span class="keyword">desc</span> = ?</span><br></pre></td></tr></table></figure><p>当表中已经存在数据的时候，本次 <code>insert</code> 会被忽略</p><p><em>注意：需要注意的是 <code>insert ignore</code> 在忽略某一次插入的时候自增id 还是会增长的，举例如下：</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb1`</span> (</span><br><span class="line"> <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'名称'</span>,</span><br><span class="line"> <span class="string">`modify_time`</span> <span class="keyword">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'2000-01-01 00:00:00'</span> <span class="keyword">COMMENT</span> <span class="string">'修改时间'</span>,</span><br><span class="line"> PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'测试表'</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into tb1 value(1, "name1", now());</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into tb1 value(1, "name2", now());</span><br><span class="line">ERROR 1062 (23000): Duplicate entry '1' for key 'PRIMARY'</span><br><span class="line">mysql&gt; select * from tb1;</span><br><span class="line">+<span class="comment">----+-------+---------------------+</span></span><br><span class="line">| id | name  | modify_time         |</span><br><span class="line">+<span class="comment">----+-------+---------------------+</span></span><br><span class="line">|  1 | name1 | 2018-07-25 13:35:27 |</span><br><span class="line">+<span class="comment">----+-------+---------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">insert</span> <span class="keyword">ignore</span> <span class="keyword">into</span> tb1 <span class="keyword">value</span>(<span class="number">1</span>, <span class="string">"name2"</span>, <span class="keyword">now</span>());</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure><hr><h4 id="使用-replace-关键字"><a href="#使用-replace-关键字" class="headerlink" title="使用 replace 关键字"></a>使用 <code>replace</code> 关键字</h4><p>除了 <code>insert ignore</code> 之外还有 <code>replace into</code> 这里也要求表中必须存在 <code>主键</code> 或者 <code>唯一索引</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">replace</span> <span class="keyword">into</span> table_name <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'a'</span>, <span class="keyword">desc</span> = <span class="string">'b'</span></span><br></pre></td></tr></table></figure><p>表中 name 必须存在 <code>唯一索引</code> ， 如果表中已经存在 name = ‘a’ 的时候， desc 的值将变更为 ‘b’</p><hr><h4 id="使用-on-duplicate-key-update"><a href="#使用-on-duplicate-key-update" class="headerlink" title="使用 on duplicate key update"></a>使用 <code>on duplicate key update</code></h4><p>当表中存在<code>主键</code>或者<code>唯一索引</code>的时候, 避免重复插入的时候，还可以使用以下命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name(uniq_name, <span class="keyword">desc</span>) <span class="keyword">values</span>(<span class="string">'exists_name'</span>, <span class="string">'desc'</span>) <span class="keyword">on</span> <span class="keyword">duplicate</span> <span class="keyword">key</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">count</span> = <span class="keyword">count</span>+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>上面的语句在避免重复插入的同时，还可以修改某一字段， 如果不需要修改任何字段，请使用一下语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name(uniq_name, <span class="keyword">desc</span>) <span class="keyword">values</span>(<span class="string">'exists_name'</span>, <span class="string">'desc'</span>) <span class="keyword">on</span> <span class="keyword">duplicate</span> <span class="keyword">key</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">desc</span> = <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>可以说 <code>on duplicate key update</code> 能够实现 <code>insert ignore</code> 和 <code>replace into</code> 的功能！</p>]]></content>
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Protobuf 简单使用</title>
      <link href="/2017/01/01/%E6%8A%80%E6%9C%AF/protobuf/2017-01-01-Protobuf%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/01/01/%E6%8A%80%E6%9C%AF/protobuf/2017-01-01-Protobuf%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h3 id="一个简单的介绍"><a href="#一个简单的介绍" class="headerlink" title="一个简单的介绍"></a>一个简单的介绍</h3><p>Google Protocol Buffer( 简称 Protobuf) 是 Google 公司内部的混合语言数据标准，目前已经正在使用的有超过 48,162 种报文格式定义和超过 12,183 个 .proto 文件。他们用于 RPC 系统和持续数据存储系统。<br>Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 等多种语言的 API。<br>详见：<a href="https://github.com/google/protobuf" target="_blank" rel="noopener">GitHub</a></p><h3 id="安装-protobuf"><a href="#安装-protobuf" class="headerlink" title="安装 protobuf"></a>安装 protobuf</h3><p>首先我们需要安装 protobuf</p><p>这里我介绍一下我在 macOS 中使用 <code>brew</code> 安装 <code>protobuf</code></p><ol><li>首先我们看看可以安装的选项</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew search protobuf</span><br></pre></td></tr></table></figure><p><img src="/assets/picture/brew_search_protobuf.png" alt="图片" title="brew search protobuf 结果图"></p><p><em>这里因为我已经安装了 <code>protobuf250</code>, 所以这里有个小 ✔️</em></p><p>如果这里的搜索结果中没有查看到版本相关信息， 执行下面的指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew tap homebrew/versions</span><br></pre></td></tr></table></figure><p>这样以后 使用 <code>brew search appName</code> 的时候就能看到不同版本的应用了</p><ol start="2"><li>使用 brew 安装</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install protobuf250</span><br></pre></td></tr></table></figure><p>安装成功之后可以检验一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -version</span><br></pre></td></tr></table></figure><h3 id="protoc-指令"><a href="#protoc-指令" class="headerlink" title="protoc 指令"></a>protoc 指令</h3><p>下面我们就能使用 <code>protoc</code> 指令来讲 <code>.proto</code> 文件编译成 protobuf 支持的其他语言的文件了，例如 <code>.java</code> 文件</p><p>指令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --java_out=/path/to/java/out/dir/ ./Demo.proto</span><br></pre></td></tr></table></figure><p>将 <em>Demo.proto</em> 编译成 <em>Demo.java</em> 文件， 并且输入到 <code>/path/to/java/out/dir</code></p><p>具体介绍见<br><a 2017 href https: summerbuger.github.io 01 protoc%e6%8c%87%e4%bb%a4%e4%bb%8b%e7%bb%8d.html"," title="protoc 指令介绍">protoc 指令介绍</a></p><h3 id="Intellij-Idea-使用-Google-Protocol-Buffers-Support"><a href="#Intellij-Idea-使用-Google-Protocol-Buffers-Support" class="headerlink" title="Intellij Idea 使用 Google Protocol Buffers Support"></a>Intellij Idea 使用 <code>Google Protocol Buffers Support</code></h3><p>当然，日常开发过程中，我们都是使用 <code>IDE</code>, 如 <code>Intellij Idea</code><br><code>Intellij Idea</code> 对 <code>protobuf</code> 的支持比较好</p><p>1 安装 <code>Google Protocol Buffers Support</code> 插件</p><p><img src="/assets/picture/intellij_idea_proto_plugin.png" alt="图片" title="搜索 proto 相关插件"><br><img src="/assets/picture/google_protocol_buffers_support.png" alt="图片" title="Google Protocol Buffers Support"></p><p>2 添加 <code>Protobuf Facet</code><br><img src="/assets/picture/project_setting_modules.png" alt="图片" title="Project Setting modules"><br><img src="/assets/picture/protobuf_facet.png" alt="图片" title="添加 Protobuf Facet"><br><img src="/assets/picture/java_output_dir.png" alt="图片" title="设置 java 文件输出文件夹"></p><p>3 点击 <code>Build Project</code> 按钮</p><h3 id="proto-文件"><a href="#proto-文件" class="headerlink" title=".proto 文件"></a><code>.proto</code> 文件</h3>]]></content>
      
      <categories>
          
          <category> protobuf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> protobuf </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>protoc 指令介绍</title>
      <link href="/2017/01/01/%E6%8A%80%E6%9C%AF/protobuf/2017-01-01-protoc%E6%8C%87%E4%BB%A4%E4%BB%8B%E7%BB%8D/"/>
      <url>/2017/01/01/%E6%8A%80%E6%9C%AF/protobuf/2017-01-01-protoc%E6%8C%87%E4%BB%A4%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h3 id="protoc-指令介绍"><a href="#protoc-指令介绍" class="headerlink" title="protoc 指令介绍"></a>protoc 指令介绍</h3><p><code>protoc</code> 指令使用示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc [参数] .proto文件路径</span><br></pre></td></tr></table></figure><p>使用 <code>protoc</code> 指令讲 <code>.proto</code> 文件编译成 <code>.java</code> 文件的简单使用如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --java_out=./ /path_to_proto_file/Demo.proto</span><br></pre></td></tr></table></figure><p>protoc 指令参数翻译如下</p><h6 id="注意：-protoc-对文件路径不敏感，所有参数中的路径，必须是绝对路径"><a href="#注意：-protoc-对文件路径不敏感，所有参数中的路径，必须是绝对路径" class="headerlink" title="注意： protoc 对文件路径不敏感，所有参数中的路径，必须是绝对路径"></a><em>注意： <code>protoc</code> 对文件路径不敏感，所有参数中的路径，必须是绝对路径</em></h6><hr><p>-I[PATH], –proto_path=[PATH]: 指定 import 修饰符扫描文件夹；可以指定多次，被指定的文件夹将按照先后制定顺序被扫描；如果没有指定，将使用当前文件夹作为扫描文件夹</p><h6 id="注意：-这里的-PATH-必须是绝对路径"><a href="#注意：-这里的-PATH-必须是绝对路径" class="headerlink" title="注意： 这里的[PATH]必须是绝对路径"></a><em>注意： 这里的[PATH]必须是绝对路径</em></h6><hr><p>–version: 查看 protoc 指令版本</p><hr><p>-h, –help: 查看帮助文档</p><hr><p>–encode=MESSAGE_TYPE</p><hr><p>–decode=MESSAGE_TYPE</p><p>–decode_raw</p><p>-o[FILE], –descriptor_set_out=[FILE]</p><p>–include_imports</p><p>–include_source_info</p><p>–error_format</p><hr><p>–java_out=[PATH]: 指定生成的java文件的输出文件夹</p><p><em>注意 <code>.proto</code> 文件中如果指定了 java_package， 会在输出文件夹中创建java 的package</em></p><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ : ✗ protoc -h</span><br><span class="line">Usage: protoc [OPTION] PROTO_FILES</span><br><span class="line">Parse PROTO_FILES and generate output based on the options given:</span><br><span class="line">  -IPATH, --proto_path=PATH   Specify the directory in which to search for</span><br><span class="line">                              imports.  May be specified multiple times;</span><br><span class="line">                              directories will be searched in order.  If not</span><br><span class="line">                              given, the current working directory is used.</span><br><span class="line">  --version                   Show version info and exit.</span><br><span class="line">  -h, --help                  Show this text and exit.</span><br><span class="line">  --encode=MESSAGE_TYPE       Read a text-format message of the given type</span><br><span class="line">                              from standard input and write it in binary</span><br><span class="line">                              to standard output.  The message type must</span><br><span class="line">                              be defined in PROTO_FILES or their imports.</span><br><span class="line">  --decode=MESSAGE_TYPE       Read a binary message of the given type from</span><br><span class="line">                              standard input and write it in text format</span><br><span class="line">                              to standard output.  The message type must</span><br><span class="line">                              be defined in PROTO_FILES or their imports.</span><br><span class="line">  --decode_raw                Read an arbitrary protocol message from</span><br><span class="line">                              standard input and write the raw tag/value</span><br><span class="line">                              pairs in text format to standard output.  No</span><br><span class="line">                              PROTO_FILES should be given when using this</span><br><span class="line">                              flag.</span><br><span class="line">  -oFILE,                     Writes a FileDescriptorSet (a protocol buffer,</span><br><span class="line">    --descriptor_set_out=FILE defined in descriptor.proto) containing all of</span><br><span class="line">                              the input files to FILE.</span><br><span class="line">  --include_imports           When using --descriptor_set_out, also include</span><br><span class="line">                              all dependencies of the input files in the</span><br><span class="line">                              set, so that the set is self-contained.</span><br><span class="line">  --include_source_info       When using --descriptor_set_out, do not strip</span><br><span class="line">                              SourceCodeInfo from the FileDescriptorProto.</span><br><span class="line">                              This results in vastly larger descriptors that</span><br><span class="line">                              include information about the original</span><br><span class="line">                              location of each decl in the source file as</span><br><span class="line">                              well as surrounding comments.</span><br><span class="line">  --error_format=FORMAT       Set the format in which to print errors.</span><br><span class="line">                              FORMAT may be 'gcc' (the default) or 'msvs'</span><br><span class="line">                              (Microsoft Visual Studio format).</span><br><span class="line">  --plugin=EXECUTABLE         Specifies a plugin executable to use.</span><br><span class="line">                              Normally, protoc searches the PATH for</span><br><span class="line">                              plugins, but you may specify additional</span><br><span class="line">                              executables not in the path using this flag.</span><br><span class="line">                              Additionally, EXECUTABLE may be of the form</span><br><span class="line">                              NAME=PATH, in which case the given plugin name</span><br><span class="line">                              is mapped to the given executable even if</span><br><span class="line">                              the executable's own name differs.</span><br><span class="line">  --cpp_out=OUT_DIR           Generate C++ header and source.</span><br><span class="line">  --java_out=OUT_DIR          Generate Java source file.</span><br><span class="line">  --python_out=OUT_DIR        Generate Python source file.</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> protobuf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> protobuf </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMVC 中的 @ControllerAdvice</title>
      <link href="/2016/12/10/%E6%8A%80%E6%9C%AF/spring/2016-12-10-SpringMvc-@ControllerAdvice/"/>
      <url>/2016/12/10/%E6%8A%80%E6%9C%AF/spring/2016-12-10-SpringMvc-@ControllerAdvice/</url>
      <content type="html"><![CDATA[<h3 id="SpringMVC-中的-ControllerAdvice"><a href="#SpringMVC-中的-ControllerAdvice" class="headerlink" title="SpringMVC 中的 @ControllerAdvice"></a>SpringMVC 中的 @ControllerAdvice</h3><p><code>SpringMVC</code> 中常用的注解网上有很多介绍，<code>@ControllerAdvice</code> 这个注解相对来说少见一点</p><p>从名称上就能看出， <code>@ControllerAdvice</code> 是用来增强 <code>@Controller</code> 的</p><pre><code>使用 `@ControllerAdvice` 注解增强控制器带有 `@ControllerAdvice` 注解的类，可以包含 @ExceptionHandler、@InitBinder, 和 `@ModelAttribute` 注解的方法，并且这些注解的方法会通过控制器层次应用到所有 `@RequestMapping` 方法中，而不用一一在控制器内部声明。</code></pre><p>看到上面这段话，大家有没有一种兴奋感？<br>在没有 <code>@ControllerAdvice</code> 之前， 我们是怎么使用 <code>@ExceptionHandler</code> 的呢？ 很简单，我们给 <code>Controller</code> 定义父类，在父类中又一个方法，被 <code>@ExceptionHandler</code> 修饰的方法，<br>在这里处理， 从上面这句话来说，我们现在并不需要定义什么父类，只要用 <code>@ControllerAdvice</code> 修饰一个类，它就能成为全局异常处理器！</p><p>Talk is cheap, show me the code!</p><p>先来一个 Controller:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/spring/demo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"test exceptions"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来一个 ControllerAdvice, 直接返回一个 json 格式的异常信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseControllerAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handlerException</span><span class="params">(Exception e, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"exception: &#123;&#125;"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来贴一下 spring 配置信息:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.springdemo.liam"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.web.bind.annotation.ControllerAdvice"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Service"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>看看运行结果，很不错，我们实现了全剧异常处理<br><img src="/assets/picture/errHandler.png" alt="图片"></p><p>到这里大家会比较疑惑，为什么 ControllerAdvice 可以被自动扫描呢？</p><p>先来看看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ControllerAdvice &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"basePackages"</span>)</span><br><span class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt;[] assignableTypes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Class&lt;? extends Annotation&gt;[] annotations() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到 <code>@ControllerAdvice</code> 是一个 <code>@Component</code>, 它当然能被扫描<br>除了 <code>@ExceptionHandler</code> 之外，还有 <code>@InitBinder</code>、<code>@ModelAttribute</code> 修饰的方法，不是很常用</p><p>这里如果只是 这三个功能， <code>@ControllerAdvice</code> 还略显鸡肋</p><p>下面来看看 <code>Spring 4.2</code> 以来的新特性 <code>ResponseBodyAdvice</code> 和 <code>RequestBodyAdvice</code></p><p><code>ResponseBodyAdvice</code> 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResponseBodyAdvice</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Whether this component supports the given controller method return type</span></span><br><span class="line"><span class="comment"> * and the selected &#123;<span class="doctag">@code</span> HttpMessageConverter&#125; type.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnType the return type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> converterType the selected converter type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if &#123;<span class="doctag">@link</span> #beforeBodyWrite&#125; should be invoked, &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoked after an &#123;<span class="doctag">@code</span> HttpMessageConverter&#125; is selected and just before</span></span><br><span class="line"><span class="comment"> * its write method is invoked.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> body the body to be written</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnType the return type of the controller method</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> selectedContentType the content type selected through content negotiation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> selectedConverterType the converter type selected to write to the response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response the current response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the body that was passed in or a modified, possibly new instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">T <span class="title">beforeBodyWrite</span><span class="params">(T body, MethodParameter returnType, MediaType selectedContentType,</span></span></span><br><span class="line"><span class="function"><span class="params">Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType,</span></span></span><br><span class="line"><span class="function"><span class="params">ServerHttpRequest request, ServerHttpResponse response)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到这里， 我们可以对 <code>@ResponseBody</code> 修饰的方法的返回值进行处理<br>比如我们对返回结果进行国际化处理，</p><p>来个简单的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span>(annotations = RestController.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleResponseBodyAdvice</span> <span class="keyword">implements</span> <span class="title">ResponseBodyAdvice</span>&lt;<span class="title">Result</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验是否是需要的接入点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> returnType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> converterType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(MethodParameter returnType, Class converterType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> returnType.getMethod().getReturnType().equals(Result.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在往 outputStream 中写入返回结果之前，对返回结果进行处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">beforeBodyWrite</span><span class="params">(Result body, MethodParameter returnType, MediaType selectedContentType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  ServerHttpRequest request, ServerHttpResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> body.withRet(<span class="keyword">false</span>).withData(<span class="string">"被 ResponseBodyAdvice 修改的结果"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test/rest"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result&lt;String&gt; <span class="title">testRest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="keyword">true</span>, <span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看结果：</p><p><img src="/assets/picture/responseBodyDemo.png" alt="图片"></p>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring MVC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMVC源码学习 —— MVC 配置加载过程</title>
      <link href="/2016/12/01/%E6%8A%80%E6%9C%AF/spring/2016-12-01-SpringMVC%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-mvc%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
      <url>/2016/12/01/%E6%8A%80%E6%9C%AF/spring/2016-12-01-SpringMVC%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-mvc%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h3 id="SpringMVC-配置加载过程"><a href="#SpringMVC-配置加载过程" class="headerlink" title="SpringMVC 配置加载过程"></a>SpringMVC 配置加载过程</h3><p><code>Spring</code> 中加载配置文件的工具类是 <code>xxxNamespaceHandler</code>， 解析 SpringMVC 的配置文件，加载默认配置的工具类就是 <code>MvcNameSpaceHandler</code>。</p><p>下面来看看 <code>MvcNameSpaceHandler</code> 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 注册 &lt;mvc:annotation-driven&gt; 配置标签解析类，具体解析内容见 [AnnotationDrivenBeanDefinitionParser]</span></span><br><span class="line">registerBeanDefinitionParser(<span class="string">"annotation-driven"</span>, <span class="keyword">new</span> AnnotationDrivenBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"default-servlet-handler"</span>, <span class="keyword">new</span> DefaultServletHandlerBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"interceptors"</span>, <span class="keyword">new</span> InterceptorsBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"resources"</span>, <span class="keyword">new</span> ResourcesBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"view-controller"</span>, <span class="keyword">new</span> ViewControllerBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"redirect-view-controller"</span>, <span class="keyword">new</span> ViewControllerBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"status-controller"</span>, <span class="keyword">new</span> ViewControllerBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"view-resolvers"</span>, <span class="keyword">new</span> ViewResolversBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"tiles-configurer"</span>, <span class="keyword">new</span> TilesConfigurerBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"freemarker-configurer"</span>, <span class="keyword">new</span> FreeMarkerConfigurerBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"velocity-configurer"</span>, <span class="keyword">new</span> VelocityConfigurerBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"groovy-configurer"</span>, <span class="keyword">new</span> GroovyMarkupConfigurerBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"script-template-configurer"</span>, <span class="keyword">new</span> ScriptTemplateConfigurerBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"cors"</span>, <span class="keyword">new</span> CorsBeanDefinitionParser());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是 <code>AnnotationDrivenBeanDefinitionParser</code> 中的 <code>parse</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">Object source = parserContext.extractSource(element);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 `&lt;mvc:annotation-driven&gt;` 的组件信息</span></span><br><span class="line">CompositeComponentDefinition compDefinition = <span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), source);</span><br><span class="line"><span class="comment">// 将 `&lt;mvc:annotation-driven&gt;` 的组建信息 push 到解析配置的上下文的 栈 中去</span></span><br><span class="line">parserContext.pushContainingComponent(compDefinition);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 `ContentNegotiationManager`, 如果 &lt;mvc:annotation-driven&gt; 中配置了 ContentNegotiationManager 的实现类名，则返回该实现的引用；</span></span><br><span class="line"><span class="comment">// 如果没有配置，就会生成一个默认的 ContentNegotiationManager</span></span><br><span class="line"><span class="comment">// ContentNegotiationManager: 1. 根据request 解析出 mediaType； 2. 根据 mediaType 解析出文件后缀名</span></span><br><span class="line">RuntimeBeanReference contentNegotiationManager = getContentNegotiationManager(element, source, parserContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 RequestMappingHandlerMapping 的Bean 定义</span></span><br><span class="line">RootBeanDefinition handlerMappingDef = <span class="keyword">new</span> RootBeanDefinition(RequestMappingHandlerMapping.class);</span><br><span class="line">handlerMappingDef.setSource(source);</span><br><span class="line">handlerMappingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line"><span class="comment">// 默认 order 为0，优先使用这个 HandlerMapping</span></span><br><span class="line">handlerMappingDef.getPropertyValues().add(<span class="string">"order"</span>, <span class="number">0</span>);</span><br><span class="line">handlerMappingDef.getPropertyValues().add(<span class="string">"contentNegotiationManager"</span>, contentNegotiationManager);</span><br><span class="line">String methodMappingName = parserContext.getReaderContext().registerWithGeneratedName(handlerMappingDef);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 &lt;mvc:annotation-driven&gt; 标签设置了 enable-matrix-variables 属性，在 RequestMappingHandlerMapping 中添加 removeSemicolonContent 属性 如果要使用 matrix-variales 属性， removeSemicolonContent 必须是 false</span></span><br><span class="line"><span class="keyword">if</span> (element.hasAttribute(<span class="string">"enable-matrix-variables"</span>)) &#123;</span><br><span class="line">Boolean enableMatrixVariables = Boolean.valueOf(element.getAttribute(<span class="string">"enable-matrix-variables"</span>));</span><br><span class="line">handlerMappingDef.getPropertyValues().add(<span class="string">"removeSemicolonContent"</span>, !enableMatrixVariables);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (element.hasAttribute(<span class="string">"enableMatrixVariables"</span>)) &#123;</span><br><span class="line">Boolean enableMatrixVariables = Boolean.valueOf(element.getAttribute(<span class="string">"enableMatrixVariables"</span>));</span><br><span class="line">handlerMappingDef.getPropertyValues().add(<span class="string">"removeSemicolonContent"</span>, !enableMatrixVariables);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 &lt;mvc:annotation-driven&gt; 中的 path-matching 属性</span></span><br><span class="line"><span class="comment">// 读取 path-matching 中的 suffix-pattern、trailing-slash、registered-suffixes-only</span></span><br><span class="line">  <span class="comment">// 设置 RequestMappingHandlerMapping 的 useSuffixPatternMatch、useTrailingSlashMatch、useRegisteredSuffixPatternMatch</span></span><br><span class="line"><span class="comment">// 读取 path-matching 中的 path-helper （UrlPathHelper 或其自定义子类的全限定名）</span></span><br><span class="line"><span class="comment">// 设置 RequestMappingHandlerMapping 的 UrlPathHelper，如果 path-helper 不为空则在 ParserContext 中设置当前 UrlPathHelper 的别名为 mvcUrlPathHelper</span></span><br><span class="line"><span class="comment">// 读取 path-matching 中的 path-helper</span></span><br><span class="line"><span class="comment">// 设置 RequestMappingHandlerMapping 中的 pathMatcher 默认为 AntPathMatcher(ant 风格的路径匹配器)，如果 path-helper 不为空则在 ParserContext 中设置当前 UrlPathHelper 的别名为 mvcPathMatcher</span></span><br><span class="line">configurePathMatchingProperties(handlerMappingDef, element, parserContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">// RequestMappingHandlerMapping 设置 CorsConfiguration(跨域请求配置信息) 并且 将 corsConfigurations 注册到 ParserContext 中</span></span><br><span class="line">RuntimeBeanReference corsConfigurationsRef = MvcNamespaceUtils.registerCorsConfigurations(<span class="keyword">null</span>, parserContext, source);</span><br><span class="line">handlerMappingDef.getPropertyValues().add(<span class="string">"corsConfigurations"</span>, corsConfigurationsRef);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 path-matching 中的 conversion-service 获取 conversionService 并且注册到 ParserContext 中去</span></span><br><span class="line">RuntimeBeanReference conversionService = getConversionService(element, source, parserContext);</span><br><span class="line">RuntimeBeanReference validator = getValidator(element, source, parserContext);</span><br><span class="line">RuntimeBeanReference messageCodesResolver = getMessageCodesResolver(element);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RootBeanDefinition bindingDef = <span class="keyword">new</span> RootBeanDefinition(ConfigurableWebBindingInitializer.class);</span><br><span class="line">bindingDef.setSource(source);</span><br><span class="line">bindingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">bindingDef.getPropertyValues().add(<span class="string">"conversionService"</span>, conversionService);</span><br><span class="line">bindingDef.getPropertyValues().add(<span class="string">"validator"</span>, validator);</span><br><span class="line">bindingDef.getPropertyValues().add(<span class="string">"messageCodesResolver"</span>, messageCodesResolver);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取配置信息中的 MessageConverter， 如果没有配置或者 register-defaults 为 true， 其实 register-defaults 默认为true</span></span><br><span class="line"><span class="comment">// 也就是说不管你有没有配置 message-converters 属性  annotation-driven 都会为你注册这写 HttpMessageConverter:</span></span><br><span class="line"><span class="comment">// ByteArrayHttpMessageConverter、StringHttpMessageConverter、ResourceHttpMessageConverter、SourceHttpMessageConverter、AllEncompassingFormHttpMessageConverter</span></span><br><span class="line"><span class="comment">// 还有一些是否根据当前 classpath 中是否有对应的jar包才会添加的对应的 HttpMessageConverter</span></span><br><span class="line">ManagedList&lt;?&gt; messageConverters = getMessageConverters(element, source, parserContext);</span><br><span class="line"><span class="comment">// 获取用户自定义的 HandlerMethodArgumentResolver， 解析方法参数</span></span><br><span class="line">ManagedList&lt;?&gt; argumentResolvers = getArgumentResolvers(element, parserContext);</span><br><span class="line"><span class="comment">// 获取用户自定义的 HandlerMethodReturnValueHandler， 处理方法的返回值</span></span><br><span class="line">ManagedList&lt;?&gt; returnValueHandlers = getReturnValueHandlers(element, parserContext);</span><br><span class="line">String asyncTimeout = getAsyncTimeout(element);</span><br><span class="line">RuntimeBeanReference asyncExecutor = getAsyncExecutor(element);</span><br><span class="line">ManagedList&lt;?&gt; callableInterceptors = getCallableInterceptors(element, source, parserContext);</span><br><span class="line">ManagedList&lt;?&gt; deferredResultInterceptors = getDeferredResultInterceptors(element, source, parserContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 RequestMappingHandlerAdapter 的 bean 定义</span></span><br><span class="line">RootBeanDefinition handlerAdapterDef = <span class="keyword">new</span> RootBeanDefinition(RequestMappingHandlerAdapter.class);</span><br><span class="line">handlerAdapterDef.setSource(source);</span><br><span class="line">handlerAdapterDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">handlerAdapterDef.getPropertyValues().add(<span class="string">"contentNegotiationManager"</span>, contentNegotiationManager);</span><br><span class="line">handlerAdapterDef.getPropertyValues().add(<span class="string">"webBindingInitializer"</span>, bindingDef);</span><br><span class="line">handlerAdapterDef.getPropertyValues().add(<span class="string">"messageConverters"</span>, messageConverters);</span><br><span class="line">addRequestBodyAdvice(handlerAdapterDef);</span><br><span class="line">addResponseBodyAdvice(handlerAdapterDef);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (element.hasAttribute(<span class="string">"ignore-default-model-on-redirect"</span>)) &#123;</span><br><span class="line">Boolean ignoreDefaultModel = Boolean.valueOf(element.getAttribute(<span class="string">"ignore-default-model-on-redirect"</span>));</span><br><span class="line">handlerAdapterDef.getPropertyValues().add(<span class="string">"ignoreDefaultModelOnRedirect"</span>, ignoreDefaultModel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (element.hasAttribute(<span class="string">"ignoreDefaultModelOnRedirect"</span>)) &#123;</span><br><span class="line"><span class="comment">// "ignoreDefaultModelOnRedirect" spelling is deprecated</span></span><br><span class="line">Boolean ignoreDefaultModel = Boolean.valueOf(element.getAttribute(<span class="string">"ignoreDefaultModelOnRedirect"</span>));</span><br><span class="line">handlerAdapterDef.getPropertyValues().add(<span class="string">"ignoreDefaultModelOnRedirect"</span>, ignoreDefaultModel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argumentResolvers != <span class="keyword">null</span>) &#123;</span><br><span class="line">handlerAdapterDef.getPropertyValues().add(<span class="string">"customArgumentResolvers"</span>, argumentResolvers);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (returnValueHandlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">handlerAdapterDef.getPropertyValues().add(<span class="string">"customReturnValueHandlers"</span>, returnValueHandlers);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (asyncTimeout != <span class="keyword">null</span>) &#123;</span><br><span class="line">handlerAdapterDef.getPropertyValues().add(<span class="string">"asyncRequestTimeout"</span>, asyncTimeout);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (asyncExecutor != <span class="keyword">null</span>) &#123;</span><br><span class="line">handlerAdapterDef.getPropertyValues().add(<span class="string">"taskExecutor"</span>, asyncExecutor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handlerAdapterDef.getPropertyValues().add(<span class="string">"callableInterceptors"</span>, callableInterceptors);</span><br><span class="line">handlerAdapterDef.getPropertyValues().add(<span class="string">"deferredResultInterceptors"</span>, deferredResultInterceptors);</span><br><span class="line">String handlerAdapterName = parserContext.getReaderContext().registerWithGeneratedName(handlerAdapterDef);</span><br><span class="line"></span><br><span class="line">String uriCompContribName = MvcUriComponentsBuilder.MVC_URI_COMPONENTS_CONTRIBUTOR_BEAN_NAME;</span><br><span class="line">RootBeanDefinition uriCompContribDef = <span class="keyword">new</span> RootBeanDefinition(CompositeUriComponentsContributorFactoryBean.class);</span><br><span class="line">uriCompContribDef.setSource(source);</span><br><span class="line">uriCompContribDef.getPropertyValues().addPropertyValue(<span class="string">"handlerAdapter"</span>, handlerAdapterDef);</span><br><span class="line">uriCompContribDef.getPropertyValues().addPropertyValue(<span class="string">"conversionService"</span>, conversionService);</span><br><span class="line">parserContext.getReaderContext().getRegistry().registerBeanDefinition(uriCompContribName, uriCompContribDef);</span><br><span class="line"></span><br><span class="line">RootBeanDefinition csInterceptorDef = <span class="keyword">new</span> RootBeanDefinition(ConversionServiceExposingInterceptor.class);</span><br><span class="line">csInterceptorDef.setSource(source);</span><br><span class="line">csInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(<span class="number">0</span>, conversionService);</span><br><span class="line">RootBeanDefinition mappedCsInterceptorDef = <span class="keyword">new</span> RootBeanDefinition(MappedInterceptor.class);</span><br><span class="line">mappedCsInterceptorDef.setSource(source);</span><br><span class="line">mappedCsInterceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">mappedCsInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(<span class="number">0</span>, (Object) <span class="keyword">null</span>);</span><br><span class="line">mappedCsInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(<span class="number">1</span>, csInterceptorDef);</span><br><span class="line">String mappedInterceptorName = parserContext.getReaderContext().registerWithGeneratedName(mappedCsInterceptorDef);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 ExceptionHandlerExceptionResolver 的 Bean 定义</span></span><br><span class="line">RootBeanDefinition exceptionHandlerExceptionResolver = <span class="keyword">new</span> RootBeanDefinition(ExceptionHandlerExceptionResolver.class);</span><br><span class="line">exceptionHandlerExceptionResolver.setSource(source);</span><br><span class="line">exceptionHandlerExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">exceptionHandlerExceptionResolver.getPropertyValues().add(<span class="string">"contentNegotiationManager"</span>, contentNegotiationManager);</span><br><span class="line">exceptionHandlerExceptionResolver.getPropertyValues().add(<span class="string">"messageConverters"</span>, messageConverters);</span><br><span class="line">exceptionHandlerExceptionResolver.getPropertyValues().add(<span class="string">"order"</span>, <span class="number">0</span>);</span><br><span class="line">addResponseBodyAdvice(exceptionHandlerExceptionResolver);</span><br><span class="line"></span><br><span class="line">String methodExceptionResolverName =</span><br><span class="line">parserContext.getReaderContext().registerWithGeneratedName(exceptionHandlerExceptionResolver);</span><br><span class="line"></span><br><span class="line">RootBeanDefinition responseStatusExceptionResolver = <span class="keyword">new</span> RootBeanDefinition(ResponseStatusExceptionResolver.class);</span><br><span class="line">responseStatusExceptionResolver.setSource(source);</span><br><span class="line">responseStatusExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">responseStatusExceptionResolver.getPropertyValues().add(<span class="string">"order"</span>, <span class="number">1</span>);</span><br><span class="line">String responseStatusExceptionResolverName =</span><br><span class="line">parserContext.getReaderContext().registerWithGeneratedName(responseStatusExceptionResolver);</span><br><span class="line"></span><br><span class="line">RootBeanDefinition defaultExceptionResolver = <span class="keyword">new</span> RootBeanDefinition(DefaultHandlerExceptionResolver.class);</span><br><span class="line">defaultExceptionResolver.setSource(source);</span><br><span class="line">defaultExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">defaultExceptionResolver.getPropertyValues().add(<span class="string">"order"</span>, <span class="number">2</span>);</span><br><span class="line">String defaultExceptionResolverName =</span><br><span class="line">parserContext.getReaderContext().registerWithGeneratedName(defaultExceptionResolver);</span><br><span class="line"></span><br><span class="line">parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(handlerMappingDef, methodMappingName));</span><br><span class="line">parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(handlerAdapterDef, handlerAdapterName));</span><br><span class="line">parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(uriCompContribDef, uriCompContribName));</span><br><span class="line">parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(exceptionHandlerExceptionResolver, methodExceptionResolverName));</span><br><span class="line">parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(responseStatusExceptionResolver, responseStatusExceptionResolverName));</span><br><span class="line">parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(defaultExceptionResolver, defaultExceptionResolverName));</span><br><span class="line">parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(mappedCsInterceptorDef, mappedInterceptorName));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ensure BeanNameUrlHandlerMapping (SPR-8289) and default HandlerAdapters are not "turned off"</span></span><br><span class="line">  <span class="comment">// 创建默认的组件 BeanNameUrlHandlerMapping、HttpRequestHandlerAdapter、SimpleControllerHandlerAdapter</span></span><br><span class="line">MvcNamespaceUtils.registerDefaultComponents(parserContext, source);</span><br><span class="line"></span><br><span class="line">parserContext.popAndRegisterContainingComponent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring MVC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>几种分布式锁的实现方式</title>
      <link href="/2016/10/26/%E6%8A%80%E6%9C%AF/java/2016-10-26-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2016/10/26/%E6%8A%80%E6%9C%AF/java/2016-10-26-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>分布式是现在大多数程序必要的运行环境：单机服务如果服务器宕机了，向外提供的服务马上崩溃，整个系统陷入瘫痪；而如果存在多个服务器向外提供服务，<br>只要还存在提供服务的服务器，系统就能正常运行</p><p>分布式系统向外提供服务时，很多情况下都会出现多个服务器共享某一资源的情况，存在自愿竞争；</p><p>如：<br>商品系统提供了rpc 接口，功能是创建商品信息，这个rpc 接口的提供服务器有 A,B,C；<br>这个创建商品信息的接口，在创建新的商品之前，会检测现在是否已经存在该商品，如果存在则返回已存在该商品，否则将新建商品<br>rpc接口的消费者是E， 假设 E 第一次调用的时候调用的是A，在短时间内再次请求，创建相同的商品，这时候A 服务器还没处理完,假设请求分发到了B<br>这时候 A 服务器还没有将商品信息持久化， B 服务器已经运行到了检查是否已经存在该商品， B 服务器没有查询到商品已存在，又创建了一个商品，此时商品的唯一性时效！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在持久化商品信息之前需要进行的操作</span></span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">// 检测商品信息是否存在</span></span><br><span class="line">  <span class="keyword">if</span> (商品信息已存在) &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail().withErrMsg(<span class="string">"该商品已存在！"</span>);</span><br><span class="line">  &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 保存商品信息</span></span><br><span class="line">    saveProductInfo();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...... 商品保存后的逻辑操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>面对上述问题，在单机服务器上，我们很容易想到给 <code>createProduct</code> 加锁，使该方法实现线程安全； 将这个思路扩展到分布式系统，我们能否提供一个适用于分布式系统的锁？<br>要实现分布式锁，我们需要借助工具</p><ol><li>数据库</li><li>redis</li><li>zookeeper</li></ol><h3 id="1-依赖数据库实现分布式锁"><a href="#1-依赖数据库实现分布式锁" class="headerlink" title="1. 依赖数据库实现分布式锁"></a>1. 依赖数据库实现分布式锁</h3><p>各种版本的数据库都实现了锁，这里以 <code>mysql</code> 的 <code>InnoDB</code> 存储引擎为例；</p><p><code>InnoDB</code> 的特性是：支持事务、支持行级锁、支持外键；</p><p><code>InnoDB</code> 提供了两种类型的行级锁：</p><p>1.<code>共享锁(S)</code>: 允许一个事务去读一行数据，阻止其他事务获取相同数据集的排他写锁<br>2.<code>排他锁(X)</code>: 允许获得排他锁的事务修改一行数据，阻止其他事务获取相同数据集的共享读锁和排他写锁</p><p>对于 <code>DELETE</code>、<code>UPDATE</code>、<code>INSERT</code>语句，<code>InnoDB</code>会自动给涉及到的数据集加上排他锁；<br>对于普通的 <code>SELECT</code> 语句，<code>InnoDB</code> 不会加上任务锁；<br>而 <code>事务</code> 可以通过以下语句显式的给涉及到的数据集加上共享锁或者排他锁：</p><ol><li>显式添加共享锁</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>显式添加排他锁</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p><code>FOR UPDATE</code> 添加排他锁，后一个想要获取锁的事务，会等待前一个事务的完成之后才能获取排他锁</p><p>回到正题，我们上面所说的分布式锁，需要具备排他性；<code>事务</code> 通过 <code>FOR UPDATE</code> 添加排他锁正好满足我们的需求</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def <span class="keyword">lock</span>:</span><br><span class="line">  <span class="keyword">set</span> autocommit <span class="number">0</span>; // 取消事务的自动提交特性</span><br><span class="line">  <span class="keyword">select</span> * <span class="keyword">from</span> lock_table <span class="keyword">where</span> lock_key = ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line">def <span class="keyword">unlock</span>:</span><br><span class="line">  <span class="keyword">set</span> autocommit <span class="number">1</span>;  // 提交事务，解除行级锁</span><br></pre></td></tr></table></figure><p>这里使用的 <code>事务</code> + <code>FOR UPDATE</code> 添加排他锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liam.distribute.lock.db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.liam.distribute.lock.DistributeLock;</span><br><span class="line"><span class="keyword">import</span> com.liam.distribute.lock.LockException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by chaochun.chen on 16-10-27.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForUpdateSimpleLock</span> <span class="keyword">implements</span> <span class="title">DistributeLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Connection&gt; localConnection = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FOR_UPDATE_SQL = <span class="string">"select * from lock_table where lock_key = ? for update"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(String lockKey)</span> </span>&#123;</span><br><span class="line">        Connection connection = localConnection.get();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            PreparedStatement statement = connection.prepareStatement(FOR_UPDATE_SQL);</span><br><span class="line">            statement.setString(<span class="number">1</span>, lockKey);</span><br><span class="line">            ResultSet resultSet = statement.executeQuery();</span><br><span class="line">            <span class="keyword">if</span> (resultSet.next()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// 忽略异常，默认为尝试加锁失败！</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String lockKey)</span> </span>&#123;</span><br><span class="line">        Connection connection = localConnection.get();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    PreparedStatement statement = connection.prepareStatement(FOR_UPDATE_SQL);</span><br><span class="line">                    statement.setString(<span class="number">1</span>, lockKey);</span><br><span class="line">                    ResultSet resultSet = statement.executeQuery();</span><br><span class="line">                    <span class="keyword">if</span> (resultSet.next()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// 此时如果抛出异常则重试！</span></span><br><span class="line">                &#125;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// 忽略异常，默认为尝试加锁失败！</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">(String lockKey)</span> </span>&#123;</span><br><span class="line">        Connection connection = localConnection.get();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConnection</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        localConnection.set(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种实现分布式锁的方法存在一些问题：</p><ol><li>性能不是很高</li><li>这里加锁解锁依赖sql，必须面对sql超时问题，如果底层 jdbc 和 数据库之前的socket 超时了，此时connection 基本不可用，需要关闭；<br>因此，在使用 <code>Connection</code> 的时候，推荐的使用方式是，将  <code>Connection</code> 的生命周期控制在一个方法内；</li><li>如果调用分布式锁的消费者宕机了，没有人去解锁，其他消费者将无法获取锁</li><li>没有可重入性</li></ol><p>除了上面说的 依赖 <code>事务</code> 通过 <code>FOR UPDATE</code> 实现分布式锁； 我们还能通过 <code>唯一索引</code> 实现分布式锁</p><p>先看看建表语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> uniq_lock_table (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">INT</span> (<span class="number">10</span>) <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'自增主键'</span>,</span><br><span class="line">  <span class="string">`lock_key`</span> <span class="built_in">VARCHAR</span> (<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'获取锁的key值'</span>,</span><br><span class="line">  <span class="string">`expire_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1970-01-01 00:00:00'</span> <span class="keyword">COMMENT</span> <span class="string">'失效时间'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1970-01-01 00:00:00'</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uniq_lock_key`</span>(<span class="string">`lock_key`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span> <span class="keyword">CHARSET</span> = <span class="string">'utf8mb4'</span> <span class="keyword">COMMENT</span> = <span class="string">'使用唯一索引实现分布式锁的表'</span></span><br></pre></td></tr></table></figure><p>简单定义一个dao 层接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liam.distribute.lock.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by chaochun.chen on 16-10-28.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UniqLockTableMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(String lockKey, Date createTime, Date expireTime)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">del</span><span class="params">(String lockKey)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteExpired</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分布式锁简单定义如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def <span class="keyword">lock</span>:</span><br><span class="line">    exec <span class="keyword">sql</span>: <span class="keyword">insert</span> <span class="keyword">into</span> uniq_lock_table(lock_key, create_time, expire_time) <span class="keyword">values</span>(?, ?, ?);</span><br><span class="line">    if result == 1:</span><br><span class="line">      return ture;</span><br><span class="line">    else :</span><br><span class="line">      return false;</span><br><span class="line"></span><br><span class="line">def <span class="keyword">unlock</span>:</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">from</span> uniq_lock_table <span class="keyword">where</span> lock_key = ?;</span><br></pre></td></tr></table></figure><p>用java 实现的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liam.distribute.lock.db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.liam.distribute.lock.DistributeLock;</span><br><span class="line"><span class="keyword">import</span> com.liam.distribute.lock.mapper.UniqLockTableMapper;</span><br><span class="line"><span class="keyword">import</span> com.liam.distribute.lock.mapper.UniqLockTableMapperImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.OperationNotSupportedException;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by chaochun.chen on 16-10-27.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniqIndexLock</span> <span class="keyword">implements</span> <span class="title">DistributeLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(String lockKey)</span> </span>&#123;</span><br><span class="line">        UniqLockTableMapper uniqLockTableMapper = UniqLockTableMapperImpl.newInstance();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> insert = uniqLockTableMapper.insert(lockKey, <span class="keyword">new</span> Date(), <span class="keyword">new</span> Date());</span><br><span class="line">            <span class="keyword">if</span> (insert) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 忽略此异常，视为加锁失败！</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String lockKey)</span> </span>&#123;</span><br><span class="line">        UniqLockTableMapper uniqLockTableMapper = UniqLockTableMapperImpl.newInstance();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> insert = uniqLockTableMapper.insert(lockKey, <span class="keyword">new</span> Date(), <span class="keyword">new</span> Date());</span><br><span class="line">                    <span class="keyword">if</span> (insert) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// 忽略此异常，视为加锁失败！</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(String lockKey, TimeUnit timeUnit, <span class="keyword">long</span> expireTime)</span> <span class="keyword">throws</span> OperationNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String lockKey, TimeUnit timeUnit, <span class="keyword">long</span> expireTime)</span> <span class="keyword">throws</span> OperationNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">(String lockKey)</span> </span>&#123;</span><br><span class="line">        UniqLockTableMapper uniqLockTableMapper = UniqLockTableMapperImpl.newInstance();</span><br><span class="line">        uniqLockTableMapper.del(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种方法的缺点很明显：</p><ol><li>分布式锁不具备可重入性</li><li>如果某一消费者在获取锁之后宕机了，其他消费者无法获取锁</li></ol><p>为了解决 上面反复提到的 失效的锁的问题，我们在获取锁的时候新增时效时间！</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def <span class="keyword">lock</span>:</span><br><span class="line">    exec clear_expire_time;</span><br><span class="line">    exec sql: <span class="keyword">insert</span> <span class="keyword">into</span> uniq_lock_table(lock_key, create_time, expire_time) <span class="keyword">values</span>(?, ?, ?);</span><br><span class="line">    if result == 1:</span><br><span class="line">      return ture;</span><br><span class="line">    else :</span><br><span class="line">      return false;</span><br><span class="line"></span><br><span class="line">def clear_expire_time:</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">from</span> uniq_lock_table <span class="keyword">where</span> <span class="keyword">now</span>() &gt; expire_time;</span><br><span class="line"></span><br><span class="line">def <span class="keyword">unlock</span>:</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">from</span> uniq_lock_table <span class="keyword">where</span> lock_key = ?;</span><br></pre></td></tr></table></figure><p>java 实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liam.distribute.lock.db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.base.Function;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.FluentIterable;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.ImmutableList;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Iterables;</span><br><span class="line"><span class="keyword">import</span> com.liam.distribute.lock.DistributeLock;</span><br><span class="line"><span class="keyword">import</span> com.liam.distribute.lock.mapper.UniqLockTableMapper;</span><br><span class="line"><span class="keyword">import</span> com.liam.distribute.lock.mapper.UniqLockTableMapperImpl;</span><br><span class="line"><span class="keyword">import</span> com.liam.distribute.lock.model.UniqLockTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.OperationNotSupportedException;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by chaochun.chen on 16-10-28.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniqIndexTimeLock</span> <span class="keyword">implements</span> <span class="title">DistributeLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_EXPIRE_TIMES = <span class="number">2</span> * <span class="number">1000</span>; <span class="comment">// 默认锁时效时间是两秒！</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(String lockKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> tryLock(lockKey, TimeUnit.MILLISECONDS, DEFAULT_EXPIRE_TIMES);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OperationNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String lockKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lock(lockKey, TimeUnit.MILLISECONDS, DEFAULT_EXPIRE_TIMES);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OperationNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(String lockKey, TimeUnit timeUnit, <span class="keyword">long</span> expireTime)</span> <span class="keyword">throws</span> OperationNotSupportedException </span>&#123;</span><br><span class="line">        UniqLockTableMapper uniqLockTableMapper = UniqLockTableMapperImpl.newInstance();</span><br><span class="line">        <span class="keyword">long</span> expireMillis = timeUnit.toMillis(expireTime);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clearExpiredLock();</span><br><span class="line">            <span class="keyword">long</span> cur = System.currentTimeMillis();</span><br><span class="line">            Date now = <span class="keyword">new</span> Date(cur);</span><br><span class="line">            Date expired = <span class="keyword">new</span> Date(cur + expireMillis);</span><br><span class="line">            <span class="keyword">boolean</span> insert = uniqLockTableMapper.insert(lockKey, now, expired);</span><br><span class="line">            <span class="keyword">if</span> (insert) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 忽略此异常，视为加锁失败！</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String lockKey, TimeUnit timeUnit, <span class="keyword">long</span> expireTime)</span> <span class="keyword">throws</span> OperationNotSupportedException </span>&#123;</span><br><span class="line">        UniqLockTableMapper uniqLockTableMapper = UniqLockTableMapperImpl.newInstance();</span><br><span class="line">        <span class="keyword">long</span> expireMillis = timeUnit.toMillis(expireTime);</span><br><span class="line">        <span class="keyword">long</span> currentTimeMillis = System.currentTimeMillis();</span><br><span class="line">        Date now = <span class="keyword">new</span> Date(currentTimeMillis);</span><br><span class="line">        Date expired = <span class="keyword">new</span> Date(currentTimeMillis + expireMillis);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clearExpiredLock();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> insert = uniqLockTableMapper.insert(lockKey, now, expired);</span><br><span class="line">                    <span class="keyword">if</span> (insert) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// 忽略此异常，视为加锁失败！</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">(String lockKey)</span> </span>&#123;</span><br><span class="line">        UniqLockTableMapper uniqLockTableMapper = UniqLockTableMapperImpl.newInstance();</span><br><span class="line">        uniqLockTableMapper.del(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearExpiredLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UniqLockTableMapper uniqLockTableMapper = UniqLockTableMapperImpl.newInstance();</span><br><span class="line">        uniqLockTableMapper.deleteExpired();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这些方法都没能实现分布式锁的可重入性，这里需要新增一个字段，标明分布式锁是谁加的, 再来看看新增分布式锁调用方标识之后的分布式锁定义</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def <span class="keyword">lock</span>:</span><br><span class="line">  clear_expire_time;</span><br><span class="line">  exec sql: <span class="keyword">insert</span> <span class="keyword">into</span> uniq_lock_table(lock_key, create_time, expire_time, biz_uniq_code) <span class="keyword">values</span>(?, ?, ?, ?);</span><br><span class="line">  if result == 1 :</span><br><span class="line">    return true;</span><br><span class="line">  else :</span><br><span class="line">    exec sql : <span class="keyword">select</span> * <span class="keyword">from</span> uniq_lock_table <span class="keyword">where</span> lock_key = ? <span class="keyword">and</span> biz_uniq_code = ?;</span><br><span class="line">    if query_result &gt; 0 :</span><br><span class="line">      return true;</span><br><span class="line">    else :</span><br><span class="line">      return false;</span><br></pre></td></tr></table></figure><p>在使用上面这种方式实现可重入性的时候，需要将表中的唯一索引修改一下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">add</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> <span class="string">`uniq_lock_key_biz_uniq_code`</span>(<span class="string">`lock_key`</span>, <span class="string">`biz_uniq_code`</span>);</span><br></pre></td></tr></table></figure><h5 id="注意：-上面说的这些依赖数据库实现分布式锁，都要避免单数据库示例的问题，如果只有一个数据库示例，而数据库宕机了，分布式锁将不能提供服务；因此，分布式锁依赖的数据库必须配置多数据库实例，利用数据库的主从复制逻辑，保证数据同步！"><a href="#注意：-上面说的这些依赖数据库实现分布式锁，都要避免单数据库示例的问题，如果只有一个数据库示例，而数据库宕机了，分布式锁将不能提供服务；因此，分布式锁依赖的数据库必须配置多数据库实例，利用数据库的主从复制逻辑，保证数据同步！" class="headerlink" title="注意： 上面说的这些依赖数据库实现分布式锁，都要避免单数据库示例的问题，如果只有一个数据库示例，而数据库宕机了，分布式锁将不能提供服务；因此，分布式锁依赖的数据库必须配置多数据库实例，利用数据库的主从复制逻辑，保证数据同步！"></a>注意： 上面说的这些依赖数据库实现分布式锁，都要避免单数据库示例的问题，如果只有一个数据库示例，而数据库宕机了，分布式锁将不能提供服务；因此，分布式锁依赖的数据库必须配置多数据库实例，利用数据库的主从复制逻辑，保证数据同步！</h5><h3 id="2-依赖redis实现分布式锁"><a href="#2-依赖redis实现分布式锁" class="headerlink" title="2. 依赖redis实现分布式锁"></a>2. 依赖redis实现分布式锁</h3><p><code>redis</code> 作为内存数据存储系统，相比数据库具有更好的高可用性<br>先来看看一个 <code>redis</code> 命令, <code>setnx</code></p><pre><code>\&gt; help setnxSETNX key valueTIME COMPLEXITY: O(1)RETURN VALUE: Integer reply, specifically:1 if the key was set0 if the key was not set</code></pre><p>从帮助信息能看明白， <code>setnx</code> 功能和 <code>set</code>指令类似， 不同在于 <code>setnx</code> 只有插入的key 不存在的时候才能插入成功，成功之后返回 1， 失败返回 0<br>我们依赖 <code>setnx</code> 实现分布式锁，定义如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def lock:</span><br><span class="line">  exec cmd: setnx lock_key lock_value;</span><br><span class="line">  if result == 1 :</span><br><span class="line">    return true;</span><br><span class="line">  else result = 0 :</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">def unlock:</span><br><span class="line">  del lock_key;</span><br></pre></td></tr></table></figure><p>上面的定义存在的问题有:</p><ol><li>调用分布式锁的消费者如果在获取锁之后宕机了，这个失效锁将导致其他消费者无法获取锁</li><li>分布式锁不具备可重入性</li></ol><p>为了提供更好用的分布式锁，我们必须给分布式锁加上时效性<br>下面来看看 <code>redis</code> 的 <code>set</code> 指令</p><pre><code>&gt; help setSET key valueTIME COMPLEXITY: O(1)OptionsEX seconds -- Set the specified expire time, in seconds.PX milliseconds -- Set the specified expire time, in milliseconds.NX -- Only set the key if it does not already exist.XX -- Only set the key if it already exist.RETURN VALUE: Status code reply: OK if SET was executed correctly. Null multi-bulk reply: a Null Bulk Reply is returned if the SET operation was not performed becase the user specified the NX or XX option but the condition was not met.</code></pre><p>从这个可以看出来，<code>set</code> 指令可以做到 <code>setnx</code> 指令的目的，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value NX</span><br></pre></td></tr></table></figure><p>再看看下面的指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set key value EX 10 NX; //插入一个 k-v 数据，只有key不存在的时候才能插入成功，插入成功好，10s 内数据有效，10s 后数据失效将被删除</span><br><span class="line">set key value PX 100 NX; //插入一个 k-v 数据，只有key不存在的时候才能插入成功，插入成功好，10 毫秒内数据有效，10 毫秒后数据失效将被删除</span><br></pre></td></tr></table></figure><p>加入有效时间后，分布式锁不需要在每次加锁之前清除无效锁, 得到优化的分布式锁如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def <span class="keyword">lock</span>:</span><br><span class="line">  exec: <span class="keyword">set</span> lock_key lock_value PX expire_time NX; // 这里选择时效时间单位为毫秒，增加锁有效时间的精确性</span><br><span class="line">  if result == OK :</span><br><span class="line">    return true;</span><br><span class="line">  else :</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">def <span class="keyword">unlock</span>:</span><br><span class="line">  del lock_key;</span><br></pre></td></tr></table></figure><p>上面的分布式锁还是没有实现可重入性， 改进如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def <span class="keyword">lock</span>:</span><br><span class="line">  exec: <span class="keyword">set</span> lock_key biz_uniq_code PX expire_time NX; // 插入的value 是 biz_uniq_code, 可以唯一表示加锁的调用方</span><br><span class="line">  if result == OK :</span><br><span class="line">    return true;</span><br><span class="line">  else :</span><br><span class="line">    exec: get lock_key</span><br><span class="line">    if value == biz_uniq_code :</span><br><span class="line">      return true;</span><br><span class="line">    else :</span><br><span class="line">      return false;</span><br></pre></td></tr></table></figure><p>依赖 <code>redis</code> 实现 <code>分布式锁</code> 存在一个难以解决的问题，<code>redis</code> 不能保证数据的 <code>强一致性</code>， 因为；</p><h6 id="redis-集群使用异步复制"><a href="#redis-集群使用异步复制" class="headerlink" title="redis 集群使用异步复制"></a>redis 集群使用异步复制</h6><p>如果在加锁的时候 <code>redis</code> 的 <code>master</code> 宕机了，异步复制到 <code>slave</code> 失败了，加锁就失败了！</p><p>为了解决这个问题，<code>redis</code> 的作者提出了 <code>redLock</code></p><h4 id="RedLock"><a href="#RedLock" class="headerlink" title="RedLock"></a>RedLock</h4><p>这里不对 <code>RedLock</code> 进行介绍，详情见 <code>并发编程网</code> 翻译<br><a href="http://ifeve.com/redis-lock/" target="_blank" rel="noopener">http://ifeve.com/redis-lock/</a></p><h3 id="3-依赖zookeeper-实现分布式锁"><a href="#3-依赖zookeeper-实现分布式锁" class="headerlink" title="3. 依赖zookeeper 实现分布式锁"></a>3. 依赖zookeeper 实现分布式锁</h3><p><code>ZooKeeper</code> 能被用来实现分布式锁的原因取决于他的以下几个特性：</p><ol><li><code>ZooKeeper</code> 的视图结构和 unix 系统的文件系统类似，都是采用树结构，不同的是 <code>ZooKeeper</code> 的树结构上是新定义的 <code>数据节点</code> —— <code>ZNode</code>，<code>ZNode</code> 是 <code>ZooKeeper</code> 中数据的最小单元，可以保存数据，也可以挂靠子节点；</li><li><code>ZooKeeper</code> 中的 <code>ZNode</code> 的类型分为 <code>持久节点</code>、 <code>临时节点</code>、 <code>顺序节点</code> 三大类型；通过组合使用可以生成四种节点：<br>1) <code>持久节点</code>：是指该数据节点被创建之后，就一直存在于 <code>ZooKeeper</code> 服务器上，直到有删除操作来主动清除这个节点；<br>2) <code>持久有序节点</code>：和 <code>持久节点</code> 的基本特性一致，不同的特性在于顺序性上；在 <code>ZooKeeper</code> 中父节点会为它的第一级节点维护一份顺序，用于记录下每个子节点创建的先后顺序。<br>3) <code>临时节点</code>：和 <code>持久节点</code> 不同的是，临时节点的生命周期和客户端的会话相关，如果客户端会话失效了，<code>临时节点</code> 将被自动清除。<br>4) <code>临时有序节点</code>：和 <code>临时节点</code> 的基本特性一致，不同的特性也在于顺序性上；</li><li><code>ZooKeeper</code> 机制规定：同一个目录下只能有一个唯一的文件名。例如：我们在 <code>Zookeeper</code> 目录一个目录下创建，两个客户端创建一个名为 <code>new_node</code> 节点，只有一个能够成功。</li><li><code>ZooKeeper</code> 提供 <code>Watcher</code> 机制，客户端可以在服务端注册一个 <code>Watcher</code> 监听，当服务端的一些指定事件触动了这个 <code>Watcher</code>，就会向客户端发送通知</li></ol><h4 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h4><p>依赖上述特性，我们可以在 <code>ZooKeeper</code> 的树结构上，创建一个临时节点 <code>/distribute_lock/lock</code>, 只要有一个客户端创建了节点，表示该客户端获取到了锁；<br>而其他没有获取到锁的客户端，需要到 <code>ZooKeeper</code> 的 <code>/distribute_lock</code> 节点上注册一个子节点变更的 <code>Watcher</code> 监听，以便见听到子节点的变更情况。</p><blockquote><p>— distribute_lock <br></p><blockquote><p>— lock</p></blockquote></blockquote><p><img src="/assets/picture/zk_simple_lock.png" alt="图片"></p><h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><p>1) 客户端执行完业务逻辑后，主动删除自己创建的临时节点；<br>2) 客户端宕机后，<code>ZooKeeper</code> 和客户端之间的对话失效、连接断开，客户端创建的临时节点将被自动删除<br>3) 客户端释放锁之后，其他客户端通过 <code>Watcher</code> 监控得到锁被释放的通知，而来竞争获取锁</p>]]></content>
      
      <categories>
          
          <category> 分布式锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mybatis 源码阅读(一)</title>
      <link href="/2016/09/20/%E6%8A%80%E6%9C%AF/mybatis/2016-09-20-mybatis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2016/09/20/%E6%8A%80%E6%9C%AF/mybatis/2016-09-20-mybatis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      <content type="html"><![CDATA[<h6 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h6><p>我们开始从mybatis 启动流程开始阅读源码</p><p><code>mybatis</code> 的配置信息层次结构：</p><blockquote><p>configuration</p><blockquote><p>properties</p></blockquote><blockquote><p>settings</p></blockquote><blockquote><p>typeAliases</p></blockquote><blockquote><p>typeHandlers</p></blockquote><blockquote><p>objectFactory</p><p>objectWrapperFactory</p><p>reflectorFactory</p><p>plugins</p><p>environments</p><blockquote><p>transactionManager</p></blockquote><blockquote><p>dataSource</p></blockquote><p>databaseIdProvider</p><p>mappers</p></blockquote></blockquote><p>无论是结合 <code>Spring</code> 使用 <code>Mybatis</code> 还是单独使用，在启动的时候都需要经过这个入口 <code>SqlSessionFactoryBuilder</code> 来构建  <code>SqlSessionFactory</code></p><p>使用 <code>SqlSessionFactoryBuilder</code> 构建  <code>SqlSessionFactory</code> 有两种方：编码方式，Xml 配置方式；</p><p>获取  <code>SqlSessionFactory</code> 的主体调用流程如下：<br>org.apache.ibatis.session.SqlSessionFactoryBuilder#build(Reader or InputStream);<br>org.apache.ibatis.builder.xml.XMLConfigBuilder#XMLConfigBuilder();<br>org.apache.ibatis.builder.xml.XMLConfigBuilder#parse<br>org.apache.ibatis.builder.xml.XMLConfigBuilder#parseConfiguration<br>org.apache.ibatis.session.SqlSessionFactoryBuilder#build(org.apache.ibatis.session.Configuration)<br>得到的 <code>SqlSessionFactory</code> 的默认实现 <code>DefaultSqlSessionFactory</code></p><p>编码方式这里不做赘述， 配置文件的方式主要流程如下得到 <code>Configuration</code><br><img src="/assets/picture/mybatis_source_to_configuration.png" alt="图片" title="加载mybatis 配置信息的途径"></p><p>xml 配置方式主要依赖 <code>XMLConfigBuilder</code> 来解析配置文件</p><pre><code>private void parseConfiguration(XNode root) {    try {      //issue #117 read properties first      //解析 xml 中 &lt;properties&gt; 标签，主要是解析url 和 resource， 需要注意的是这两个配置不能同时存在      propertiesElement(root.evalNode(&quot;properties&quot;));      // 注册 type aliase 可以使用 package 扫描一个文件夹中的所有 带@Alias 注解的所有类      // [注意] alias 会忽略大小写 toLowCase      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));      pluginElement(root.evalNode(&quot;plugins&quot;));      // MyBatis uses an `ObjectFactory` to create all needed new Objects.      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));      //      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));      reflectionFactoryElement(root.evalNode(&quot;reflectionFactory&quot;));      settingsElement(root.evalNode(&quot;settings&quot;));      // read it after objectFactory and objectWrapperFactory issue #631      //      environmentsElement(root.evalNode(&quot;environments&quot;));      // 通过xml 中设置的type 别名构建 DatabaseIdProvider， 默认为 VendorDatabaseIdProvider      // 再通过 DatabaseIdProvider 获取 databaseId， 设置到 Configuration.databaseId      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));      // TypeHander 对应一个 Class 以及一个 JdbcType      // 注册 TypeHander 时可以一个个的注册，也可以注册一个 package 中所有实现了 `TypeHandler` 接口的类      // 通过继承 BaseTypeHandler 自定义的TypeHander      // TypeHandler 如果没有通过 @MappedJdbcTypes 指定的JdbcType 则为null      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));      mapperElement(root.evalNode(&quot;mappers&quot;));    } catch (Exception e) {      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);    }  }</code></pre><p>mybatis 的重要组成部分是 mapper xml 文件，对于这些文件的解析很重要<br>解析 package 中的接口时，获取 package 下的所有接口， 依次直接使用 <code>MapperRegister</code> 注册 Interface –&gt; MapperProxyFactory</p><p>使用 <mapper> 标签中的 <code>mapperClass</code> 配置接口信息， 也是 <code>MapperRegister</code> 注册 Interface –&gt; MapperProxyFactory</mapper></p><p>使用 <mapper> 标签中的 <code>url</code> 或 <code>resource</code> 配置 mapper xml 文件的路径， 使用 <code>XmlMappperBuilder</code> 解析 xml 文件</mapper></p><p>这里先介绍 <code>MapperRegister</code> <code>MapperProxyFactory</code></p><p><code>MapperRegister</code> 中保存了 Interface –&gt; MapperProxyFactory 的map</p><p><code>mybatis</code> 中大量使用了设计模式， <code>MapperProxyFactory</code> 使用了工厂模式<br><code>MapperProxyFactory</code> 一看就是生产 <code>MapperProxy</code> 的工厂类， 提供 org.apache.ibatis.binding.MapperProxyFactory#newInstance(org.apache.ibatis.session.SqlSession)<br>方法获取 Mapper Interface 的实现类</p><p><code>MapperProxy</code> 是java 动态代理的使用，<code>MapperProxy</code> 实现了 <code>InvocationHandler</code> 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *    Copyright 2009-2015 the original author or authors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment"> *    you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> *    You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *       http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> *    distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"> *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> *    See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> *    limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> org.apache.ibatis.binding;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lasse Voss</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// MapperProxy 代理的 Mapper 接口</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="comment">// 这里的Key 是 Mapper 接口中方法对象，Value 是方法对象的封装</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;Method, MapperMethod&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperProxyFactory</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getMapperInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;Method, MapperMethod&gt; <span class="title">getMethodCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 Sqlsession 获取 Mapper 接口</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Configuration</code>: mybatis 配置信息的根节点</p><pre><code>public Configuration() {    // 这里注册了很多类的别名，在需要的时候通过反射机制获取 类的实例    typeAliasRegistry.registerAlias(&quot;JDBC&quot;, JdbcTransactionFactory.class);    typeAliasRegistry.registerAlias(&quot;MANAGED&quot;, ManagedTransactionFactory.class);    typeAliasRegistry.registerAlias(&quot;JNDI&quot;, JndiDataSourceFactory.class);    typeAliasRegistry.registerAlias(&quot;POOLED&quot;, PooledDataSourceFactory.class);    typeAliasRegistry.registerAlias(&quot;UNPOOLED&quot;, UnpooledDataSourceFactory.class);    typeAliasRegistry.registerAlias(&quot;PERPETUAL&quot;, PerpetualCache.class);    typeAliasRegistry.registerAlias(&quot;FIFO&quot;, FifoCache.class);    typeAliasRegistry.registerAlias(&quot;LRU&quot;, LruCache.class);    typeAliasRegistry.registerAlias(&quot;SOFT&quot;, SoftCache.class);    typeAliasRegistry.registerAlias(&quot;WEAK&quot;, WeakCache.class);    typeAliasRegistry.registerAlias(&quot;DB_VENDOR&quot;, VendorDatabaseIdProvider.class);    typeAliasRegistry.registerAlias(&quot;XML&quot;, XMLLanguageDriver.class);    typeAliasRegistry.registerAlias(&quot;RAW&quot;, RawLanguageDriver.class);    typeAliasRegistry.registerAlias(&quot;SLF4J&quot;, Slf4jImpl.class);    typeAliasRegistry.registerAlias(&quot;COMMONS_LOGGING&quot;, JakartaCommonsLoggingImpl.class);    typeAliasRegistry.registerAlias(&quot;LOG4J&quot;, Log4jImpl.class);    typeAliasRegistry.registerAlias(&quot;LOG4J2&quot;, Log4j2Impl.class);    typeAliasRegistry.registerAlias(&quot;JDK_LOGGING&quot;, Jdk14LoggingImpl.class);    typeAliasRegistry.registerAlias(&quot;STDOUT_LOGGING&quot;, StdOutImpl.class);    typeAliasRegistry.registerAlias(&quot;NO_LOGGING&quot;, NoLoggingImpl.class);    typeAliasRegistry.registerAlias(&quot;CGLIB&quot;, CglibProxyFactory.class);    typeAliasRegistry.registerAlias(&quot;JAVASSIST&quot;, JavassistProxyFactory.class);    // 注册语言管理驱动，默认语言管理驱动为：`XMLLanguageDriver`    languageRegistry.setDefaultDriverClass(XMLLanguageDriver.class);    languageRegistry.register(RawLanguageDriver.class);  }</code></pre><p><code>ObjectFactory</code>:</p><p><code>Reflector</code></p><p><code>ObjectWrapper</code></p><p><code>TransactionFactory</code></p><p><code>TypeAliasRegistry</code></p><p><code>LanguageRegistry</code></p>]]></content>
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线上应用故障排查</title>
      <link href="/2016/09/13/%E6%8A%80%E6%9C%AF/java/2016-09-13-CPU%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/"/>
      <url>/2016/09/13/%E6%8A%80%E6%9C%AF/java/2016-09-13-CPU%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h4 id="CPU-100-处理流程"><a href="#CPU-100-处理流程" class="headerlink" title="CPU 100% 处理流程"></a>CPU 100% 处理流程</h4><p>当我们遇到 CPU 使用率过高的情况时(这里只考虑 <code>Linux/Solaris</code> 系统)<br>首先想到了 <code>top</code> 指令</p><pre><code>&gt; top</code></pre><p>先看看哪个进程使用的cpu 比较高,　当然这里只讲 JVM 使用 CPU 过高的情况;</p><p><img src="/assets/picture/top_cpu_fix.png" alt="图片" title="top 指令执行效果图"><br>这里的图片只是示例用，不存在cpu 使用率过高的问题</p><p>在查询到 vmid 后，查询虚拟机进程中哪个线程使用的 cpu 比较高</p><pre><code>&gt; ps -mp pid -o THREAD,tid,time</code></pre><p>确定了使用　cpu 过高的虚拟机线程 id 后，记录下　threadId</p><p>然后再使用　<code>jstack</code> 记录当前虚拟机线程信息快照</p><pre><code>$ jstack -l vmid　&gt; outofcpu.threaddump</code></pre><p> 这里已经获得了　<code>threadId</code> 和　当前的虚拟机线程信息快照信息</p><p> 我们可以考虑重启一下 tomcat 或者直接重启 JVM</p><p> 对于保存的　<code>threadId</code> 和　<code>outofcpu.threaddump</code><br> 在 threaddump 文件中查看　threadId 线程信息定位代码问题，达到修复目的</p><hr><h4 id="内存使用过高处理流程"><a href="#内存使用过高处理流程" class="headerlink" title="内存使用过高处理流程"></a>内存使用过高处理流程</h4><p>当我们遇到 <code>内存</code>  使用率过高的情况时(这里只考虑 <code>Linux/Solaris</code> 系统)<br><br>首先想到了还是 <code>top</code> 指令</p><p><img src="/assets/picture/top_mem.png" alt="图片" title="top 指令执行效果图"></p><p>我们看到这里的tomcat 占用内存大到了 60% 多， 记录下 vmid</p><p>下面我们尝试查看这个进程中具体线程的内存使用情况<br><img src="/assets/picture/ps_thread_mem_bug.png" alt="图片" title="ps 指令无法查询进程中具体线程的内存适用情况"><br>这里可以看出</p><h6 id="ps-指令无法查询进程中具体线程的内存适用情况"><a href="#ps-指令无法查询进程中具体线程的内存适用情况" class="headerlink" title="ps 指令无法查询进程中具体线程的内存适用情况"></a>ps 指令无法查询进程中具体线程的内存适用情况</h6><br>不过我们还有 java 提供的工具 jmap<pre><code>&gt; sudo jmap -F -histo 12788 &gt; test.dump</code></pre><p>这里使用 <code>jmap -histo</code> 指令去 统计 JVM 堆中的对象信息</p><pre><code>&gt; sudo jmap -F -dump:format=b,file=test.all.dump 12788</code></pre><p>这里使用 <code>jmap -dump</code> 指令去生成JVM 堆存储快照， 后面在用 jhat visualvm 等工具进行分析</p><p>在分析之前，我们可以考虑一下是否需要重启服务</p><hr><p>这里在介绍一下 ps 的具体使用<br><img src="/assets/picture/ps_help.png" alt="图片" title="ps 帮助信息"></p><p>-m: 显示当前 <code>process id</code> 进程下的线程的信息<br>-o: 用户自定义显示列</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM 性能监控和故障处理工具</title>
      <link href="/2016/09/12/%E6%8A%80%E6%9C%AF/java/2016-09-12-JVM%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/"/>
      <url>/2016/09/12/%E6%8A%80%E6%9C%AF/java/2016-09-12-JVM%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<h3 id="jps-JVM-Process-Status-Tool"><a href="#jps-JVM-Process-Status-Tool" class="headerlink" title="jps (JVM Process Status Tool)"></a>jps (JVM Process Status Tool)</h3><h4 id="显示指定系统中的所有虚拟机进程"><a href="#显示指定系统中的所有虚拟机进程" class="headerlink" title="显示指定系统中的所有虚拟机进程"></a>显示指定系统中的所有虚拟机进程</h4><pre><code>&gt; jps [ options ] [ hostid ]</code></pre><p><img src="/assets/picture/jps_help.png" alt="图片" title="JPS 指令说明"></p><p>jps 选项 [ options ] 说明：<br><br>-q 只输出LVMID 省略主类的名称；<br><br>-m 输出虚拟机进程启东市传递给主类main函数的参数；<br><br>-l 输出主类的名称，如果进程执行的是jar包，输出jar 路径；<br><br>-v 输出虚拟机进程启动时的JVM 参数</p><h4 id="注意"><a href="#注意" class="headerlink" title="[ 注意 ]"></a>[ 注意 ]</h4><p>使用 jps 指令得到的输出结果可能是下面这样的</p><pre><code>pid -- process information unavailable</code></pre><p>JVM 会在本地文件系统中的 tmp 文件夹中新建 <code>hsperfdata_{username}/{pid}</code> 文件， 如果当前执行 jps 指令的用户没有属于自己的这个文件，就会出现这种提示</p><p>例如： 我们公司tomcat 的启动用户默认是 <code>tomcat</code>,  JVM 新建的文件是 <code>/tmp/hsperfdata_tomcat/pid</code>(这是在linux系统中)，这样导致了如下问题</p><h6 id="不管使用-root-用户权限还是-普通用户权限都不能执行-jps-指令"><a href="#不管使用-root-用户权限还是-普通用户权限都不能执行-jps-指令" class="headerlink" title="不管使用 root 用户权限还是 普通用户权限都不能执行 jps 指令"></a>不管使用 root 用户权限还是 普通用户权限都不能执行 jps 指令</h6><h5 id="上述问题解决方案"><a href="#上述问题解决方案" class="headerlink" title="上述问题解决方案"></a>上述问题解决方案</h5><pre><code>sudo -u tomcat jps pid</code></pre><hr><h3 id="jstat-JVM-Statistics-Monitoring-Tool"><a href="#jstat-JVM-Statistics-Monitoring-Tool" class="headerlink" title="jstat (JVM Statistics Monitoring Tool)"></a>jstat (JVM Statistics Monitoring Tool)</h3><pre><code>&gt; jstat [ option vmid [interval [s|ms] [count]]  ]</code></pre><p>参数  <code>interval</code>, <code>count</code> 代表查询的间隔时间和次数，如果省略这两个参数表示只查询一次<br>假设需要每 1s 查询一次进程 3234 的jvm gc信息，一共查询10次</p><pre><code>&gt; jstat -gc 3234 1s 10</code></pre><table><thead><tr><th align="left">选项</th><th>作用描述</th></tr></thead><tbody><tr><td align="left">-class</td><td>监视类装载、卸载数量、总空间以及类装载所耗费的时间</td></tr><tr><td align="left">-gc</td><td>监视 JVM 堆状况，包括 Eden区、两个survivor 区、老年代、永生代等的容量、已用空间、GC时间合计等信息</td></tr><tr><td align="left">-gccapacity</td><td>监视内容与 -gc 基本相同，但输出主要关注java 堆各个区域使用到的最大、最小空间</td></tr><tr><td align="left">-gcutil</td><td>监视内容与 -gc 基本相同，但输出主要关注已经使用空间占总空间的百分比</td></tr><tr><td align="left">-gccause</td><td>与 -gcutil 功能一样，但是会额外输出导致上一次 GC 产生的原因</td></tr><tr><td align="left">-gcnew</td><td>监视新生代 gc 状况</td></tr><tr><td align="left">-gcnewcapacity</td><td>监视内容与 -gcnew 基本相同，但输出主要关注新生代已经使用到的最大、最小空间</td></tr><tr><td align="left">-gcold</td><td>监视老年代 gc 状况</td></tr><tr><td align="left">-gcoldcapacity</td><td>监视内容与 -gcold 基本相同，但输出主要关注老年代已经使用到的最大、最小空间</td></tr><tr><td align="left">-gcpermcapacity</td><td>输出永久代已经使用到的最大、最小空间</td></tr><tr><td align="left">-compiler</td><td>输出JIT 编译器编译过的方法、耗时等信息</td></tr><tr><td align="left">-gccompilation</td><td>输出已经呗 JIT 编译的方法</td></tr></tbody></table><hr><h3 id="jinfo-Configuration-Info-for-java"><a href="#jinfo-Configuration-Info-for-java" class="headerlink" title="jinfo (Configuration Info for java)"></a>jinfo (Configuration Info for java)</h3><h4 id="实时查询和调整虚拟机各项参数"><a href="#实时查询和调整虚拟机各项参数" class="headerlink" title="实时查询和调整虚拟机各项参数"></a>实时查询和调整虚拟机各项参数</h4><pre><code>&gt; jinfo [ option ] pidliam@liamchen-ubuntu:~$ jinfo -helpUsage:    jinfo [option] &lt;pid&gt;        (to connect to running process)    jinfo [option] &lt;executable &lt;core&gt;        (to connect to a core file)    jinfo [option] [server_id@]&lt;remote server IP or hostname&gt;        (to connect to remote debug server)where &lt;option&gt; is one of:    -flag &lt;name&gt;         to print the value of the named VM flag    -flag [+|-]&lt;name&gt;    to enable or disable the named VM flag    -flag &lt;name&gt;=&lt;value&gt; to set the named VM flag to the given value    -flags               to print VM flags    -sysprops            to print Java system properties    &lt;no option&gt;          to print both of the above    -h | -help           to print this help message</code></pre><hr><h3 id="jmap-Memory-Map-for-Java"><a href="#jmap-Memory-Map-for-Java" class="headerlink" title="jmap (Memory Map for Java)"></a>jmap (Memory Map for Java)</h3><h4 id="生成对存储快照"><a href="#生成对存储快照" class="headerlink" title="生成对存储快照"></a>生成对存储快照</h4><pre><code>&gt; jmap [ option ] vmid</code></pre><table><thead><tr><th align="left">选项</th><th>作用描述</th></tr></thead><tbody><tr><td align="left">-dump</td><td>生成 JVM 堆存储快照。 格式为: dump:[live,]format=b,file=<filename>，其中live参数说明是否只dump 出存活的对象</filename></td></tr><tr><td align="left">-finalizeinfo</td><td>显示在F-Queue 中等待Finalizer线程执行 finalize 方法的对象，只在 linux/solaris 平台下有效</td></tr><tr><td align="left">-heap</td><td>显示 JVM 堆详细信息，如使用那种回收器、参数配置、分代情况等。只在 linux/solaris 平台下有效</td></tr><tr><td align="left">-histo</td><td>显示堆中对象统计信息，包括类、实例数量、合计数量</td></tr><tr><td align="left">-permstat</td><td>以ClassLoader为统计口径，显示永生代内存状态，只在 linux/solaris 平台下有效</td></tr><tr><td align="left">-F</td><td>当 JVM 进程对 -dump 指令选项没有响应时，可使用这个选项强制生成dump 快照，只在 linux/solaris 平台下有效</td></tr></tbody></table><pre><code>使用示例：&gt; jmap -dump:format=b,file=test.dump pid</code></pre><hr><h3 id="jhat-JVM-Heap-Analysis-Tool"><a href="#jhat-JVM-Heap-Analysis-Tool" class="headerlink" title="jhat (JVM Heap Analysis Tool)"></a>jhat (JVM Heap Analysis Tool)</h3><h4 id="与jmap搭配使用，-来分析-jmap-生成的-堆存储快照文件"><a href="#与jmap搭配使用，-来分析-jmap-生成的-堆存储快照文件" class="headerlink" title="与jmap搭配使用， 来分析 jmap 生成的 堆存储快照文件"></a>与jmap搭配使用， 来分析 jmap 生成的 堆存储快照文件</h4><pre><code>&gt; jhat test.dump</code></pre><p>当屏幕上出现 “Server is ready” 提示后，访问 <code>http://localhost:7000</code> 就能看到分析结果</p><h6 id="注意-分析工作比较消耗资源，可将dump-文件复制到其他机器上分析"><a href="#注意-分析工作比较消耗资源，可将dump-文件复制到其他机器上分析" class="headerlink" title="[ 注意 ] : 分析工作比较消耗资源，可将dump 文件复制到其他机器上分析"></a>[ 注意 ] : 分析工作比较消耗资源，可将dump 文件复制到其他机器上分析</h6><hr><h3 id="jstack-Stack-Trace-for-Java"><a href="#jstack-Stack-Trace-for-Java" class="headerlink" title="jstack (Stack Trace for Java)"></a>jstack (Stack Trace for Java)</h3><h4 id="生成JVM-当前时刻的线程快照"><a href="#生成JVM-当前时刻的线程快照" class="headerlink" title="生成JVM 当前时刻的线程快照"></a>生成JVM 当前时刻的线程快照</h4><pre><code>&gt; jstack [ option ] vmid</code></pre><table><thead><tr><th align="left">选项</th><th>作用描述</th></tr></thead><tbody><tr><td align="left">-l</td><td>除堆栈外，显示关于锁的附加信息</td></tr><tr><td align="left">-m</td><td>打印</td></tr><tr><td align="left">-F</td><td>当 JVM 进程对指令没有响应时，可使用这个选项强制生成 threaddump 快照，只在 linux/solaris 平台下有效</td></tr></tbody></table><h2 id="GC-日志"><a href="#GC-日志" class="headerlink" title="GC 日志"></a>GC 日志</h2><h3 id="日志设置"><a href="#日志设置" class="headerlink" title="日志设置"></a>日志设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS=<span class="string">"-Xms8g -Xmx16g -XX:PermSize=512m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=../logs  -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:../logs/gc.log"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql explain 介绍</title>
      <link href="/2016/09/08/%E6%8A%80%E6%9C%AF/mysql/2016-09-08-mysql%20explain%20%E8%AF%A6%E8%A7%A3/"/>
      <url>/2016/09/08/%E6%8A%80%E6%9C%AF/mysql/2016-09-08-mysql%20explain%20%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>mysql 为我们提供了一个很好用的 sql 语句分析工具 <code>explain</code> , 它可以帮助我们选择更好的索引和写出更优化的查询语句。</p><p><code>explain</code> 会显示sql 语句如何使用索引</p><h6 id="注意：在-mysql-5-6-之前-explain-只能分析-select-语句，其他类型的语句只能先改写为-select-语句再分析；-但是-mysql-5-6-及以后，-explain-支持其他语句的解析！！！"><a href="#注意：在-mysql-5-6-之前-explain-只能分析-select-语句，其他类型的语句只能先改写为-select-语句再分析；-但是-mysql-5-6-及以后，-explain-支持其他语句的解析！！！" class="headerlink" title="注意：在 mysql 5.6 之前 explain 只能分析 select 语句，其他类型的语句只能先改写为 select 语句再分析； 但是 mysql 5.6 及以后， explain 支持其他语句的解析！！！"></a>注意：在 <code>mysql 5.6</code> 之前 <code>explain</code> 只能分析 <code>select</code> 语句，其他类型的语句只能先改写为 <code>select</code> 语句再分析； 但是 <code>mysql 5.6</code> 及以后， <code>explain</code> 支持其他语句的解析！！！</h6><p>先来个使用范例</p><pre><code>exlain select sql如：explain select * from grade_info where teacher_id = &apos;1&apos;;</code></pre><p>下面看看 <code>explain</code> 的执行结果：<br><img src="/assets/picture/mysql_index_a.png" alt="图片" title="使用索引第一列的情况"><br><code>explain</code> 的结果有这些列<br><br> <code>id</code>, <code>select_type</code>, <code>table</code>, <code>partitions</code>, <code>type</code>, <code>possible_keys</code>, <code>key</code>, <code>key_len</code>, <code>ref</code>, <code>rows</code>, <code>filtered</code>, <code>Extra</code></p><h4 id="explain-输出字段概要说明"><a href="#explain-输出字段概要说明" class="headerlink" title="explain 输出字段概要说明"></a><code>explain</code> 输出字段概要说明</h4><table><thead><tr><th>列名</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>sql 语句中多个嵌套语句的唯一标识，如果只有一条 sql 始终为 1</td></tr><tr><td>select_type</td><td>select 语句的类型，或其他语句的类型（较高版本中 explain 支持 delete,update,insert 等语句）</td></tr><tr><td>table</td><td>表名称，或者 sql 中表的别名</td></tr><tr><td>partitions</td><td>匹配的分区</td></tr><tr><td>type</td><td>连接类型</td></tr><tr><td>possible_keys</td><td>可能被用到的索引名称</td></tr><tr><td>key</td><td>实际被使用的索引的名称</td></tr><tr><td>key_len</td><td>被选用的索引实际被使用的长度</td></tr><tr><td>ref</td><td>和索引比较的列，todo</td></tr><tr><td>rows</td><td>将要被检查的行数的估计值</td></tr><tr><td>filtered</td><td>被“表”条件过滤的行数的百分比</td></tr><tr><td>Extra</td><td>附加信息</td></tr></tbody></table><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>sql 语句执行顺序号， 就是sql 语句的执行顺序<br><img src="../../..//assets/picture/mysql_nested_sql_explain.png" alt="图片" title="mysql嵌套语句"><br>这里可以看到 id 的变化</p><h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h4><p>select 语句的类型</p><table><thead><tr><th>取值</th><th>说明</th></tr></thead><tbody><tr><td>SIMPLE</td><td>简单的查询语句（没有子查询，也没有 UNION）</td></tr><tr><td>PRIMARY</td><td>–</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mysql 索引</title>
      <link href="/2016/09/07/%E6%8A%80%E6%9C%AF/mysql/2016-09-07-mysql%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"/>
      <url>/2016/09/07/%E6%8A%80%E6%9C%AF/mysql/2016-09-07-mysql%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/</url>
      <content type="html"><![CDATA[<h2 id="Mysql-索引"><a href="#Mysql-索引" class="headerlink" title="Mysql 索引"></a>Mysql 索引</h2><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p>mysql 索引分为 <code>聚簇索引</code> 和 <code>非聚簇索引</code><br><br><code>聚簇索引</code>：数据的物理存储顺序和索引的顺序是一致的<br><br><code>非聚簇索引</code>：数据的物理存储顺序和索引的顺序不一致<br><br>很明显数据的物理存储顺序只有一种，所以 <code>聚簇索引</code> 只能有一个</p><h3 id="关于联合索引"><a href="#关于联合索引" class="headerlink" title="关于联合索引"></a>关于联合索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`grade_info`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'自增主键'</span>,</span><br><span class="line">  <span class="string">`grade`</span> <span class="keyword">double</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'成绩'</span>,</span><br><span class="line">  <span class="string">`teacher_id`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'教师id'</span>,</span><br><span class="line">  <span class="string">`class_id`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'课程id'</span>,</span><br><span class="line">  <span class="string">`student_id`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'学生id'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`grade_info_teacher_id_IDX`</span> (<span class="string">`teacher_id`</span>,<span class="string">`class_id`</span>,<span class="string">`student_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">30</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4</span><br></pre></td></tr></table></figure><p>先创建一个表，这个表中有个联合索引 <code>grade_info_teacher_id_IDX</code></p><p>下面插入几条数据：</p><p><img src="/assets/picture/multiindex.png" alt="图片" title="grade_info 中的数据"></p><p>下面开始讨论下面几个问题:</p><pre><code>`grade_info_teacher_id_IDX` (teacher_id, class_id, student_id) 这个索引如果查询条件只有teacher_id，会用上索引么？&lt;br /&gt;如果查询条件中有teacher_id, student_id会用上索引么？&lt;br /&gt;如果查询条件中有class_id, student_id会用上索引么？&lt;br /&gt;如果查询条件中有teacher_id, class_id会用上索引么？&lt;br /&gt;</code></pre><p><img src="/assets/picture/mysql_index_a.png" alt="图片" title="使用索引第一列的情况"></p><p>很明显当查询条件中使用了联合索引的第一列的时候会用上索引</p><p><img src="/assets/picture/mysql_index_a_c.png" alt="图片" title="使用索引第一列和第三列的情况"></p><p>这里当查询条件使用联合索引的第一列和第三列的时候也会用上索引，<br>但是这里有个问题， 图中的查询条件只会查询出一条，但是现在问题出现了， 但<code>explain</code> 结果中的row 是 2， 这里得知 索引只用到了第一列</p><p><img src="/assets/picture/mysql_index_b_c.png" alt="图片" title="使用索引第二列、第三列的情况"><br>很明显，这种查询条件没用上索引</p><p><img src="/assets/picture/mysql_index_a_c.png" alt="图片" title="使用索引第一列、第二列的情况"><br>这里使用到了索引，而且索引的长度和 只使用第一列的时候相比更长； 可以确定这里使用了索引的前两列</p><h3 id="索引的限制"><a href="#索引的限制" class="headerlink" title="索引的限制"></a>索引的限制</h3><p>这里说的索引的限制将能解释上面联合索引的问题</p><h4 id="1-如果不是按照索引的最左列开始查询，则无法使用索引"><a href="#1-如果不是按照索引的最左列开始查询，则无法使用索引" class="headerlink" title="1. 如果不是按照索引的最左列开始查询，则无法使用索引"></a>1. 如果不是按照索引的最左列开始查询，则无法使用索引</h4><p>如果查询条件中有class_id, student_id会用上索引么？<br>这里就能回答这个问题，不会；</p><h4 id="2-不能跳过索引中的列"><a href="#2-不能跳过索引中的列" class="headerlink" title="2. 不能跳过索引中的列"></a>2. 不能跳过索引中的列</h4><p>如果查询条件中有teacher_id, student_id会用上索引么？<br>这里跳过了第二列，这个时候只使用索引的第一列</p><h4 id="3-如果查询中有某列的范围查询，则其右边的所有列的查询都不能使用索引优化查找"><a href="#3-如果查询中有某列的范围查询，则其右边的所有列的查询都不能使用索引优化查找" class="headerlink" title="3. 如果查询中有某列的范围查询，则其右边的所有列的查询都不能使用索引优化查找"></a>3. 如果查询中有某列的范围查询，则其右边的所有列的查询都不能使用索引优化查找</h4><p><img src="/assets/picture/mysql_index_a_b_c_range.png" alt="图片" title="索引全覆盖，但最左列是范围查询"><br>从 <code>explain</code> 中 row 是 3， 但是查询到结果只有一个，而只按照第一列范围查询结果是3，这个例子可以印证上述限制</p><h3 id="索引的选择"><a href="#索引的选择" class="headerlink" title="索引的选择"></a>索引的选择</h3><p>突然发现一个问题，mysql 是如何选择索引的？</p><p>下面看看这个表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `school`;</span><br><span class="line">CREATE TABLE `school` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;,</span><br><span class="line">  `name` varchar(20) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;学校名称&apos;,</span><br><span class="line">  `phone` varchar(20) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;学校电话&apos;,</span><br><span class="line">  `addr` varchar(255) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;学校地址&apos;,</span><br><span class="line">  `email` varchar(30) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `idx_name_phone_email` (`name`,`phone`,`email`),</span><br><span class="line">  KEY `idx_name_phone` (`name`,`phone`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COMMENT=&apos;学校&apos;</span><br></pre></td></tr></table></figure><p><code>idx_name_phone_email</code> 和 <code>idx_name_phone</code> 这两个索引，设置的 <em>极不合理</em> ，这里 <em>不推荐使用</em> ， 但是这种情况下，mysql 会选择哪个索引呢？</p><p>插入一条测试数据<br><img src="/assets/picture/school_long_idx.png" alt="图片"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc <span class="keyword">select</span> * <span class="keyword">from</span> school <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'重庆邮电大学'</span> <span class="keyword">and</span> phone = <span class="string">'76822313'</span>\G</span><br></pre></td></tr></table></figure><p>执行一下上面这个 sql 语句，两个索引都可能被用到，会是哪一个呢？</p><p>这里我们能看到，使用的是 <code>idx_name_phone_email</code><br><img src="/assets/picture/school_long_idx2.png" alt="图片" title="使用索引 `idx_name_phone_email`"></p><p>这里做一个简单的猜想，为什么使用的是 <code>idx_name_phone_email</code>, 这和索引的声明顺序有关吗？</p><p>重新建表看看：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`school`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`school`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'学校名称'</span>,</span><br><span class="line">  <span class="string">`phone`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'学校电话'</span>,</span><br><span class="line">  <span class="string">`addr`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'学校地址'</span>,</span><br><span class="line">  <span class="string">`email`</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_name_phone`</span> (<span class="string">`name`</span>,<span class="string">`phone`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_name_phone_email`</span> (<span class="string">`name`</span>,<span class="string">`phone`</span>,<span class="string">`email`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">2</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'学校'</span></span><br></pre></td></tr></table></figure><p>修改了索引定义顺序之后， 使用的索引也随之改变了</p><p><img src="/assets/picture/school_short_idx.png" alt="图片" title="使用索引 `idx_name_phone`"></p><p>好像，我们的猜想被证实了</p><h6 id="如果我们需要制定使用哪个索引呢？"><a href="#如果我们需要制定使用哪个索引呢？" class="headerlink" title="如果我们需要制定使用哪个索引呢？"></a>如果我们需要制定使用哪个索引呢？</h6><p><img src="/assets/picture/school_short_idx.png" alt="图片" title="使用 force index"></p><p><code>force index(idx_name)</code>: 使用这个关键字强制指定要用的索引即可</p><p>还有其他方式吗？</p><p>可以 <code>use index(idx_name)</code> 推荐使用的索引</p><p><img src="/assets/picture/school_use_idx.png" alt="图片" title="使用 use index"></p><h6 id="use-index-和-force-index-的区别"><a href="#use-index-和-force-index-的区别" class="headerlink" title="use index 和 force index 的区别"></a><code>use index</code> 和 <code>force index</code> 的区别</h6><pre><code>If you use USE INDEX then you RECOMMEND optimizer to use this index, but it can use a table scan if optimizer thinks it will be faster. If you use FORCE INDEX then you MAKE optimizer to use this index even if it thinks a table scan is more efficient. Optimizer will use a table scan only if there is no way to use index to find rows.</code></pre><p>也就是说， 使用 <code>USE INDEX</code> 时 sql 优化可能会进行全表扫描，如果全表扫描更快的话； 而使用 <code>FORCE INDEX</code> 时，只能是使用索引，除非查询条件没有命中索引</p><p>指定使用索引还有一个使用场景，就是解决之前说到的 <em>范围查询时，索引无效</em></p><p><img src="/assets/picture/school_force_idx_range_query.png" alt="图片" title="范围查询时强制使用索引"></p><p>除了指定要使用的索引，还能指定不使用哪些索引</p><p><img src="/assets/picture/school_ignore_idx.png" alt="图片" title="使用 ignore index"></p><p>排除掉不使用的索引，就能使用想要使用的索引</p>]]></content>
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>synchronized 关键字</title>
      <link href="/2016/07/27/%E6%8A%80%E6%9C%AF/java/2016-07-27-synchronized%20%E5%87%A0%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/"/>
      <url>/2016/07/27/%E6%8A%80%E6%9C%AF/java/2016-07-27-synchronized%20%E5%87%A0%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/</url>
      <content type="html"><![CDATA[<h2 id="synchronized-几种使用方法比较"><a href="#synchronized-几种使用方法比较" class="headerlink" title="synchronized 几种使用方法比较"></a>synchronized 几种使用方法比较</h2><p><code>synchronized</code> 关键字在 Java 中出现的很早， Java 提供的实现原子性的内置锁机制，就是用这个关键字实现。<br><code>synchronized</code> 关键字可以修饰方法，也可以修饰一个代码块，实现一种互斥锁，这里就不做赘述。</p><p>下面讨论几个问题</p><h4 id="1-synchronized-关键字修饰-非静态方法，-锁定的是对象实例还是类？"><a href="#1-synchronized-关键字修饰-非静态方法，-锁定的是对象实例还是类？" class="headerlink" title="1. synchronized 关键字修饰 非静态方法， 锁定的是对象实例还是类？"></a>1. synchronized 关键字修饰 非静态方法， 锁定的是对象实例还是类？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncInnerReferenceLock1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"syncInnerReferenceLock1: [count] -- "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncInnerReferenceLock2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"syncInnerReferenceLock2: [count] -- "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SyncLockDemo syncLockDemo1 = <span class="keyword">new</span> SyncLockDemo();</span><br><span class="line"></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            syncLockDemo1.syncInnerReferenceLock1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            syncLockDemo1.syncInnerReferenceLock2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中有两个用 <code>synchronized</code>  关键字修饰的非静态方法， 在两个线程中运行这两个方法， 结果如下</p><pre><code>    syncInnerReferenceLock2: [count] -- 0    syncInnerReferenceLock2: [count] -- 1    syncInnerReferenceLock2: [count] -- 2    syncInnerReferenceLock2: [count] -- 3    syncInnerReferenceLock2: [count] -- 4    syncInnerReferenceLock1: [count] -- 0    syncInnerReferenceLock1: [count] -- 1    syncInnerReferenceLock1: [count] -- 2    syncInnerReferenceLock1: [count] -- 3    syncInnerReferenceLock1: [count] -- 4    Process finished with exit code 0或    syncInnerReferenceLock1: [count] -- 0    syncInnerReferenceLock1: [count] -- 1    syncInnerReferenceLock1: [count] -- 2    syncInnerReferenceLock1: [count] -- 3    syncInnerReferenceLock1: [count] -- 4    syncInnerReferenceLock2: [count] -- 0    syncInnerReferenceLock2: [count] -- 1    syncInnerReferenceLock2: [count] -- 2    syncInnerReferenceLock2: [count] -- 3    syncInnerReferenceLock2: [count] -- 4    Process finished with exit code 0</code></pre><p>从结果可以看出，两个线程是串行执行的，我们可以猜测： 修饰非静态方法的 <code>synchronized</code> 关键字锁定的是这个类的对象实例，下面我们来验证这个想法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncInnerReferenceLock1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">"syncInnerReferenceLock1: [count] -- "</span> + i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncInnerReferenceLock2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">"syncInnerReferenceLock2: [count] -- "</span> + i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> SyncLockDemo syncLockDemo1 = <span class="keyword">new</span> SyncLockDemo();</span><br><span class="line">  <span class="keyword">final</span> SyncLockDemo syncLockDemo2 = <span class="keyword">new</span> SyncLockDemo();</span><br><span class="line"></span><br><span class="line">  Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          syncLockDemo1.syncInnerReferenceLock1();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          syncLockDemo2.syncInnerReferenceLock2();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  t1.start();</span><br><span class="line">  t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们创建两个对象实例， 在两个线程中分别执行两个被 <code>synchronized</code> 关键字修饰的方法， 结果如下：</p><pre><code>syncInnerReferenceLock2: [count] -- 0syncInnerReferenceLock1: [count] -- 0syncInnerReferenceLock2: [count] -- 1syncInnerReferenceLock1: [count] -- 1syncInnerReferenceLock1: [count] -- 2syncInnerReferenceLock1: [count] -- 3syncInnerReferenceLock1: [count] -- 4syncInnerReferenceLock2: [count] -- 2syncInnerReferenceLock2: [count] -- 3syncInnerReferenceLock2: [count] -- 4Process finished with exit code 0</code></pre><p>这里可以看到，连个线程是并行执行的，没有丝毫互斥的现象，从而论证了上面的猜测！</p><h4 id="2-synchronized-关键字修饰-静态方法，-锁定的是对象实例还是类？"><a href="#2-synchronized-关键字修饰-静态方法，-锁定的是对象实例还是类？" class="headerlink" title="2.  synchronized 关键字修饰 静态方法， 锁定的是对象实例还是类？"></a>2.  <code>synchronized</code> 关键字修饰 <code>静态方法</code>， 锁定的是对象实例还是类？</h4><p>看了第一个问题，我们能不能说， <code>synchronized</code> 关键字修饰 <code>静态方法</code>， 锁定的是类呢？ 让我们看看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncLock1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"syncLock1: [count] -- "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncLock2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"syncLock2: [count] -- "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            syncLock1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            syncLock2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里把 <code>1</code> 中的两个方法修改成静态方法， 在两个线程中分别执行两个方法，结果如下：</p><pre><code>    syncLock1: [count] -- 0    syncLock1: [count] -- 1    syncLock1: [count] -- 2    syncLock1: [count] -- 3    syncLock1: [count] -- 4    syncLock2: [count] -- 0    syncLock2: [count] -- 1    syncLock2: [count] -- 2    syncLock2: [count] -- 3    syncLock2: [count] -- 4    Process finished with exit code 0或    syncLock2: [count] -- 0    syncLock2: [count] -- 1    syncLock2: [count] -- 2    syncLock2: [count] -- 3    syncLock2: [count] -- 4    syncLock1: [count] -- 0    syncLock1: [count] -- 1    syncLock1: [count] -- 2    syncLock1: [count] -- 3    syncLock1: [count] -- 4    Process finished with exit code 0</code></pre><p>可以从结果中看出，两个线程是串行执行，存在明显的互斥，<code>synchronized</code> 关键字修饰 <code>静态方法</code>， 锁定的确实是类</p><h4 id="3-synchronized-reference-和-synchronized-Clazz-class"><a href="#3-synchronized-reference-和-synchronized-Clazz-class" class="headerlink" title="3. synchronized(reference) {} 和 synchronized(Clazz.class) {}"></a>3. synchronized(reference) {} 和 synchronized(Clazz.class) {}</h4><p>synchorinizable 修饰类和对象的区别是什么呢？</p><p>在我看来， synchorinizable 修饰类和对象，可以抽象为 <code>类锁</code> 和 <code>对象锁</code></p><p>下面上代码</p><p>这是一个 <code>类锁</code> 的范例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">syncClazzLock</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SyncLockDemo.class) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"syncClazzLock: [count] -- "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是个 <code>对象锁</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncReferenceLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"syncReferenceLock: [count] -- "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用上面的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> SyncLockDemo syncLockDemo = <span class="keyword">new</span> SyncLockDemo();</span><br><span class="line"></span><br><span class="line">     Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             syncClazzLock();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">     Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             syncLockDemo.syncReferenceLock();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">     t1.start();</span><br><span class="line">     t3.start();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>程序运行结果</p><pre><code>syncReferenceLock: [count] -- 0syncClazzLock: [count] -- 0syncReferenceLock: [count] -- 1syncClazzLock: [count] -- 1syncReferenceLock: [count] -- 2syncClazzLock: [count] -- 2syncReferenceLock: [count] -- 3syncReferenceLock: [count] -- 4syncClazzLock: [count] -- 3syncClazzLock: [count] -- 4Process finished with exit code 0</code></pre><p>从结果可以看出， 这两个线程的运行顺序是并行的，并不互斥。 因为 <code>syncClazzLock</code> 中 <code>synchronized</code> 关键字修饰的是类， 这个  <code>类锁</code> 作用于类的范围， 作用于类的静态方法、类的class 对象、类的静态代码块；而 <code>syncReferenceLock</code> 方法中 <code>synchronized</code> 关键字修饰的是对象， 这个 <code>对象锁</code> 最用于对象的范围，作用的对象示例的方法或一个对象实例上</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JAVA 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring揭秘读书笔记 —— 如何干涉IOC容器</title>
      <link href="/2016/07/16/%E6%8A%80%E6%9C%AF/spring/2016-07-16-Spring%E6%8F%AD%E7%A7%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E5%B9%B2%E6%B6%89IOC%E5%AE%B9%E5%99%A8/"/>
      <url>/2016/07/16/%E6%8A%80%E6%9C%AF/spring/2016-07-16-Spring%E6%8F%AD%E7%A7%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E5%B9%B2%E6%B6%89IOC%E5%AE%B9%E5%99%A8/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Spring IOC 容器在加载 Bean 的时候，可以大致分为两个阶段</p><ol><li>容器启动阶段</li><li>Bean 实例化阶段</li></ol><h3 id="插手容器启动阶段"><a href="#插手容器启动阶段" class="headerlink" title="插手容器启动阶段"></a>插手容器启动阶段</h3><p>容器启动阶段简而言之就是将 通过注解或者在 xml 文件中配置信息，解析转化为 <code>BeanDefinition</code>， 再通过 <code>BeanDefinitionRegister</code> 注册到容器中<br>这个阶段主要是一些收集准备工作</p><p><code>Spring</code> 提供给我们插手这一阶段的方式是： 实现 <code>BeanFactoryPostProcessor</code></p>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 《Spring揭秘》 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring揭秘读书笔记 —— IOC 基本概念</title>
      <link href="/2016/07/15/%E6%8A%80%E6%9C%AF/spring/2016-07-15-Spring%E6%8F%AD%E7%A7%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94IOC%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2016/07/15/%E6%8A%80%E6%9C%AF/spring/2016-07-15-Spring%E6%8F%AD%E7%A7%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94IOC%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一直在使用Spring 这一开源项目， 但是在学习spring 的过程中一直没遇到让我心旷神怡的好书，看过 <code>《Spring技术内幕：深入解析Spring架构与设计原理（第2版）》</code>， 从源码角度讲解spring， 虽然也很不错， 但是略感枯燥。  另外就是开涛大神的 <code>跟我学Spring</code>(<a href="http://jinnianshilongnian.iteye.com/blog/1482071" target="_blank" rel="noopener">http://jinnianshilongnian.iteye.com/blog/1482071</a>) 和 <code>跟我学Spring MVC</code>(<a href="http://jinnianshilongnian.iteye.com/blog/1617451" target="_blank" rel="noopener">http://jinnianshilongnian.iteye.com/blog/1617451</a>), 这两个系列的博客，主要是从使用Spring 的角度出发，很适合初学者系列的学习Spring 的使用以及一些Spring 的原理。</p><h6 id="以上对两位大神的著作的评论仅属个人言论，欢迎大家指正"><a href="#以上对两位大神的著作的评论仅属个人言论，欢迎大家指正" class="headerlink" title="以上对两位大神的著作的评论仅属个人言论，欢迎大家指正"></a>以上对两位大神的著作的评论仅属个人言论，欢迎大家指正</h6><p>最近接触到一本比较 <code>古老</code> 的 Spring 学习书籍 ———— <code>《Spring揭秘》</code> , 这本书貌似现在已经停刊了，讲的 Spring 也是将的 <code>Spring 2.X</code> , 但是 Spring 的主要思想，在这本书中被作者用一种通俗易懂的语言表达的让人能一边看，一边笑着点头， 甚是舒畅。</p><hr><h2 id="IoC的基本概念读书笔记"><a href="#IoC的基本概念读书笔记" class="headerlink" title="IoC的基本概念读书笔记"></a>IoC的基本概念读书笔记</h2><h4 id="IoC-控制反转-————-我们的理念是：让别人为你服务"><a href="#IoC-控制反转-————-我们的理念是：让别人为你服务" class="headerlink" title="IoC [控制反转] ———— 我们的理念是：让别人为你服务"></a>IoC [控制反转] ———— 我们的理念是：让别人为你服务</h4><p>书中的比喻很形象<br><img src="/assets/picture/iocmetaphor.png" alt title="IoC形象比喻"></p><p>常见的 Ioc 实现方法</p><ol><li>构造方法注入</li><li>setter方法注入</li><li>接口注入</li></ol><p>三种方法中 <code>接口注入</code> 较为难理解<br>被注入的对象要想 Ioc Service Provider 为其注入依赖对象， 就要实现一个特定接口，特定的接口提供一个方法，用来为其注入一个依赖对象，这个特性接口就如同是上图比喻中的 “拿衣服的女朋友”</p><p>示例：<br><img src="/assets/picture/ioc.interfaceinsert.demo.png" alt><br>FxNewsProvider 希望能被注入依赖 IFXNewsListener, 使用接口注入时，实现 FXNewsListenerCallable 接口  FXNewListenerCallable 接口提供了 injectNewsListener 方法, 这个方法的参数的类型就是 IFXNewsListenr</p><p><code>接口注入</code>这种注入方式目前已经过时，不提倡使用</p><p><code>构造方法注入</code> 在对象构造完之后，就会立即进入就绪状态，可以马上使用。但是如果依赖的对象比较多，构造方法的参数列表会比较长，而且<code>构造方法注入</code>底层实现还是基于反射机制，而反射机制对于构造方法中相同类型的参数处理会有困难；而且构造方法不能被继承，不能设置默认值</p><p><code>setter方法注入</code> setter 方法参数单一，反射机制可以很好的支持，而且setter 方法能被继承，能够设置默认值</p>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 《Spring揭秘》 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring揭秘读书笔记 —— IOC BeanFactory</title>
      <link href="/2016/07/15/%E6%8A%80%E6%9C%AF/spring/2016-07-15-Spring%E6%8F%AD%E7%A7%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94IOC%E4%B9%8BBeanFactory/"/>
      <url>/2016/07/15/%E6%8A%80%E6%9C%AF/spring/2016-07-15-Spring%E6%8F%AD%E7%A7%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94IOC%E4%B9%8BBeanFactory/</url>
      <content type="html"><![CDATA[<h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>Spring 的Ioc 容器除了是 Ioc Service Provider 还提供了其他的功能， 这边笔记将介绍 Ioc 容器的 Ioc 相关支持以及衍生的高级特性</p><p>Spring 中提供两种IOC 容器， <code>BeanFactory</code> 和  <code>ApplicationContext</code></p><h5 id="BeanFactory-1"><a href="#BeanFactory-1" class="headerlink" title="BeanFactory:"></a><code>BeanFactory</code>:</h5><p>基本类型的ICO 容器， 提供完整的IOC支持。 默认采用延迟初始化策略(lazy-load) 只有客户端对象需要访问容器中某个收管理的对象的时候， 才对该受管理的对象进行初始化以及依赖注入的操作。</p><h5 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a><code>ApplicationContext</code></h5><p>留待下章讲解</p><p>先看看 <code>BeanFactory</code> 的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Used to dereference a FactoryBean instance and distinguish it from beans created by the FactoryBean.</span></span><br><span class="line"><span class="comment">   * 这个前缀用于区分FactoryBean， 当想从BeanFactory 中获取一个FactoryBean 对象的时候，会返回这个工厂类</span></span><br><span class="line"><span class="comment">   * For example, if the bean named  myJndiObject is a FactoryBean, getting  myJndiObject will return the factory, not the instance returned by the factory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment"> * (only applied when creating a new instance as opposed to retrieving an existing one)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">String[] getAliases(String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/picture/beanDefinition.png" alt title="BeanDefinition 类图"></p><p>讲到了 BeanFactory 不得不提 BeanDefinitionRegister</p><p><code>Spring IOC</code> 中的 <code>BeanDefinition</code> 封装了一个被管理的Bean 的所有信息， 再通过 <code>BeanDefinitionRegister</code> 将 Bean 注册到 IOC 容器中去</p><p>本章章节比较易懂， 这里主要讲讲没这么提及的FactoryBean。</p><h5 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean :"></a><code>FactoryBean</code> :</h5><p><code>FactoryBean</code> 从命名上看跟  <code>BeanFactory</code> 很容易混淆。 <code>FactoryBean</code> 是 Spring 提供的一种可以扩展容器对象实例化逻辑的接口， 这个命名主语是Bean，定语是Factory； 也就是说它是 Spring 管理的一个普通的Bean， 只是它相对于生产对象来说，它是一个工厂。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.liam.learn.ioc.factorybean.DateWithFactoryBean"</span> <span class="attr">id</span>=<span class="string">"dateWithFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dateTimeFormatter"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"dateTimeFormatter"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dateTimeFormatter"</span> <span class="attr">class</span>=<span class="string">"org.springframework.format.datetime.standard.DateTimeFormatterFactoryBean"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>获取FactoryBean 的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring-config.xml"</span>);</span><br><span class="line">    DateTimeFormatterFactoryBean dateTimeFormatter = (DateTimeFormatterFactoryBean) applicationContext.getBean(<span class="string">"&amp;dateTimeFormatter"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BeanFactory</code> 中的 <code>getObjectForBeanInstance</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Object beanInstance, String name, String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don't let calling code try to dereference the factory if the bean isn't a factory.</span></span><br><span class="line">   <span class="comment">// 如果 bean 的名称以'&amp;'开头 并且 bean的类型不属于 FactoryBean 将抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now we have the bean instance, which may be a normal bean or a FactoryBean.</span></span><br><span class="line"><span class="comment">// If it's a FactoryBean, we use it to create a bean instance, unless the</span></span><br><span class="line"><span class="comment">// caller actually wants a reference to the factory.</span></span><br><span class="line">   <span class="comment">// 如果当前 Bean 的引用类型不是 FactoryBean 或者 bean 的名称以 '&amp;' 开头直接返回这个引用</span></span><br><span class="line"><span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object object = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span>) &#123;  <span class="comment">// 从缓存中获取FactoryBean 的引用</span></span><br><span class="line">object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">// 如果缓存中没有这个FactoryBean 的引用； 将新建引用，存到缓存中，并返回</span></span><br><span class="line"><span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Return bean instance from factory.</span></span><br><span class="line">FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line"><span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> synthetic = (mbd != <span class="keyword">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 《Spring揭秘》 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Jackson 中的 Features</title>
      <link href="/2016/07/10/%E6%8A%80%E6%9C%AF/java/2016-07-10-jackson%E4%B8%AD%E7%9A%84Feature/"/>
      <url>/2016/07/10/%E6%8A%80%E6%9C%AF/java/2016-07-10-jackson%E4%B8%AD%E7%9A%84Feature/</url>
      <content type="html"><![CDATA[<h2 id="Jackson-中的各种-Features"><a href="#Jackson-中的各种-Features" class="headerlink" title="Jackson 中的各种 Features"></a>Jackson 中的各种 Features</h2><p>先来看看 jackson 中的各种feature<br><img src="/assets/picture/jacksonFeature.png" alt="图片" title="Feature 类图"></p><p>首先是 序列化时候的Feature ——</p><h3 id="SerializaitonFeature"><a href="#SerializaitonFeature" class="headerlink" title="SerializaitonFeature"></a>SerializaitonFeature</h3><hr><h4 id="WRAP-ROOT-VALUE-false-序列化的json是否显示根节点"><a href="#WRAP-ROOT-VALUE-false-序列化的json是否显示根节点" class="headerlink" title="WRAP_ROOT_VALUE(false) : 序列化的json是否显示根节点"></a><code>WRAP_ROOT_VALUE(false)</code> : 序列化的json是否显示根节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWrapRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       SimpleBean simpleBean = <span class="keyword">new</span> SimpleBean();</span><br><span class="line">       simpleBean.setCode(<span class="number">1</span>);</span><br><span class="line">       simpleBean.setName(<span class="string">"TEST_WRAP_ROOT_VALUE"</span>);</span><br><span class="line">       simpleBean.setDesc(Lists.newArrayList(<span class="string">"test1"</span>, <span class="string">"test2"</span>, <span class="string">"test3"</span>));</span><br><span class="line"></span><br><span class="line">       ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//        objectMapper.enable(SerializationFeature.WRAP_ROOT_VALUE);</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           String s = objectMapper.writeValueAsString(simpleBean);</span><br><span class="line">           System.out.println(s);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><pre><code>{&quot;name&quot;:&quot;TEST_WRAP_ROOT_VALUE&quot;,&quot;code&quot;:1,&quot;desc&quot;:[&quot;test1&quot;,&quot;test2&quot;,&quot;test3&quot;]}</code></pre><p>去掉注释的运行结果：</p><pre><code>{&quot;SimpleBean&quot;:{&quot;name&quot;:&quot;TEST_WRAP_ROOT_VALUE&quot;,&quot;code&quot;:1,&quot;desc&quot;:[&quot;test1&quot;,&quot;test2&quot;,&quot;test3&quot;]}}</code></pre><p>从结果可以看出 jackson 会把类名作为根节点展示</p><hr><h4 id="INDENT-OUTPUT-false-允许或禁止是否以缩进的方式展示json"><a href="#INDENT-OUTPUT-false-允许或禁止是否以缩进的方式展示json" class="headerlink" title="INDENT_OUTPUT(false): 允许或禁止是否以缩进的方式展示json"></a><code>INDENT_OUTPUT(false)</code>: 允许或禁止是否以缩进的方式展示json</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testIdentOutput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SimpleBean simpleBean = <span class="keyword">new</span> SimpleBean();</span><br><span class="line">    simpleBean.setCode(<span class="number">1</span>);</span><br><span class="line">    simpleBean.setName(<span class="string">"TEST_WRAP_ROOT_VALUE"</span>);</span><br><span class="line">    simpleBean.setDesc(Lists.newArrayList(<span class="string">"test1"</span>, <span class="string">"test2"</span>, <span class="string">"test3"</span>));</span><br><span class="line"></span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    objectMapper.enable(SerializationFeature.INDENT_OUTPUT);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String s = objectMapper.writeValueAsString(simpleBean);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果：</p><pre><code>{    &quot;name&quot; : &quot;TEST_WRAP_ROOT_VALUE&quot;,    &quot;code&quot; : 1,    &quot;desc&quot; : [ &quot;test1&quot;, &quot;test2&quot;, &quot;test3&quot; ]}</code></pre><hr><h4 id="FAIL-ON-EMPTY-BEANS-true-当类的一个属性外部无法访问-如：没有getter-setter-的私有属性-，且没有annotation-标明需要序列化时，如果FAIL-ON-EMPTY-BEANS-是true-将会跑出异常，如果是false-则不会跑出异常"><a href="#FAIL-ON-EMPTY-BEANS-true-当类的一个属性外部无法访问-如：没有getter-setter-的私有属性-，且没有annotation-标明需要序列化时，如果FAIL-ON-EMPTY-BEANS-是true-将会跑出异常，如果是false-则不会跑出异常" class="headerlink" title="FAIL_ON_EMPTY_BEANS(true): 当类的一个属性外部无法访问(如：没有getter setter 的私有属性)，且没有annotation 标明需要序列化时，如果FAIL_ON_EMPTY_BEANS 是true 将会跑出异常，如果是false 则不会跑出异常"></a><code>FAIL_ON_EMPTY_BEANS</code>(true): 当类的一个属性外部无法访问(如：没有getter setter 的私有属性)，且没有annotation 标明需要序列化时，如果FAIL_ON_EMPTY_BEANS 是true 将会跑出异常，如果是false 则不会跑出异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testFailOnEmptyField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TestBean simpleBean = <span class="keyword">new</span> TestBean();</span><br><span class="line"></span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//        objectMapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String s = objectMapper.writeValueAsString(simpleBean);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码运行结果</p><pre><code>com.fasterxml.jackson.databind.JsonMappingException: No serializer found for class com.liam.learning.Main$TestBean and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS)  at com.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:275)  at com.fasterxml.jackson.databind.SerializerProvider.mappingException(SerializerProvider.java:1109)  at com.fasterxml.jackson.databind.SerializerProvider.reportMappingProblem(SerializerProvider.java:1134)  at com.fasterxml.jackson.databind.ser.impl.UnknownSerializer.failForEmpty(UnknownSerializer.java:69)  at com.fasterxml.jackson.databind.ser.impl.UnknownSerializer.serialize(UnknownSerializer.java:32)  at com.fasterxml.jackson.databind.ser.DefaultSerializerProvider.serializeValue(DefaultSerializerProvider.java:292)  at com.fasterxml.jackson.databind.ObjectMapper._configAndWriteValue(ObjectMapper.java:3672)  at com.fasterxml.jackson.databind.ObjectMapper.writeValueAsString(ObjectMapper.java:3048)  at com.liam.learning.Main.testFailOnEmptyField(Main.java:56)  at com.liam.learning.Main.main(Main.java:15)  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)  at java.lang.reflect.Method.invoke(Method.java:606)  at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)</code></pre><p>取消注释的运行结果：</p><pre><code>{}</code></pre><hr><h4 id="FAIL-ON-SELF-REFERENCES-true"><a href="#FAIL-ON-SELF-REFERENCES-true" class="headerlink" title="FAIL_ON_SELF_REFERENCES(true)"></a>FAIL_ON_SELF_REFERENCES(true)</h4><p>如果POJO 中有一个直接自我引用，在序列化的时候会抛出 <code>com.fasterxml.jackson.databind.JsonMappingException</code></p><hr><h4 id="WRAP-EXCEPTIONS-true"><a href="#WRAP-EXCEPTIONS-true" class="headerlink" title="WRAP_EXCEPTIONS(true)"></a>WRAP_EXCEPTIONS(true)</h4><p>如果序列化过程中，如果抛出 Exception 将会被包装，添加额外的上下文信息</p><hr><h4 id="FAIL-ON-UNWRAPPED-TYPE-IDENTIFIERS-true"><a href="#FAIL-ON-UNWRAPPED-TYPE-IDENTIFIERS-true" class="headerlink" title="FAIL_ON_UNWRAPPED_TYPE_IDENTIFIERS(true),"></a>FAIL_ON_UNWRAPPED_TYPE_IDENTIFIERS(true),</h4><h4 id="CLOSE-CLOSEABLE-false"><a href="#CLOSE-CLOSEABLE-false" class="headerlink" title="CLOSE_CLOSEABLE(false),"></a>CLOSE_CLOSEABLE(false),</h4><h4 id="FLUSH-AFTER-WRITE-VALUE-true"><a href="#FLUSH-AFTER-WRITE-VALUE-true" class="headerlink" title="FLUSH_AFTER_WRITE_VALUE(true),"></a>FLUSH_AFTER_WRITE_VALUE(true),</h4><h4 id="WRITE-DATES-AS-TIMESTAMPS-true"><a href="#WRITE-DATES-AS-TIMESTAMPS-true" class="headerlink" title="WRITE_DATES_AS_TIMESTAMPS(true),"></a>WRITE_DATES_AS_TIMESTAMPS(true),</h4><h4 id="WRITE-DATE-KEYS-AS-TIMESTAMPS-false"><a href="#WRITE-DATE-KEYS-AS-TIMESTAMPS-false" class="headerlink" title="WRITE_DATE_KEYS_AS_TIMESTAMPS(false),"></a>WRITE_DATE_KEYS_AS_TIMESTAMPS(false),</h4><h4 id="WRITE-DATES-WITH-ZONE-ID-false"><a href="#WRITE-DATES-WITH-ZONE-ID-false" class="headerlink" title="WRITE_DATES_WITH_ZONE_ID(false),"></a>WRITE_DATES_WITH_ZONE_ID(false),</h4><h4 id="WRITE-DURATIONS-AS-TIMESTAMPS-true"><a href="#WRITE-DURATIONS-AS-TIMESTAMPS-true" class="headerlink" title="WRITE_DURATIONS_AS_TIMESTAMPS(true),"></a>WRITE_DURATIONS_AS_TIMESTAMPS(true),</h4><hr><h4 id="WRITE-CHAR-ARRAYS-AS-JSON-ARRAYS-false-序列化json-的时候对于-char-为true-则解析成数组形式；-为false-则解析成一个字符串-String"><a href="#WRITE-CHAR-ARRAYS-AS-JSON-ARRAYS-false-序列化json-的时候对于-char-为true-则解析成数组形式；-为false-则解析成一个字符串-String" class="headerlink" title="WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS(false): 序列化json 的时候对于 char[] 为true 则解析成数组形式； 为false 则解析成一个字符串(String)"></a>WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS(false): 序列化json 的时候对于 <code>char[]</code> 为true 则解析成数组形式； 为false 则解析成一个字符串(String)</h4><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWriteCharArraysAsJsonArrays</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       String t = <span class="string">"tester"</span>;</span><br><span class="line">       <span class="keyword">char</span>[] arr = t.toCharArray();</span><br><span class="line"></span><br><span class="line">       ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//        objectMapper.enable(SerializationFeature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS);</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           String s = objectMapper.writeValueAsString(arr);</span><br><span class="line">           System.out.println(s);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><pre><code>&quot;tester&quot;</code></pre><p>去掉注释后，运行结果如下</p><pre><code>[&quot;t&quot;,&quot;e&quot;,&quot;s&quot;,&quot;t&quot;,&quot;e&quot;,&quot;r&quot;]</code></pre><hr><h4 id="WRITE-ENUMS-USING-TO-STRING-false-序列化时，-enable-用枚举的-enum-toString-表示枚举值-disable-用枚举的-enum-name-表示枚举值"><a href="#WRITE-ENUMS-USING-TO-STRING-false-序列化时，-enable-用枚举的-enum-toString-表示枚举值-disable-用枚举的-enum-name-表示枚举值" class="headerlink" title="WRITE_ENUMS_USING_TO_STRING(false): 序列化时， enable: 用枚举的 enum.toString() 表示枚举值 disable: 用枚举的 enum.name() 表示枚举值"></a>WRITE_ENUMS_USING_TO_STRING(false): 序列化时， enable: 用枚举的 enum.toString() 表示枚举值 disable: 用枚举的 enum.name() 表示枚举值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWriteEnumsUsingString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//        objectMapper.enable(SerializationFeature.WRITE_ENUMS_USING_TO_STRING);</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String s = objectMapper.writeValueAsString(CHILD.BOY);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">enum</span> CHILD &#123;</span><br><span class="line">    BOY, GIRL;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"+"</span> + <span class="keyword">this</span>.name() + <span class="string">"+"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行结果：</p><pre><code>&quot;BOY&quot;</code></pre><p>去掉注释后的代码运行结果：</p><pre><code>&quot;+BOY+&quot;</code></pre><hr><h4 id="WRITE-ENUMS-USING-INDEX-false-序列化时，用枚举的-enum-index-表示枚举值"><a href="#WRITE-ENUMS-USING-INDEX-false-序列化时，用枚举的-enum-index-表示枚举值" class="headerlink" title="WRITE_ENUMS_USING_INDEX(false): 序列化时，用枚举的 enum.index() 表示枚举值"></a>WRITE_ENUMS_USING_INDEX(false): 序列化时，用枚举的 enum.index() 表示枚举值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWriteEnumsUsingIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//        objectMapper.enable(SerializationFeature.WRITE_ENUMS_USING_INDEX);</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String s = objectMapper.writeValueAsString(CHILD.BOY);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">enum</span> CHILD &#123;</span><br><span class="line">    BOY, GIRL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行结果：</p><pre><code>&quot;BOY&quot;</code></pre><p>取消注释后代码运行结果：</p><pre><code>0</code></pre><hr><h4 id="WRITE-NULL-MAP-VALUES-true-对于-Map-中的-null-值-是否序列化"><a href="#WRITE-NULL-MAP-VALUES-true-对于-Map-中的-null-值-是否序列化" class="headerlink" title="WRITE_NULL_MAP_VALUES(true): 对于 Map 中的 null 值 是否序列化"></a>WRITE_NULL_MAP_VALUES(true): 对于 Map 中的 null 值 是否序列化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWriteNullMapValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, Object&gt; extMap = Maps.newHashMap();</span><br><span class="line">    extMap.put(<span class="string">"test1"</span>, <span class="keyword">null</span>);</span><br><span class="line">    extMap.put(<span class="string">"test2"</span>, <span class="string">"not null"</span>);</span><br><span class="line"></span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//        objectMapper.disable(SerializationFeature.WRITE_NULL_MAP_VALUES);</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String s = objectMapper.writeValueAsString(extMap);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行结果：</p><pre><code>{&quot;test1&quot;:null,&quot;test2&quot;:&quot;not null&quot;}</code></pre><p>去除注释后的运行结果：</p><pre><code>{&quot;test2&quot;:&quot;not null&quot;}</code></pre><hr><h4 id="WRITE-EMPTY-JSON-ARRAYS-true-对于空的-Collection、-数组-为-true-则序列化，-为-false-则跳过，-默认为-true"><a href="#WRITE-EMPTY-JSON-ARRAYS-true-对于空的-Collection、-数组-为-true-则序列化，-为-false-则跳过，-默认为-true" class="headerlink" title="WRITE_EMPTY_JSON_ARRAYS(true): 对于空的 Collection、 数组 ; 为 true 则序列化， 为 false 则跳过， 默认为 true"></a>WRITE_EMPTY_JSON_ARRAYS(true): 对于空的 <code>Collection</code>、 <code>数组</code> ; 为 <code>true</code> 则序列化， 为 <code>false</code> 则跳过， 默认为 <code>true</code></h4><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWriteEmptyJsonArrays</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SimpleBean simpleBean = <span class="keyword">new</span> SimpleBean();</span><br><span class="line">    simpleBean.setCode(<span class="number">1</span>);</span><br><span class="line">    simpleBean.setName(<span class="string">"WRITE_EMPTY_JSON_ARRAYS"</span>);</span><br><span class="line">    simpleBean.setDesc(Collections.&lt;String&gt;emptyList());</span><br><span class="line"></span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//        objectMapper.disable(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS);</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String s = objectMapper.writeValueAsString(simpleBean);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><pre><code>{&quot;name&quot;:&quot;WRITE_EMPTY_JSON_ARRAYS&quot;,&quot;code&quot;:1,&quot;desc&quot;:[],&quot;ext&quot;:null}</code></pre><p>取消注释后，运行结果如下：</p><pre><code>{&quot;name&quot;:&quot;WRITE_EMPTY_JSON_ARRAYS&quot;,&quot;code&quot;:1,&quot;ext&quot;:null}</code></pre><hr><h4 id="WRITE-SINGLE-ELEM-ARRAYS-UNWRAPPED-false-序列化json时，对于只有单个元素的数组，不用中括号-‘-’-括起来"><a href="#WRITE-SINGLE-ELEM-ARRAYS-UNWRAPPED-false-序列化json时，对于只有单个元素的数组，不用中括号-‘-’-括起来" class="headerlink" title="WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED(false): 序列化json时，对于只有单个元素的数组，不用中括号(‘[]’)括起来"></a>WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED(false): 序列化json时，对于只有单个元素的数组，不用中括号(‘[]’)括起来</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWrietSingleElemArraysUnwrapped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SimpleBean simpleBean = <span class="keyword">new</span> SimpleBean();</span><br><span class="line">    simpleBean.setCode(<span class="number">1</span>);</span><br><span class="line">    simpleBean.setName(<span class="string">"TEST_WRAP_ROOT_VALUE"</span>);</span><br><span class="line">    simpleBean.setDesc(Lists.newArrayList(<span class="string">"test1"</span>));</span><br><span class="line"></span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//        objectMapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED);</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String s = objectMapper.writeValueAsString(simpleBean);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行结果：</p><pre><code>{&quot;name&quot;:&quot;TEST_WRAP_ROOT_VALUE&quot;,&quot;code&quot;:1,&quot;desc&quot;:[&quot;test1&quot;]}</code></pre><p>去掉注释之后的，运行结果</p><pre><code>{&quot;name&quot;:&quot;TEST_WRAP_ROOT_VALUE&quot;,&quot;code&quot;:1,&quot;desc&quot;:&quot;test1&quot;}</code></pre><p>效果一目了然！</p><hr><h4 id="WRITE-BIGDECIMAL-AS-PLAIN-false-deprecated"><a href="#WRITE-BIGDECIMAL-AS-PLAIN-false-deprecated" class="headerlink" title="WRITE_BIGDECIMAL_AS_PLAIN(false): @deprecated"></a>WRITE_BIGDECIMAL_AS_PLAIN(false): <code>@deprecated</code></h4><p><code>@see</code></p><p><code>com.fasterxml.jackson.core.JsonGenerator.Feature#WRITE_BIGDECIMAL_AS_PLAIN</code></p><hr><h4 id="WRITE-DATE-TIMESTAMPS-AS-NANOSECONDS-true-序列化json的时候把时间类型值序列化成纳秒的形式"><a href="#WRITE-DATE-TIMESTAMPS-AS-NANOSECONDS-true-序列化json的时候把时间类型值序列化成纳秒的形式" class="headerlink" title="WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS(true): 序列化json的时候把时间类型值序列化成纳秒的形式"></a>WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS(true): 序列化json的时候把时间类型值序列化成纳秒的形式</h4><pre><code>`注意` 只有最新版本(`jdk8` 中的 `Date/Time` )的时间类型支持本特性, `jdk8` 之前的 `java.util.Date`  和`joda-time` 都不支持！</code></pre><hr><h4 id="ORDER-MAP-ENTRIES-BY-KEYS-false-序列化-Map-的时候，-为-true-则按照-Map-的-key-进行排序，否则不排序"><a href="#ORDER-MAP-ENTRIES-BY-KEYS-false-序列化-Map-的时候，-为-true-则按照-Map-的-key-进行排序，否则不排序" class="headerlink" title="ORDER_MAP_ENTRIES_BY_KEYS(false): 序列化 Map 的时候， 为 true 则按照 Map 的 key 进行排序，否则不排序"></a>ORDER_MAP_ENTRIES_BY_KEYS(false): 序列化 <code>Map</code> 的时候， 为 <code>true</code> 则按照 <code>Map</code> 的 <code>key</code> 进行排序，否则不排序</h4><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testOrderMapEntriesByKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//        objectMapper.enable(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS);</span></span><br><span class="line">    Map&lt;String, String&gt; data = ImmutableMap.of(<span class="string">"1"</span>, <span class="string">"test1"</span>, <span class="string">"3"</span>, <span class="string">"test2"</span>, <span class="string">"2"</span>, <span class="string">"test3"</span>, <span class="string">"0"</span>, <span class="string">"test4"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String dateStr = objectMapper.writeValueAsString(data);</span><br><span class="line">        System.out.println(dateStr);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><pre><code>{&quot;1&quot;:&quot;test1&quot;,&quot;3&quot;:&quot;test2&quot;,&quot;2&quot;:&quot;test3&quot;,&quot;0&quot;:&quot;test4&quot;}</code></pre><p>取消注释的运行结果：</p><pre><code>{&quot;0&quot;:&quot;test4&quot;,&quot;1&quot;:&quot;test1&quot;,&quot;2&quot;:&quot;test3&quot;,&quot;3&quot;:&quot;test2&quot;}</code></pre><hr><h4 id="EAGER-SERIALIZER-FETCH-true-序列化是是否应当预先抓取必要的-JsonSerializer-，-绝大多数情况下不应该关闭此特性"><a href="#EAGER-SERIALIZER-FETCH-true-序列化是是否应当预先抓取必要的-JsonSerializer-，-绝大多数情况下不应该关闭此特性" class="headerlink" title="EAGER_SERIALIZER_FETCH(true): 序列化是是否应当预先抓取必要的 JsonSerializer ， 绝大多数情况下不应该关闭此特性"></a>EAGER_SERIALIZER_FETCH(true): 序列化是是否应当预先抓取必要的 <code>JsonSerializer</code> ， 绝大多数情况下不应该关闭此特性</h4><hr><h4 id="USE-EQUALITY-FOR-OBJECT-ID-false"><a href="#USE-EQUALITY-FOR-OBJECT-ID-false" class="headerlink" title="USE_EQUALITY_FOR_OBJECT_ID(false)"></a>USE_EQUALITY_FOR_OBJECT_ID(false)</h4><p>;</p><hr><p>接下来是 反序列化时候的Feature ——</p><h3 id="DeserializationFeature"><a href="#DeserializationFeature" class="headerlink" title="DeserializationFeature"></a>DeserializationFeature</h3><p>先来个最常用的：</p><h4 id="FAIL-ON-UNKNOWN-PROPERTIES-：-反序列化遇到未知的字段的时候是否失败，-默认是-true-会失败"><a href="#FAIL-ON-UNKNOWN-PROPERTIES-：-反序列化遇到未知的字段的时候是否失败，-默认是-true-会失败" class="headerlink" title="FAIL_ON_UNKNOWN_PROPERTIES ： 反序列化遇到未知的字段的时候是否失败， 默认是 true 会失败"></a><code>FAIL_ON_UNKNOWN_PROPERTIES</code> ： 反序列化遇到未知的字段的时候是否失败， 默认是 true 会失败</h4>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Json </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MarkDown 基本语法</title>
      <link href="/2016/07/06/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/markdown%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/2016/07/06/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/markdown%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>看到同事用 [git+github+markdown+jekyll] 搭建了一个<a href="http://littlepang.github.io/" target="_blank" rel="noopener"><em>个人博客</em></a>， 感觉很不错，果断 fork 他的分支，给自己来一个，下面简单记一些 [markdown]的语法，或者说占位符的用法</p><h1 id="MarkDown-基本语法"><a href="#MarkDown-基本语法" class="headerlink" title="MarkDown 基本语法"></a>MarkDown 基本语法</h1><hr><h3 id="标题："><a href="#标题：" class="headerlink" title="标题："></a>标题：</h3><h4 id="1-在文字标题之前加上-“-”-表示标题，-通过-“-”-的数量表示标题等，一个”-”表示一级，两个表示二级，最多六级"><a href="#1-在文字标题之前加上-“-”-表示标题，-通过-“-”-的数量表示标题等，一个”-”表示一级，两个表示二级，最多六级" class="headerlink" title="1. 在文字标题之前加上 “#” 表示标题， 通过 “#” 的数量表示标题等，一个”#”表示一级，两个表示二级，最多六级"></a>1. 在文字标题之前加上 “#” 表示标题， 通过 “#” 的数量表示标题等，一个”#”表示一级，两个表示二级，最多六级</h4><pre><code>例：# 用&quot;#&quot;表示标题   # 一级标题   ## 二级标题   ...   ####### 六级标题</code></pre><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>…</p><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr><h4 id="2-在文字下方加上两个以上的-“-“-表示标题-等同于二级标题-“-”"><a href="#2-在文字下方加上两个以上的-“-“-表示标题-等同于二级标题-“-”" class="headerlink" title="2. 在文字下方加上两个以上的 “-“ 表示标题, 等同于二级标题 (“##”)"></a>2. 在文字下方加上两个以上的 “-“ 表示标题, 等同于二级标题 (“##”)</h4><pre><code>  例： 在文字下方加上两个以上 &quot;-&quot; 表示标题----------------------------------</code></pre><h2 id="两个以上-‘-‘-表示二级标题"><a href="#两个以上-‘-‘-表示二级标题" class="headerlink" title="两个以上 ‘-‘ 表示二级标题"></a>两个以上 ‘-‘ 表示二级标题</h2><h4 id="3-在文字下方加上两个以上的-“-”-表示标题，等同于一级标题-“-”"><a href="#3-在文字下方加上两个以上的-“-”-表示标题，等同于一级标题-“-”" class="headerlink" title="3. 在文字下方加上两个以上的 “=” 表示标题，等同于一级标题 (“#”)"></a>3. 在文字下方加上两个以上的 “=” 表示标题，等同于一级标题 (“#”)</h4><pre><code>    例：在文字下方加上 &quot;=&quot; 表示标题(两个以上&quot;=&quot;)=======================</code></pre><h1 id="两个以上-‘-’-表示一级标题"><a href="#两个以上-‘-’-表示一级标题" class="headerlink" title="两个以上 ‘=’ 表示一级标题"></a>两个以上 ‘=’ 表示一级标题</h1><h3 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h3><h4 id="1-在-文字-前后-加上-两个-‘-’-或-‘-’"><a href="#1-在-文字-前后-加上-两个-‘-’-或-‘-’" class="headerlink" title="1. 在 文字 前后 加上 两个 ‘_’ 或 ‘*’"></a>1. 在 <strong>文字</strong> 前后 <strong>加上</strong> 两个 ‘_’ 或 ‘*’</h4><pre><code>例：__n__  或 **n**</code></pre><p><strong>粗体</strong></p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><h4 id="1-在文字前后加上一个-‘-’-或-‘-’"><a href="#1-在文字前后加上一个-‘-’-或-‘-’" class="headerlink" title="1. 在文字前后加上一个 ‘_’ 或 ‘*’"></a>1. 在文字前后加上一个 ‘_’ 或 ‘*’</h4><pre><code>例： _斜体_ 或 *斜体*</code></pre><p><em>斜体</em></p><h3 id="粗斜体"><a href="#粗斜体" class="headerlink" title="粗斜体"></a>粗斜体</h3><h4 id="1-在文字前后加上三个-‘-’-或-‘-’"><a href="#1-在文字前后加上三个-‘-’-或-‘-’" class="headerlink" title="1. 在文字前后加上三个 ‘_’ 或 ‘*’"></a>1. 在文字前后加上三个 ‘_’ 或 ‘*’</h4><pre><code>例： ___斜粗体___ 或 ***斜粗体***</code></pre><p><strong><em>粗斜体</em></strong>  <strong><em>粗斜体</em></strong></p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><h4 id="1-行首加上四个-Tab-或-四个空格-代码块自带滚动条效果"><a href="#1-行首加上四个-Tab-或-四个空格-代码块自带滚动条效果" class="headerlink" title="1. 行首加上四个 Tab 或 四个空格 (代码块自带滚动条效果)"></a>1. 行首加上四个 Tab 或 四个空格 (代码块自带滚动条效果)</h4><pre><code>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++--------------------------------------------------------------------------------------</code></pre><h3 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h3><h4 id="1-文字前面加上-“-gt-”"><a href="#1-文字前面加上-“-gt-”" class="headerlink" title="1. 文字前面加上 “&gt;”"></a>1. 文字前面加上 “&gt;”</h4><pre><code>例： &gt; 这个一个区块引用</code></pre><blockquote><p> 区块引用效果如下</p></blockquote><h4 id="2-区块引用可以嵌套使用"><a href="#2-区块引用可以嵌套使用" class="headerlink" title="2. 区块引用可以嵌套使用"></a>2. 区块引用可以嵌套使用</h4><pre><code>例：&gt; 这是外层&gt;&gt; 这是内层&gt;&gt;&gt; 这里更内层</code></pre><p>示例效果：</p><blockquote><p>这里外层</p><blockquote><p>这是内层</p><blockquote><p>这是更内层<br>这也是内层</p></blockquote></blockquote></blockquote><p>注意<br>如果 <code>&gt;</code> 和 <code>&gt;&gt;</code> 嵌套使用的话，从 <code>&gt;&gt;</code> 退到 <code>&gt;</code> 时，必须之间要加一个空格或者 <code>&gt;</code> 作为过渡，否则默认为下一行和上一行是同一级别的引用。如示例所示。<br>示例效果：</p><blockquote><p>这里外层</p><blockquote><p>这是内层</p><blockquote><p>这是更内层</p></blockquote><p>这也是内层</p></blockquote></blockquote><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><h4 id="1-三个以上”-“"><a href="#1-三个以上”-“" class="headerlink" title="1. 三个以上”-“"></a>1. 三个以上”-“</h4><pre><code>例： ----</code></pre><p>示例效果如下</p><hr><h4 id="2-三个以上”-”"><a href="#2-三个以上”-”" class="headerlink" title="2. 三个以上”*”"></a>2. 三个以上”*”</h4><pre><code>例： ***</code></pre><p>示例效果如下</p><hr><h3 id="代码块和语法高亮"><a href="#代码块和语法高亮" class="headerlink" title="代码块和语法高亮"></a>代码块和语法高亮</h3><h4 id="1-代码块使用方法如下："><a href="#1-代码块使用方法如下：" class="headerlink" title="1. 代码块使用方法如下："></a>1. 代码块使用方法如下：</h4><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo(<span class="string">"this a js code Block"</span>);</span><br></pre></td></tr></table></figure></code></pre><p>代码块效果如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tip = <span class="string">"this a js code block"</span>;</span><br><span class="line">echo(tip);</span><br></pre></td></tr></table></figure><h4 id="2-代码块语法高亮-在-“"><a href="#2-代码块语法高亮-在-“" class="headerlink" title="2. 代码块语法高亮 在 “"></a>2. 代码块语法高亮 在 “<figure class="highlight plain"><figcaption><span>后加上 language</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">```java</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    System.out.println(&quot;hello markdown&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h4><h4 id="3-高亮部分文字"><a href="#3-高亮部分文字" class="headerlink" title="3. 高亮部分文字"></a>3. 高亮部分文字</h4><pre><code>`高亮部分`</code></pre><p><code>高亮效果示例</code></p><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><h4 id="1-“-链接显示文字-url-“超链接标题”-“-url-和标题之间有空格"><a href="#1-“-链接显示文字-url-“超链接标题”-“-url-和标题之间有空格" class="headerlink" title="1. “[链接显示文字](url “超链接标题”)“ url 和标题之间有空格"></a>1. “[链接显示文字](url “超链接标题”)“ url 和标题之间有空格</h4><pre><code>例： [百度](http://www.baidu.com &quot;百度&quot;)</code></pre><p>示例效果:   <a href="http://www.baidu.com" title="百度" target="_blank" rel="noopener">百度</a></p><h4 id="2-指向本地文件的链接"><a href="#2-指向本地文件的链接" class="headerlink" title="2. 指向本地文件的链接"></a>2. 指向本地文件的链接</h4><pre><code>例: [icon.png](/assets/picture/headPicture.png)</code></pre><p><a href="/assets/picture/headPicture.png">icon.png</a></p><h3 id="图片引用"><a href="#图片引用" class="headerlink" title="图片引用"></a>图片引用</h3><h4 id="1-图片引用使用方法如下"><a href="#1-图片引用使用方法如下" class="headerlink" title="1.  图片引用使用方法如下"></a>1.  图片引用使用方法如下</h4><pre><code>例： ![图片](图片路径 &quot;图片标题&quot;)</code></pre><p><img src="/assets/picture/headPicture.png" alt="图片" title="图片标题"></p><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><h4 id="1-在需要转义的字符前面加上’-39"><a href="#1-在需要转义的字符前面加上’-39" class="headerlink" title="1. 在需要转义的字符前面加上’&#39;"></a>1. 在需要转义的字符前面加上’&#39;</h4><pre><code>例： 这是用来 _演示_ 的 **文本**    这是用来 \_演示\_ 的 \**文本\**</code></pre><p>这是用来 <em>演示</em> 的 <strong>文本</strong></p><p>这是用来 _演示_ 的 **文本**</p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><h4 id="1-在文字前后加上两个-‘-’"><a href="#1-在文字前后加上两个-‘-’" class="headerlink" title="1. 在文字前后加上两个 ‘~’"></a>1. 在文字前后加上两个 ‘~’</h4><pre><code>例： ~~删除线~~</code></pre><p>示例效果<br><del>删除线</del></p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><h4 id="1-使用-来分隔不同的单元格，使用-来分隔表头和其他行："><a href="#1-使用-来分隔不同的单元格，使用-来分隔表头和其他行：" class="headerlink" title="1. 使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行："></a>1. 使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行：</h4><pre><code>例：| name | age || ---- | --- || zero | 24  || liam | 23  |</code></pre><p>示例效果：</p><table><thead><tr><th>name</th><th>age</th></tr></thead><tbody><tr><td>zero</td><td>24</td></tr><tr><td>liam</td><td>23</td></tr></tbody></table><h4 id="2-表格对其-在表头和其他行的分隔符中加上-‘-’"><a href="#2-表格对其-在表头和其他行的分隔符中加上-‘-’" class="headerlink" title="2. 表格对其, 在表头和其他行的分隔符中加上 ‘:’"></a>2. 表格对其, 在表头和其他行的分隔符中加上 ‘:’</h4><h5 id="‘-—‘-左对齐"><a href="#‘-—‘-左对齐" class="headerlink" title="‘:—‘ 左对齐"></a>‘:—‘ 左对齐</h5><h5 id="‘-–-’-居中"><a href="#‘-–-’-居中" class="headerlink" title="‘:–:’ 居中"></a>‘:–:’ 居中</h5><h5 id="‘—-’-右对齐"><a href="#‘—-’-右对齐" class="headerlink" title="‘—:’ 右对齐"></a>‘—:’ 右对齐</h5><pre><code>例：| left | center | right || :--- | :----: | ----: ||左    |中     |右     |</code></pre><p>示例效果:</p><table><thead><tr><th align="left">left</th><th align="center">center</th><th align="right">right</th></tr></thead><tbody><tr><td align="left">左</td><td align="center">中</td><td align="right">右</td></tr></tbody></table><h3 id="上标和下标"><a href="#上标和下标" class="headerlink" title="上标和下标"></a>上标和下标</h3><h4 id="1-上标-使用html标签-lt-sup-gt"><a href="#1-上标-使用html标签-lt-sup-gt" class="headerlink" title="1. 上标 使用html标签 &lt;sup&gt;"></a>1. 上标 使用html标签 <code>&lt;sup&gt;</code></h4><pre><code>例： 来个上标 &lt;sup&gt;[1]&lt;/sup&gt;</code></pre><p>示例效果:</p><p>来个上标<sup>[1]</sup></p><h4 id="2-下标-使用html-标签-lt-sub-gt"><a href="#2-下标-使用html-标签-lt-sub-gt" class="headerlink" title="2. 下标  使用html 标签 &lt;sub&gt;"></a>2. 下标  使用html 标签 <code>&lt;sub&gt;</code></h4><pre><code>例: 来个下标 &lt;sub&gt;[2]&lt;/sub&gt;</code></pre><p>示例效果:</p><p>来个下标<sub>[2]</sub></p>]]></content>
      
      <categories>
          
          <category> GitHub Pages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
