<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo-next-github-page</title>
    <url>/2018/07/29/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/hexo-next-github-page/</url>
    <content><![CDATA[<h1 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 <code>Hexo</code></h1><p><em>安装 <code>Hexo</code> 的前提你已经安装以下安装程序</em></p>
<pre><code>    1. Node.js
    2. Git</code></pre>
<h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 <code>Node.js</code></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure>

<p>或者从 [官网](<a href="https://nodejs.org/en/">https://nodejs.org/en/</a> 官网) 下载安装包，傻瓜式安装</p>
<h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 <code>Git</code></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure>

<p>或者从 [官网](<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a> 官网) 下载安装包，傻瓜式安装</p>
<h2 id="安装-Hexo-1"><a href="#安装-Hexo-1" class="headerlink" title="安装 Hexo"></a>安装 <code>Hexo</code></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>查看安装版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ hexo -v</span><br><span class="line">hexo-cli: 1.1.0</span><br><span class="line">os: Darwin 16.3.0 darwin x64</span><br><span class="line">http_parser: 2.8.0</span><br><span class="line">node: 10.7.0</span><br><span class="line">v8: 6.7.288.49-node.15</span><br><span class="line">uv: 1.22.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">ares: 1.14.0</span><br><span class="line">modules: 64</span><br><span class="line">nghttp2: 1.32.0</span><br><span class="line">napi: 3</span><br><span class="line">openssl: 1.1.0h</span><br><span class="line">icu: 62.1</span><br><span class="line">unicode: 11.0</span><br><span class="line">cldr: 33.1</span><br><span class="line">tz: 2018e</span><br></pre></td></tr></table></figure>


<h1 id="Hexo-使用简介"><a href="#Hexo-使用简介" class="headerlink" title="Hexo 使用简介"></a><code>Hexo</code> 使用简介</h1><h2 id="初始化-Hexo-文件夹"><a href="#初始化-Hexo-文件夹" class="headerlink" title="初始化 Hexo 文件夹"></a>初始化 <code>Hexo</code> 文件夹</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /path/to/my/blog/source/code  ## 传建一个保存博客源代码的目录</span><br><span class="line">hexo init                           ## 初始化一个 Hexo 文件夹</span><br></pre></td></tr></table></figure>

<p>然后我们来看看初始化后的 hexo 文件夹</p>
<pre><code>    .
    ├── _config.yml                ## 配置文件
    ├── node_modules               ## npm 依赖文件夹            
    ├── package-lock.json          ## 根据 package.json 文件生成的版本依赖锁定文件，指定了依赖的确定版本
    ├── package.json               ## 声明 hexo 的所有依赖机器版本，详见 https://docs.npmjs.com/getting-started/using-a-package.json
    ├── scaffolds                  ## 存放模板的文件夹，hexo new &#39;file&#39; 指令创建新文档的时候会使用 scaffolds 中的模板
    ├── source                     ## hexo 源文件
    └── themes                     ## hexo 使用的主题文件夹存放位置</code></pre>
<h2 id="创建一个新文档"><a href="#创建一个新文档" class="headerlink" title="创建一个新文档"></a>创建一个新文档</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new &#x27;newfile&#x27;</span><br></pre></td></tr></table></figure>

<pre><code>    ➜ ... hexo new &#39;new file&#39;
    INFO  Created: ~/.../source/_posts/new-file.md</code></pre>
<p>我们可以看到在 source 文件夹下面新建了一个新的 <code>markdown</code> 文件</p>
<h2 id="生成-Hexo-静态文件"><a href="#生成-Hexo-静态文件" class="headerlink" title="生成 Hexo 静态文件"></a>生成 <code>Hexo</code> 静态文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo generate ## 可以使用简写指令 [hexo g]</span><br></pre></td></tr></table></figure>

<p>下面我们可以看到 <code>Hexo</code> 文件夹下多了一个 <code>public</code> 文件夹</p>
<pre><code>    .
    ├── _config.yml
    ├── db.json
    ├── node_modules
    ├── package-lock.json
    ├── package.json
    ├── public                ## 存放生成的静态文件，包含 js、css、html、图片
    ├── scaffolds
    ├── source
    └── themes</code></pre>
<h2 id="启动-Hexo-服务"><a href="#启动-Hexo-服务" class="headerlink" title="启动 Hexo 服务"></a>启动 <code>Hexo</code> 服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server    <span class="comment">## 简写指令 hexo s</span></span><br></pre></td></tr></table></figure>

<p>现在我们可以通过 <code>http://localhost:4000/</code> 来访问我们搭建的网站</p>
<h2 id="一键部署到-GitHub"><a href="#一键部署到-GitHub" class="headerlink" title="一键部署到 GitHub"></a>一键部署到 GitHub</h2><h3 id="修改-config-yml-文件"><a href="#修改-config-yml-文件" class="headerlink" title="修改 _config.yml 文件"></a>修改 <code>_config.yml</code> 文件</h3><pre><code>    deploy:
      type: git
      repo: &lt;repository url&gt;
      branch: [branch]
      message: [message]</code></pre>
<h3 id="安装-hexo-deployer-git"><a href="#安装-hexo-deployer-git" class="headerlink" title="安装 hexo-deployer-git"></a>安装 <code>hexo-deployer-git</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<h4 id="安装-hexo-deployer-git-遇到的问题"><a href="#安装-hexo-deployer-git-遇到的问题" class="headerlink" title="安装 hexo-deployer-git 遇到的问题"></a>安装 <code>hexo-deployer-git</code> 遇到的问题</h4><pre><code>    &gt; npm install hexo-deployer-git --save
    npm WARN deprecated swig@1.4.2: This package is no longer maintained
    + hexo-deployer-git@0.3.1
    added 31 packages from 36 contributors and audited 2296 packages in 10.148s
    found 1 low severity vulnerability
      run `npm audit fix` to fix them, or `npm audit` for details</code></pre>
<p>让我们执行 <code>npm audit</code> 指令来查看具体问题</p>
<p>➜  hexo.test.blog npm audit</p>
<pre><code>                           === npm audit security report ===

    ┌──────────────────────────────────────────────────────────────────────────────┐
    │                                Manual Review                                 │
    │            Some vulnerabilities require your attention to resolve            │
    │                                                                              │
    │         Visit https://go.npm.me/audit-guide for additional guidance          │
    └──────────────────────────────────────────────────────────────────────────────┘
    ┌───────────────┬──────────────────────────────────────────────────────────────┐
    │ Low           │ Regular Expression Denial of Service                         │
    ├───────────────┼──────────────────────────────────────────────────────────────┤
    │ Package       │ uglify-js                                                    │
    ├───────────────┼──────────────────────────────────────────────────────────────┤
    │ Patched in    │ &gt;=2.6.0                                                      │
    ├───────────────┼──────────────────────────────────────────────────────────────┤
    │ Dependency of │ hexo-deployer-git                                            │
    ├───────────────┼──────────────────────────────────────────────────────────────┤
    │ Path          │ hexo-deployer-git &gt; swig &gt; uglify-js                         │
    ├───────────────┼──────────────────────────────────────────────────────────────┤
    │ More info     │ https://nodesecurity.io/advisories/48                        │
    └───────────────┴──────────────────────────────────────────────────────────────┘
    found 1 low severity vulnerability in 2296 scanned packages
      1 vulnerability requires manual review. See the full report for details.</code></pre>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>添加淘宝 npm 镜像源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p>然后我们可以继续安装 <code>hexo-deployer-git</code> 了</p>
<h3 id="部署网站"><a href="#部署网站" class="headerlink" title="部署网站"></a>部署网站</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo deploy    ## 简写指令 hexo d</span><br></pre></td></tr></table></figure>

<p>部署指令将生成 <code>.deploy_git</code> 文件加，我们需要在 <code>.deploy_git</code> 文件中指定远程 git 链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin giturl</span><br></pre></td></tr></table></figure>

<h2 id="清除缓存和已创建的静态文件"><a href="#清除缓存和已创建的静态文件" class="headerlink" title="清除缓存和已创建的静态文件"></a>清除缓存和已创建的静态文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<h2 id="生成并部署-Hexo-网站"><a href="#生成并部署-Hexo-网站" class="headerlink" title="生成并部署 Hexo 网站"></a>生成并部署 <code>Hexo</code> 网站</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d -g</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

<p>这两个指令是等价的，都是先构建本地静态文件，再部署网站</p>
<h1 id="使用-NexT-主题"><a href="#使用-NexT-主题" class="headerlink" title="使用 NexT 主题"></a>使用 <code>NexT</code> 主题</h1><h2 id="下载-NexT-主题"><a href="#下载-NexT-主题" class="headerlink" title="下载 NexT 主题"></a>下载 <code>NexT</code> 主题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd your-hexo-site</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>

<h2 id="修改站点配置文件"><a href="#修改站点配置文件" class="headerlink" title="修改站点配置文件"></a>修改站点配置文件</h2><p>修改 <code>_config.yml</code> 文件中的 <code>theme</code> 配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span>  <span class="comment"># next 是 themes 文件下主题文件夹的名称，冒号后面必须有空格，这是 yaml 语法</span></span><br></pre></td></tr></table></figure>

<p>现在你可以执行以下指令去构建静态文件并且部署网站了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>然后你可以访问 <code>http://localhost:4000/</code> 去访问你的博客了</p>
<p><img src="/assets/picture/next-demo.png" title="NexT 主题 Demo 图片"></p>
<h2 id="配置-NexT-主题"><a href="#配置-NexT-主题" class="headerlink" title="配置 NexT 主题"></a>配置 <code>NexT</code> 主题</h2><h3 id="修改菜单栏"><a href="#修改菜单栏" class="headerlink" title="修改菜单栏"></a>修改菜单栏</h3><p>修改</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span>                                                          <span class="string">|</span>  <span class="attr">menu:</span>                                                      </span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span>                                              <span class="string">|</span>    <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span>                        <span class="comment"># 主页，默认配置打开</span></span><br><span class="line">  <span class="comment">#about: /about/ || user                                      |    #about: /about/ || user                # 关于自己，可以配置</span></span><br><span class="line">  <span class="comment">#tags: /tags/ || tags                                        |    tags: /tags/ || tags                   # 标签页，默认配置关闭，需要你打开注释</span></span><br><span class="line">  <span class="comment">#categories: /categories/ || th                              |    categories: /categories/ || th         # 分类页，默认配置关闭，需要你打开注释</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span>                              <span class="string">|</span>    <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span>        <span class="comment"># 归档页，默认配置打开</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar                            |    #schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap                            |    #sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat                                                                          # 公益404页，默认配置关闭，需要你打开注释</span></span><br></pre></td></tr></table></figure>

<h4 id="配置标签页"><a href="#配置标签页" class="headerlink" title="配置标签页"></a>配置标签页</h4><ol>
<li>创建标签页</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page <span class="string">&quot;tags&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>修改 themes/next/_config.yml 文件<br>去除 <code>menu.tags</code> 前的 <code>#</code></p>
</li>
<li><p>修改标签页标题<br>修改 source/tags/index.md 文件中的 title，写一个你喜欢的标题</p>
</li>
</ol>
<h4 id="配置分类页"><a href="#配置分类页" class="headerlink" title="配置分类页"></a>配置分类页</h4><ol>
<li>创建标签页</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page <span class="string">&quot;categories&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>修改 themes/next/_config.yml 文件<br>去除 <code>menu.categories</code> 前的 <code>#</code></p>
</li>
<li><p>修改标签页标题<br>修改 source/categories/index.md 文件中的 title，写一个你喜欢的标题</p>
</li>
</ol>
<h3 id="选择-scheme"><a href="#选择-scheme" class="headerlink" title="选择 scheme"></a>选择 <code>scheme</code></h3><p><code>themes/next/_config.yml</code> 文件中默认主题是 <code>Muse</code>，我选择  <code>Mist</code></p>
<pre><code>    # Schemes
    scheme: Muse          # 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白
    #scheme: Mist         # Muse 的紧凑版本，整洁有序的单栏外观
    #scheme: Pisces       # 双栏 Scheme，小家碧玉似的清新
    #scheme: Gemini</code></pre>
<h3 id="自定义样式"><a href="#自定义样式" class="headerlink" title="自定义样式"></a>自定义样式</h3><h4 id="修改页面宽度"><a href="#修改页面宽度" class="headerlink" title="修改页面宽度"></a>修改页面宽度</h4><p>编辑主题的 source/css/_variables/custom.styl 文件，新增变量：</p>
<pre><code>      // 当屏幕宽度 &lt; 1600px, 修改成你期望的宽度
      $content-desktop = 900px

      // 当视窗超过 1600px 后的宽度
      $content-desktop-large = 1300px</code></pre>
<h4 id="生成文章摘要"><a href="#生成文章摘要" class="headerlink" title="生成文章摘要"></a>生成文章摘要</h4><ol>
<li>在文章中使用 <code>&lt;!-- more --&gt;</code> 手动进行截断，在 <code>&lt;!-- more --&gt;</code> 上方撰写摘要，Hexo 提供的方式 <em>【推荐】</em></li>
<li>在文章的 <code>front-matter</code> 中添加 <code>description</code>，并提供文章摘录，我选择这种</li>
</ol>
<h4 id="修改作者名称、描述、语言、时区"><a href="#修改作者名称、描述、语言、时区" class="headerlink" title="修改作者名称、描述、语言、时区"></a>修改作者名称、描述、语言、时区</h4><p>修改 <code>_config.yml</code> 文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site                                                         |  # Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Ice</span> <span class="string">summer</span> <span class="string">bug&#x27;s</span> <span class="string">notes</span>                                  <span class="string">|</span>  <span class="attr">title:</span> <span class="string">Hexo</span></span><br><span class="line"><span class="attr">subtitle:</span>                                                      <span class="string">|</span>  <span class="attr">subtitle:</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">About</span> <span class="string">technology</span> <span class="string">and</span> <span class="string">about</span> <span class="string">life.</span>                  <span class="string">|</span>  <span class="attr">description:</span></span><br><span class="line"><span class="attr">keywords:</span>                                                      <span class="string">|</span>  <span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Liam</span> <span class="string">Chen</span>                                              <span class="string">|</span>  <span class="attr">author:</span> <span class="string">John</span> <span class="string">Doe</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span>                                              <span class="string">|</span>  <span class="attr">language:</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure>

<h4 id="修改作者头像"><a href="#修改作者头像" class="headerlink" title="修改作者头像"></a>修改作者头像</h4><p>修改 <code>themes/next/_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">avatar:</span> <span class="string">/images/headPicture.png</span></span><br></pre></td></tr></table></figure>

<h1 id="使用-GitHub-Pages"><a href="#使用-GitHub-Pages" class="headerlink" title="使用 GitHub Pages"></a>使用 <code>GitHub Pages</code></h1><p><code>GitHub Pages</code> 使用教程有很多，这里不做赘述，主要是将 <code>.deploy_git</code> 文件夹托管到 <code>GitHub</code> 上，并设置成 <code>GitHub Pages</code></p>
<p><code>_config.yml</code> 文件中的 <code>deploy.repo</code> 设置成 github url</p>
<p>我们还可以再建一个 github repository 来管理 Hexo 文件夹</p>
]]></content>
      <categories>
        <category>GitHub Pages</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown 基本语法</title>
    <url>/2016/07/06/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/markdown%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>看到同事用 [git+github+markdown+jekyll] 搭建了一个<a href="http://littlepang.github.io/"><em>个人博客</em></a>， 感觉很不错，果断 fork 他的分支，给自己来一个，下面简单记一些 [markdown]的语法，或者说占位符的用法</p>
<h1 id="MarkDown-基本语法"><a href="#MarkDown-基本语法" class="headerlink" title="MarkDown 基本语法"></a>MarkDown 基本语法</h1><hr>
<h3 id="标题："><a href="#标题：" class="headerlink" title="标题："></a>标题：</h3><h4 id="1-在文字标题之前加上-“-”-表示标题，-通过-“-”-的数量表示标题等，一个”-”表示一级，两个表示二级，最多六级"><a href="#1-在文字标题之前加上-“-”-表示标题，-通过-“-”-的数量表示标题等，一个”-”表示一级，两个表示二级，最多六级" class="headerlink" title="1. 在文字标题之前加上 “#” 表示标题， 通过 “#” 的数量表示标题等，一个”#”表示一级，两个表示二级，最多六级"></a>1. 在文字标题之前加上 “#” 表示标题， 通过 “#” 的数量表示标题等，一个”#”表示一级，两个表示二级，最多六级</h4><pre><code>  例：# 用&quot;#&quot;表示标题
     # 一级标题
     ## 二级标题
     ...
     ####### 六级标题</code></pre>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>…</p>
<h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr>
<h4 id="2-在文字下方加上两个以上的-“-“-表示标题-等同于二级标题-“-”"><a href="#2-在文字下方加上两个以上的-“-“-表示标题-等同于二级标题-“-”" class="headerlink" title="2. 在文字下方加上两个以上的 “-“ 表示标题, 等同于二级标题 (“##”)"></a>2. 在文字下方加上两个以上的 “-“ 表示标题, 等同于二级标题 (“##”)</h4><pre><code>  例： 在文字下方加上两个以上 &quot;-&quot; 表示标题
----------------------------------</code></pre>
<h2 id="两个以上-‘-‘-表示二级标题"><a href="#两个以上-‘-‘-表示二级标题" class="headerlink" title="两个以上 ‘-‘ 表示二级标题"></a>两个以上 ‘-‘ 表示二级标题</h2><h4 id="3-在文字下方加上两个以上的-“-”-表示标题，等同于一级标题-“-”"><a href="#3-在文字下方加上两个以上的-“-”-表示标题，等同于一级标题-“-”" class="headerlink" title="3. 在文字下方加上两个以上的 “=” 表示标题，等同于一级标题 (“#”)"></a>3. 在文字下方加上两个以上的 “=” 表示标题，等同于一级标题 (“#”)</h4><pre><code>    例：在文字下方加上 &quot;=&quot; 表示标题(两个以上&quot;=&quot;)
=======================</code></pre>
<h1 id="两个以上-‘-’-表示一级标题"><a href="#两个以上-‘-’-表示一级标题" class="headerlink" title="两个以上 ‘=’ 表示一级标题"></a>两个以上 ‘=’ 表示一级标题</h1><h3 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h3><h4 id="1-在-文字-前后-加上-两个-‘-’-或-‘-’"><a href="#1-在-文字-前后-加上-两个-‘-’-或-‘-’" class="headerlink" title="1. 在 文字 前后 加上 两个 ‘_’ 或 ‘*’"></a>1. 在 <strong>文字</strong> 前后 <strong>加上</strong> 两个 ‘_’ 或 ‘*’</h4><pre><code>  例：__n__  或 **n**</code></pre>
<p><strong>粗体</strong></p>
<h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><h4 id="1-在文字前后加上一个-‘-’-或-‘-’"><a href="#1-在文字前后加上一个-‘-’-或-‘-’" class="headerlink" title="1. 在文字前后加上一个 ‘_’ 或 ‘*’"></a>1. 在文字前后加上一个 ‘_’ 或 ‘*’</h4><pre><code>例： _斜体_ 或 *斜体*</code></pre>
<p><em>斜体</em></p>
<h3 id="粗斜体"><a href="#粗斜体" class="headerlink" title="粗斜体"></a>粗斜体</h3><h4 id="1-在文字前后加上三个-‘-’-或-‘-’"><a href="#1-在文字前后加上三个-‘-’-或-‘-’" class="headerlink" title="1. 在文字前后加上三个 ‘_’ 或 ‘*’"></a>1. 在文字前后加上三个 ‘_’ 或 ‘*’</h4><pre><code>例： ___斜粗体___ 或 ***斜粗体***</code></pre>
<p><strong><em>粗斜体</em></strong>  <strong><em>粗斜体</em></strong></p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><h4 id="1-行首加上四个-Tab-或-四个空格-代码块自带滚动条效果"><a href="#1-行首加上四个-Tab-或-四个空格-代码块自带滚动条效果" class="headerlink" title="1. 行首加上四个 Tab 或 四个空格 (代码块自带滚动条效果)"></a>1. 行首加上四个 Tab 或 四个空格 (代码块自带滚动条效果)</h4><pre><code>  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  -------------------------------------------------------------
  ------------------
  -------</code></pre>
<h3 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h3><h4 id="1-文字前面加上-“-gt-”"><a href="#1-文字前面加上-“-gt-”" class="headerlink" title="1. 文字前面加上 “&gt;”"></a>1. 文字前面加上 “&gt;”</h4><pre><code>  例： &gt; 这个一个区块引用</code></pre>
<blockquote>
<p> 区块引用效果如下</p>
</blockquote>
<h4 id="2-区块引用可以嵌套使用"><a href="#2-区块引用可以嵌套使用" class="headerlink" title="2. 区块引用可以嵌套使用"></a>2. 区块引用可以嵌套使用</h4><pre><code>  例：
  &gt; 这是外层
  &gt;&gt; 这是内层
  &gt;&gt;&gt; 这里更内层</code></pre>
<p>示例效果：</p>
<blockquote>
<p>这里外层</p>
<blockquote>
<p>这是内层</p>
<blockquote>
<p>这是更内层<br>这也是内层</p>
</blockquote>
</blockquote>
</blockquote>
<p>注意<br>如果 <code>&gt;</code> 和 <code>&gt;&gt;</code> 嵌套使用的话，从 <code>&gt;&gt;</code> 退到 <code>&gt;</code> 时，必须之间要加一个空格或者 <code>&gt;</code> 作为过渡，否则默认为下一行和上一行是同一级别的引用。如示例所示。<br>示例效果：</p>
<blockquote>
<p>这里外层</p>
<blockquote>
<p>这是内层</p>
<blockquote>
<p>这是更内层</p>
</blockquote>
<p>这也是内层</p>
</blockquote>
</blockquote>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><h4 id="1-三个以上”-“"><a href="#1-三个以上”-“" class="headerlink" title="1. 三个以上”-“"></a>1. 三个以上”-“</h4><pre><code>例： ----</code></pre>
<p>示例效果如下</p>
<hr>
<h4 id="2-三个以上”-”"><a href="#2-三个以上”-”" class="headerlink" title="2. 三个以上”*”"></a>2. 三个以上”*”</h4><pre><code>    例： ***</code></pre>
<p>示例效果如下</p>
<hr>
<h3 id="代码块和语法高亮"><a href="#代码块和语法高亮" class="headerlink" title="代码块和语法高亮"></a>代码块和语法高亮</h3><h4 id="1-代码块使用方法如下："><a href="#1-代码块使用方法如下：" class="headerlink" title="1. 代码块使用方法如下："></a>1. 代码块使用方法如下：</h4><pre><code>&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;echo(&lt;span class=&quot;string&quot;&gt;&amp;quot;this a js code Block&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;</code></pre>
<p>代码块效果如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tip = <span class="string">&quot;this a js code block&quot;</span>;</span><br><span class="line">echo(tip);</span><br></pre></td></tr></table></figure>
<h4 id="2-代码块语法高亮-在-“-”-后加上-language"><a href="#2-代码块语法高亮-在-“-”-后加上-language" class="headerlink" title="2. 代码块语法高亮 在 “```” 后加上 language"></a>2. 代码块语法高亮 在 “```” 后加上 language</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello markdown&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-高亮部分文字"><a href="#3-高亮部分文字" class="headerlink" title="3. 高亮部分文字"></a>3. 高亮部分文字</h4><pre><code>`高亮部分`</code></pre>
<p><code>高亮效果示例</code></p>
<h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><h4 id="1-“-链接显示文字-url-“超链接标题”-“-url-和标题之间有空格"><a href="#1-“-链接显示文字-url-“超链接标题”-“-url-和标题之间有空格" class="headerlink" title="1. “[链接显示文字](url “超链接标题”)“ url 和标题之间有空格"></a>1. “[链接显示文字](url “超链接标题”)“ url 和标题之间有空格</h4><pre><code>例： [百度](http://www.baidu.com &quot;百度&quot;)</code></pre>
<p>示例效果:   <a href="http://www.baidu.com/" title="百度">百度</a></p>
<h4 id="2-指向本地文件的链接"><a href="#2-指向本地文件的链接" class="headerlink" title="2. 指向本地文件的链接"></a>2. 指向本地文件的链接</h4><pre><code>例: [icon.png](/assets/picture/headPicture.png)</code></pre>
<p><a href="/assets/picture/headPicture.png">icon.png</a></p>
<h3 id="图片引用"><a href="#图片引用" class="headerlink" title="图片引用"></a>图片引用</h3><h4 id="1-图片引用使用方法如下"><a href="#1-图片引用使用方法如下" class="headerlink" title="1.  图片引用使用方法如下"></a>1.  图片引用使用方法如下</h4><pre><code>例： ![图片](图片路径 &quot;图片标题&quot;)</code></pre>
<p><img src="/assets/picture/headPicture.png" alt="图片" title="图片标题"></p>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><h4 id="1-在需要转义的字符前面加上’-39"><a href="#1-在需要转义的字符前面加上’-39" class="headerlink" title="1. 在需要转义的字符前面加上’&#39;"></a>1. 在需要转义的字符前面加上’&#39;</h4><pre><code>例： 这是用来 _演示_ 的 **文本**

    这是用来 \_演示\_ 的 \**文本\**</code></pre>
<p>这是用来 <em>演示</em> 的 <strong>文本</strong></p>
<p>这是用来 _演示_ 的 **文本**</p>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><h4 id="1-在文字前后加上两个-‘-’"><a href="#1-在文字前后加上两个-‘-’" class="headerlink" title="1. 在文字前后加上两个 ‘~’"></a>1. 在文字前后加上两个 ‘~’</h4><pre><code>例： ~~删除线~~</code></pre>
<p>示例效果<br><del>删除线</del></p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><h4 id="1-使用-来分隔不同的单元格，使用-来分隔表头和其他行："><a href="#1-使用-来分隔不同的单元格，使用-来分隔表头和其他行：" class="headerlink" title="1. 使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行："></a>1. 使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行：</h4><pre><code>例：
| name | age |
| ---- | --- |
| zero | 24  |
| liam | 23  |</code></pre>
<p>示例效果：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>zero</td>
<td>24</td>
</tr>
<tr>
<td>liam</td>
<td>23</td>
</tr>
</tbody></table>
<h4 id="2-表格对其-在表头和其他行的分隔符中加上-‘-’"><a href="#2-表格对其-在表头和其他行的分隔符中加上-‘-’" class="headerlink" title="2. 表格对其, 在表头和其他行的分隔符中加上 ‘:’"></a>2. 表格对其, 在表头和其他行的分隔符中加上 ‘:’</h4><h5 id="‘-—‘-左对齐"><a href="#‘-—‘-左对齐" class="headerlink" title="‘:—‘ 左对齐"></a>‘:—‘ 左对齐</h5><h5 id="‘-–-’-居中"><a href="#‘-–-’-居中" class="headerlink" title="‘:–:’ 居中"></a>‘:–:’ 居中</h5><h5 id="‘—-’-右对齐"><a href="#‘—-’-右对齐" class="headerlink" title="‘—:’ 右对齐"></a>‘—:’ 右对齐</h5><pre><code>例：
| left | center | right |
| :--- | :----: | ----: |
|左    |中     |右     |</code></pre>
<p>示例效果:</p>
<table>
<thead>
<tr>
<th align="left">left</th>
<th align="center">center</th>
<th align="right">right</th>
</tr>
</thead>
<tbody><tr>
<td align="left">左</td>
<td align="center">中</td>
<td align="right">右</td>
</tr>
</tbody></table>
<h3 id="上标和下标"><a href="#上标和下标" class="headerlink" title="上标和下标"></a>上标和下标</h3><h4 id="1-上标-使用html标签-lt-sup-gt"><a href="#1-上标-使用html标签-lt-sup-gt" class="headerlink" title="1. 上标 使用html标签 &lt;sup&gt;"></a>1. 上标 使用html标签 <code>&lt;sup&gt;</code></h4><pre><code>例： 来个上标 &lt;sup&gt;[1]&lt;/sup&gt;</code></pre>
<p>示例效果:</p>
<p>来个上标<sup>[1]</sup></p>
<h4 id="2-下标-使用html-标签-lt-sub-gt"><a href="#2-下标-使用html-标签-lt-sub-gt" class="headerlink" title="2. 下标  使用html 标签 &lt;sub&gt;"></a>2. 下标  使用html 标签 <code>&lt;sub&gt;</code></h4><pre><code>例: 来个下标 &lt;sub&gt;[2]&lt;/sub&gt;</code></pre>
<p>示例效果:</p>
<p>来个下标<sub>[2]</sub></p>
]]></content>
      <categories>
        <category>GitHub Pages</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>《程序化广告——个性化精准投放实用手册》常见问题导读</title>
    <url>/2018/08/01/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/%E7%A8%8B%E5%BA%8F%E5%8C%96%E5%B9%BF%E5%91%8A-%E4%B8%AA%E6%80%A7%E5%8C%96%E7%B2%BE%E5%87%86%E6%8A%95%E6%94%BE%E5%AE%9E%E7%94%A8%E6%89%8B%E5%86%8C-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%AF%BC%E8%AF%BB/</url>
    <content><![CDATA[<h4 id="问：与传统广告购买相比，程序化广告有什么优势？"><a href="#问：与传统广告购买相比，程序化广告有什么优势？" class="headerlink" title="问：与传统广告购买相比，程序化广告有什么优势？"></a>问：与传统广告购买相比，程序化广告有什么优势？</h4><p><strong>答： 传统广告购买模式下，广告主需要和总多媒体或者广告代理逐个谈判购买媒体资源；程序化购买模式下，广告主可以通过 <code>DSP</code>、<code>TD</code> 或广告代理来对接 <code>Ad Exchang(ADX)</code> 或 <code>SSP</code>；对于程序化广告，通过 <code>DMP</code> 的数据可以做到精准定向投放，还可以结合 <code>PCP(程序化创意平台)</code> 进行个性化广告制作，实现 “千人千面”；借助 <code>广告验证平台</code> 进行广告验证；还可以满足广告主对 <code>品牌安全</code>，<code>反作弊过滤</code>，<code>广告可见度分析</code>等方面的要求。</strong><br/><br><strong>对于广告主，程序化广告无需耗费人力一一对接各个媒体渠道，直接加入交易市场即可；程序化广告的精准投放能减少预算浪费并提升转化率；实时竞价和实时投放是的广告数据的收集、分析和优化过程变动更简单、高效。</strong><br/><br><strong>对于媒体，程序化广告无需媒体方好美人力资源和广告主或广告代理逐一谈判、对接，只需要对接交易市场；程序化广告能关注每个广告流的销售，将流量进行分级售卖，提高变现能力；程序化广告能更贴合用户的需求，改善媒体用户的用户体验。</strong><br/></p>
<hr>
<h4 id="问：开发和运营需方平台有什么门槛？"><a href="#问：开发和运营需方平台有什么门槛？" class="headerlink" title="问：开发和运营需方平台有什么门槛？"></a>问：开发和运营需方平台有什么门槛？</h4><p><strong>答：开发和运营需求方平台有 <code>技术</code>、<code>资金</code>、<code>流量资源</code>、<code>广告主资源</code>等方面的能力</strong><br/><br><strong>1. 技术：DSP 需要有一下技术能力</strong><br/><br><strong>1.1 参与RTB，实时竞价的能力，保证100ms 内作出响应。</strong><br/><br><strong>1.1.1 数据收集能力：及时收集竞价、曝光和点击数据</strong><br/><br><strong>1.1.2 数据分析能力：竞价过程中DSP 需要分析大量流量数据数据，分析流量是否符合广告投放需求。</strong><br/><br><strong>1.1.3 日志数据处理能力：竞价过程中 DSP 需要出价，DSP 需要对日志进行实时统计和离线统计，然后进行 <code>CTR预估</code>、<code>转化率预估</code>和<code>点击价值预估</code>。</strong><br/><br><strong>1.1.4 用户识别能力：精准定向能力来自DSP 的用户识别能力和定向能力，DSP 需要支持Cookie 和移动设备ID映射去识别用户，DSP 需要收集用户行为数据，清晰的刻画用户画像。</strong><br/><br><strong>2. 资金：DSP 系统需要足够的资金去维持各项硬件设备；还需要足够的运营资金支撑专业团队以及大客户业务</strong><br/><br><strong>3. 流量资源：DSP 需要满足广告主对流量的需求</strong><br/><br><strong>4. 广告主资源：DSP 需要有足够的广告主资源保证广告填充率，同时足够的广告预算去满足资金需求</strong><br/><br><strong>5. 专业人才：技术人才、运营人才</strong><br/><br><strong>5.1 DSP 需要技术人才高效的开发和维护DSP 系统</strong><br/><br><strong>5.2 DSP 需要有专业的运营人才在数据分析的基础上，根据经验，及时调整投放过程中的各项决策</strong><br/></p>
<hr>
<h4 id="问：QPS-是什么意思？流量、竞价请求、QPS-三者之间是什么关系？"><a href="#问：QPS-是什么意思？流量、竞价请求、QPS-三者之间是什么关系？" class="headerlink" title="问：QPS 是什么意思？流量、竞价请求、QPS 三者之间是什么关系？"></a>问：QPS 是什么意思？流量、竞价请求、QPS 三者之间是什么关系？</h4><p><strong>答：QPS(Query Per Second) 是每秒查询率，是对服务器在规定时间内所处理流量多少的衡量标准</strong><br/><br><strong>一个竞价请求一般只携带一个竞价请求，但是为了节省网络流量等原因，部分渠道会通过一个竞价请求写到同一页面不同广告位的多个流量</strong><br/><br><strong>竞价服务会根据DSP的消耗能力(广告填充率、出价和竞得率)设置固定的QPS阈值，或者根据DSP出价和竞得率自动调整QPS阈值</strong><br/><br><strong>DSP 也会在ADX/SSP后台设置它能接收到QPS阈值，防止DSP系统过载</strong><br/></p>
<hr>
<h4 id="问：如何选择需求方平台，有哪些评估指标？"><a href="#问：如何选择需求方平台，有哪些评估指标？" class="headerlink" title="问：如何选择需求方平台，有哪些评估指标？"></a>问：如何选择需求方平台，有哪些评估指标？</h4><p><strong>答：评估需求方有如下指标：媒体资源、技术能力、数据实力、算法能力、公司背景、服务能力、收费模式</strong><br/></p>
<hr>
<h4 id="问：开发和运营广告交易平台有什么门槛？"><a href="#问：开发和运营广告交易平台有什么门槛？" class="headerlink" title="问：开发和运营广告交易平台有什么门槛？"></a>问：开发和运营广告交易平台有什么门槛？</h4><p><strong>答：开发和运营广告交易平台需要 <code>技术完整性</code>、<code>运营规范化</code>、<code>足够的填充率</code></strong><br/><br><strong>技术完整性：完整的流量管理、竞价规则、审核管理等技术机制，保证RTB 流程的高效、完整性</strong><br/><br><strong>运营规范化：规范的DSP技术对接文档、规范化的运营流程</strong><br/><br><strong>足够的填充率：媒体方要求交易平台保证足够的填充率，这取决于交易平台对接的流量质量和规模、价格政策还有数据开放性</strong><br/></p>
<hr>
<h4 id="问：程序化广告常用的第三方技术服务有哪些？提供这些服务的公司有哪些？"><a href="#问：程序化广告常用的第三方技术服务有哪些？提供这些服务的公司有哪些？" class="headerlink" title="问：程序化广告常用的第三方技术服务有哪些？提供这些服务的公司有哪些？"></a>问：程序化广告常用的第三方技术服务有哪些？提供这些服务的公司有哪些？</h4><p><strong>答：程序化广告需要的第三方服务有 **<br/><br>**<code>程序化创意平台(Programmatic Creative Platform)</code>：通过技术自动生成海量创意，并利用算法和数据对不同受众动态的展示广告并进行创意优化，提供服务的有舜飞科技、筷子科技、Sizmek</strong><br/><br><strong><code>广告验证平台(Ad Verification Platform)</code>：</strong><br/><br><strong>足够的填充率：媒体方要求交易平台保证足够的填充率，这取决于交易平台对接的流量质量和规模、价格政策还有数据开放性</strong><br/></p>
<hr>
<h4 id="问：品牌广告如何考核投放效果？"><a href="#问：品牌广告如何考核投放效果？" class="headerlink" title="问：品牌广告如何考核投放效果？"></a>问：品牌广告如何考核投放效果？</h4><p>**答：品牌广告有如下考核标准 **<br/></p>
<p><strong>品牌广告投放效果的考核主要从<code>广告效果</code>，<code>成本收益</code>，<code>投放保障</code>三个方面进行 **<br/><br>**1. <code>广告效果</code>：衡量广告受众的活跃度和对广告的接受度。从广告效果的层级来说，传播效果可以用广告曝光维度衡量；广告达到的心里效果可以通过受众的行为效果进行衡量；行为效果可以从落地页/网站/APP访问以及用户互动角度进行考核。</strong><br/><br><strong>2. <code>成本收益</code>：衡量广告投放整体消耗、各渠道等维度的性价比</strong><br/><br><strong>3. <code>投放保障</code>：一般是衡量广告投放的真实性和安全性，用于保障广告效果以及成本收益。</strong><br/></p>
<p><img src="/assets/picture/brand.ads.kpi.jpg" title="品牌广告投放考核KPI"></p>
<p>** 具体的考核标准如下：*<em><br/><br>** 独立访客数(UV, Unique Visitor)，在特定时间内访问页面的虚拟自然人（用客户端标识）数量 **<br/><br>** 频次(Frequency)，同一波广告投放活动中，每个独立访客接触广告的次数 **<br/><br>** 广告可视度(Viewability)，广告出现在窗口可见区域的广告曝光量占广告总曝光量的占比；具体可见曝光定义见可见曝光定义表 **<br/><br>** 广告可见的TA浓度(Viewable TA%，Target Audience)，<code>TA%</code> = 目标市场中看到广告的TA / 目标市场的广告受众总数 **<br/><br>** 广告可见的TA到达率(Viewable TA N+Search)，目标市场中看到广告N次及以上的的TA数量 / 目标市场广告受众总数 **<br/><br>** 广告可见的互联网总收视点(Viewable IGRP, Internet Gross Rating Points)， <code>IGRP</code> = 平均曝光频次 \</em> 到达率 * 100 **<br/></p>
<p>** 点击率(CTR, Click Through Rate)，广告点击次数占广告展示次数的占比**<br/><br>** 互动率(Engagement Rate)，用户衡量广告投放中用户在广告素材或者站内(网站或APP)的交互度和参与度**<br/><br>** 回搜率(Search Conversion)，广告受众接触广告后在各个平台中搜索广告主相关关键词的用户占比，用于衡量品牌广告对用户品牌认知的提升程度**<br/></p>
<p>** 每点击成本(CPC, Cost Per Click)，广告被点击一次对应的价格 <strong><br/><br>** 每千人成本(CPM, Cost Per Mille\Cost Per Thousand Impressions)，广告被展示1000次对应的价格 **<br/><br>** 每UV成本(CPUV, Cost Per UV)，广告曝光中每获取一个 UV 的价格；计算公式为 CPUV = 广告消耗金额 / UV数量 **<br/><br>** 单次交互成本(CPE, Cost Per Engagement) 或 (CPEV, Cost Per Engaged Visit)，每获得一个受众互动行为对应的价格 **<br/><br>** 受众对广告的浏览\互动时长的成本(CPH, Cost Per Hour)，受众对广告的浏览\互动时长的成本，一定程度上代表了广告对受众品牌意识的影响力</strong><br/><br><strong><em>疑问点：广告主在多个渠道投放了品牌广告，如何确认回搜行为关联的品牌广告是在哪个渠道投放的？</em></strong></p>
<p>** 跳出率(Bounce Rate)，指只浏览了入口页面就离开的访问流量占进入该页面的总流量的比例，用于衡量用户点击广告后进入页面的访问质量 **<br/><br>** 二跳率(2nd-click Rate)，二跳指用户进入落地页之后在页面的首次有效点击，二跳率是二跳量占进入该页面的总访问量的比例 **<br/></p>
<p>** 品牌安全(Brand Safety)，品牌广告的投放环境要求非常高，不允许出现品牌广告出现在某些网站或媒体上，也不允许通过敏感\非法的关键词触发广告；广告主一般通过广告验证平台过滤敏感或非法关键词/页面。**<br/><br>** 反作弊(Anti-Fraud)，品牌广告主的考核标准更容易被作弊，因此广告主需要考量服务方的反作弊能力**<br/><br>** 无效流量验证(Invalid Traffic Verification)，作弊流量只是无效流量的一部分，无效流量的定义见 <code>MMA（中国无线营销联盟）</code><a href="http://www.mmachina.cn/download/MMAa%CC%88%C2%B8%C2%ADa%CC%8A%C2%9B%C2%BD%C3%A6%C2%97%C2%A0c%CC%A7%C2%BA%C2%BFe%CC%80%C2%90%C2%A5e%CC%81%C2%94%C2%80e%CC%80%C2%81%C2%94c%CC%A7%C2%9B%C2%9Fc%CC%A7%C2%A7%C2%BBa%CC%8A%C2%8A%C2%A8a%CC%88%C2%BA%C2%92e%CC%80%C2%81%C2%94c%CC%A7%C2%BD%C2%91a%CC%8A%C2%B9%C2%BFa%CC%8A%C2%91%C2%8A%C3%A6%C2%97%C2%A0%C3%A6%C2%95%C2%88%C3%A6%C2%B5%C2%81e%CC%81%C2%87%C2%8Fe%CC%81%C2%AA%C2%8Ce%CC%80%C2%AF%C2%81%C3%A6%C2%A0%C2%87a%CC%8A%C2%87%C2%86V.1.0.pdf" title="移动互联网广告无效流量验证标准V.1.0">移动互联网广告无效流量验证标准V.1.0</a> ；**<br/><br>** 第三方监控差异(Discrepancy)，第三方数据和DSP平台统计数据之间的差异值 **<br/></p>
<hr>
<h4 id="问：OTV-是指什么？OTV广告的考核指标有哪些？"><a href="#问：OTV-是指什么？OTV广告的考核指标有哪些？" class="headerlink" title="问：OTV 是指什么？OTV广告的考核指标有哪些？"></a>问：<code>OTV</code> 是指什么？<code>OTV</code>广告的考核指标有哪些？</h4><p>**答：<code>OTV</code> 是 <code>Online TV</code>（网络电视或网络视频），主要的考核指标包含上一问题中的 <code>广告可见度</code>, <code>Viewable TA%</code>, <code>Viewable TA N+Reach</code>, <code>Viewable IGRP</code> 以及基本的广告考核标准 **<br/></p>
<hr>
<h4 id="问：广告可视度的标准是什么？"><a href="#问：广告可视度的标准是什么？" class="headerlink" title="问：广告可视度的标准是什么？"></a>问：广告可视度的标准是什么？</h4><p><strong>答：<code>广告可视度(Viewability)</code> 指广告出现在窗口可见痊愈的广告曝光量占广告总曝光率的比例。</strong><br/></p>
<p><strong><code>MMA(中国无线营销联盟)</code> 制定的 <a href="http://47.104.208.19/wp-content/uploads/2018/05/MMA%E4%B8%AD%E5%9B%BD%E6%97%A0%E7%BA%BF%E8%90%A5%E9%94%80%E8%81%94%E7%9B%9F%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91%E5%B9%BF%E5%91%8A%E5%8F%AF%E8%A7%81%E6%80%A7%E9%AA%8C%E8%AF%81%E6%A0%87%E5%87%86V.1.0.pdf" title="移动互联网广告可见性验证标准 V.1.0">移动互联网广告可见性验证标准 V.1.0</a> 中对可见性的定义标准遵从 <code>IBA</code>(互动广告局) 和 <code>MRC</code>(媒体分级委员会) 对可视度的计算标准的定义，具体内容如下：</strong><br/><br><strong>首先需要注意的是，能够被评价广告可视度的广告都必须是有效流量，无效流量是不需要计算可视度的</strong><br/><br><strong>1. 对测量对象的一般要求</strong><br/><br>** &nbsp;&nbsp;&nbsp;&nbsp;1) 客户端计数**<br/><br>** &nbsp;&nbsp;&nbsp;&nbsp;2) 过滤非人类流量和无效流量**<br/><br>** &nbsp;&nbsp;&nbsp;&nbsp;3) 缓存清除技术**<br/><br>** &nbsp;&nbsp;&nbsp;&nbsp;4) 区分明显的（机器人）自动刷新行为与人为活动**<br/><br>** &nbsp;&nbsp;&nbsp;&nbsp;5) 区分被遮挡及不在显示区域的曝光**<br/><br>** &nbsp;&nbsp;&nbsp;&nbsp;6) 公开内部材料和流量的传输**<br/><br>** &nbsp;&nbsp;&nbsp;&nbsp;7) 媒体，门户网站，广告服务器，广告网络和交易所的完整公开**<br/><br><strong>2. 对可见广告的曝光要求</strong><br/></p>
<table>
<thead>
<tr>
<th>广告类型</th>
<th>面积</th>
<th>时长</th>
<th>窗口要求</th>
</tr>
</thead>
<tbody><tr>
<td>PC 展示广告（普通）</td>
<td>&gt;= 50%</td>
<td>&gt;= 1秒</td>
<td>浏览器的可视空间</td>
</tr>
<tr>
<td>PC 展示广告（大）</td>
<td>&gt;= 30%</td>
<td>&gt;= 1秒</td>
<td>浏览器的可视空间</td>
</tr>
<tr>
<td>PC 视屏广告</td>
<td>&gt;= 50%</td>
<td>&gt;= 2秒</td>
<td>浏览器的可视空间</td>
</tr>
<tr>
<td>移动展示广告</td>
<td>&gt;= 50%</td>
<td>&gt;= 1秒</td>
<td>移动浏览器或App终端的可视空间</td>
</tr>
<tr>
<td>移动视屏广告</td>
<td>&gt;= 50%</td>
<td>&gt;= 2秒</td>
<td>移动浏览器或App终端的可视空间</td>
</tr>
</tbody></table>
<hr>
<h4 id="问：如何保障品牌安全，需要规避哪些类别？"><a href="#问：如何保障品牌安全，需要规避哪些类别？" class="headerlink" title="问：如何保障品牌安全，需要规避哪些类别？"></a>问：如何保障<code>品牌安全</code>，需要规避哪些类别？</h4><p><strong>答：品牌广告对于 <code>投放环境</code> 有很高的要求，不能让广告受众对品牌产生负面影响，<code>品牌安全</code> 要求每个广告验证服务商维护并公开潜在规避类别</strong><br/><br><strong>1. IAB <code>内容分级法</code>规定的规避类别 **<br/><br>** · 成人内容（Audit Content）</strong><br/><br>** · 协助非法活动（Facilitation of Illeagl Activities）**<br/><br>** · 有争议的主题，即违反现有的社会规范，如神秘、禁忌、反常的生活方式（Controversial Subjects, contrary to existing social norms, such as OccultTaboos、Unusual Lifestyles）**<br/><br>** · 侵犯版权（Copyright Infringement）**<br/><br>** · 药物\酒精\受管制药品（Drugs\Alcoho\Controlled Substances）**<br/><br>** · 极端的图像\明显暴力内容（Extreme Graphic\Explicit Violence）**<br/><br>** · 诱导篡改度量衡的问题（Incentivized Manipulation of Measurements）**<br/><br>** · 仇恨\亵渎（Hate\Profanity）**<br/><br>** · 骚扰\间谍软件\恶意软件\盗版软件（Nuisance\Spyware<br>Malware\Warez） <strong><br/><br>** · 政治\宗教（Political\Religion）</strong><br/><br>** · 未经认证的有用户生成的内容（Unmoderated User Generated Content）**<br/><br>**2. MMA China 品牌安全和流量质量小组的规避类别 **<br/><br>** · 分裂言论 **<br/><br>** · 讣告 **<br/><br>** · 邪教相关言论 **<br/><br>** · 恐怖主义言论 **<br/><br>** · 党和国家领导人（包括不限于文字、影像等信息）旁 **<br/><br>** · 革命烈士（包括不限于文字、影像等信息）旁 **<br/><br>** · 在广告主媒介计划以外 **<br/></p>
]]></content>
      <categories>
        <category>计算广告</category>
      </categories>
      <tags>
        <tag>程序化广告</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker常用指令</title>
    <url>/2017/11/23/%E6%8A%80%E6%9C%AF/docker/2017-11-23-Docker%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="Docker-常用指令"><a href="#Docker-常用指令" class="headerlink" title="Docker 常用指令"></a>Docker 常用指令</h3><p>作为一个开发最近才开始使用docker ，深感惭愧！<br>最近在学习 <code>CloudMan</code> 大佬的 <a href="http://mp.weixin.qq.com/s/7o8QxGydMTUe4Q7Tz46Diw"><em>《每天5分钟玩转 Docker 容器技术》</em></a>, 通俗易懂，每天积累一点点，积累，这里记录一下常用的 docker 相关知识，仅做笔记用。</p>
<ol>
<li><p>查看本地的所有 <code>docker</code>镜像</p>
<pre><code> docker images</code></pre>
</li>
<li><p>查看指定镜像信息</p>
<pre><code> docker images ubuntu</code></pre>
</li>
<li><p>查看指定tag 的镜像信息</p>
<pre><code> docker images ubuntu:latest</code></pre>
</li>
</ol>
<ol start="4">
<li><p>从 <code>Docker Hub</code> 下载镜像</p>
<pre><code> docker pull hello-world</code></pre>
</li>
<li><p>交互运行一个 container</p>
<pre><code> docker run -it ubuntu</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>计算广告学习笔记之名词汇总</title>
    <url>/2017/09/01/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%90%8D%E8%AF%8D%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近看了刘鹏老师的《计算广告》，叹为惊止，对于接触广告投放业务不到一年的我产生了很大帮助，决定好好研读这本广告 <code>圣经</code></p>
<h4 id="计算广告名词汇总"><a href="#计算广告名词汇总" class="headerlink" title="计算广告名词汇总"></a>计算广告名词汇总</h4><p><code>广告主（Advisiter）</code>： 买广告位的个人或公司<br><code>媒体（media）</code>：卖广告位的个体<br><code>受众（audience）</code>：看广告的人</p>
<p>在线广告创意类型</p>
<ol>
<li><code>横幅广告</code></li>
<li><code>文字链广告</code></li>
<li><code>富媒体广告</code></li>
<li><code>视屏广告</code></li>
<li><code>社交广告</code>：社交广告是指几月社交信息，在用户的社交信息流中展示的广告，如你的还有对汽车很感兴趣，你们有很多的相似点，你将在你的朋友圈看到汽车广告</li>
<li><code>移动广告</code>：移动端的广告</li>
<li><code>邮件定向营销广告</code>：类似产品有通过广告、imessage等方式投放的广告</li>
</ol>
<p><code>展示广告（Display  Advertising）</code>：纸媒上的广告方式迁移到网页中<br><code>合约广告（Agreement-based Advertising）</code>: 采用合同方式约定某一个广告位在某一时间段为某特定广告主主所独占； CPT 结算方式<br><code>受众广告（Target  Advertising）</code>：针对不同用户投放不同的广告<br><code>受众定向（Audience  Targeting）</code>：收集用户信息，进行归类、贴标签<br><code>广告投放 （Advertising Serving）</code>：从静态页面变为实时从服务器获取要展示的广告信息</p>
<p><code>担保式投放（Guaranteed Delivery, GD）</code>：在合约广告的基础上，媒体向广告主保证，某个投放量，并确定投放量未完成的情况下 的赔偿方案。<br><code>按千次展现付费 (Cost per Mille, CPM)</code><br><code>在线分配(online allocation)</code>：对于每一次在线广告的展现进行实时决策，有效的将流量分配到各个合约互相交叉的人群覆盖上</p>
<p><code>竞价广告（auction-based advertising）</code><br><code>搜索广告（search advertising）</code>：用户输入关键词，根据关键词精确定位广告；广告主通过购买关键词来购买广告位资源<br><em>疑问：搜索广告和上下文广告中，广告主都是针对关键词出价，如果两个广告主都买了同一个广告词时，如果选择展示哪个广告？按照 eCPM 排序吗？</em><br><code>上下文广告（search advertising）</code>：将搜索广告中的搜索词换成页面的关键词，通过页面关键词定位广告</p>
<p><code>广义第二高价(Generalized Second Price, GSP)</code></p>
<p><code>ADN（AD Network）</code>：广告网络，批量运营媒体的广告位资源，按照人群或者上下文标签售卖给需求方，并用竞价的方式决定流量分配；在广告市场中广告网络的出现是为了批量聚合各媒体方的<code>剩余流量</code>，批量卖给需求方实现变现，因此广告网络提供的流量一般质量较差，广告网络先天性不适合投放品牌广告；国内主要公司产品：百度网盟</p>
<p><code>竞价广告网络</code>: 竞价售卖方式的广告网络，淡化广告位标的，售卖标的是根据标签划分的人群。产品特点如下</p>
<ol>
<li>竞价方式不向广告主做出量的约定，使得广告网络可以专注于对eCPM的估计</li>
<li>广告网络的出现就是为了批量聚合各媒体的<code>剩余流量</code>，淡化广告位，按人群售卖，很难拿到品牌溢价高的广告位，一般不适合品牌类广告</li>
<li>竞价广告的结算方式首推CPC, 屏蔽了广告位的概念之后，广告主无法估计每次展现出价，当使用CPC结算时，广告主只需要根据点击出价</li>
</ol>
<p><code>竞价广告需求方产品</code>: 1. 挑选广告合适的目标人群 2.针对目标人群给出合理的出价； 上述两个问题的根本就是优化<code>ROI</code><br>a) <code>搜索引擎营销(SEM Search Engine Marketing)</code>：选择合适的关键词；对关键词出价</p>
<p><code>CPC（Cost per click）</code>：按点击收费<br><code>TD（Trading Desk）</code>：交易终端，面对多个ADN或者媒体按人群一站式采买的广告并优化投入产出比的需求方产品</p>
<p><code>RTB（Real Time Bidding）</code>：实时竞价，针对每一次广告展现，向需求方产品发送广告位及用户标识，从需求方获取报价，比较各需求方的价格，选出最优价格，展示该需求方的广告<br><code>ADX (Advertising Exchange)</code>：广告交易平台，大量聚合媒体的剩余流量，并且通过实时竞价的方式将它们变现的产品形态<br><code>DSP（Demand Side Platform）</code>：需求方平台，通过实时竞价的方式，按照定制化的人群标签购买广告； 需求方平台将非竞价广告中需要广告交易平台来实现的对人群进行定制化标签划分工作给接管了，DSP 根据自身的第一方数据（来自DMP)面对市场提供的开放竞价接口，出价采买合适的广告<br><code>DMP (Data Management Platform)</code>：数据管理平台，收集第一方数据，为自身平台收集数据信息<br><code>数据交易平台 (Data Exchange Platform, DEP)</code> 数据交易平台，收集管理交易第三方数 据</p>
<p>第一方数据：广告主自身的数据<br>第二方数据：广告平台的数据<br>第三方数据：不直接参与广告交易的其他数据提供方的数据</p>
<p><code>重定向</code>: 针对在广告主网站有过操作的用户，精确投放操作相关的广告，提高转化率；缺点是只能提高ROI，无法获取新用户</p>
<ol>
<li>个性化重定向， 类似于站外推荐，依赖根据用户信息的精确推荐引擎，对于电商系统动态库存查询接口也是必要的</li>
</ol>
<p><code>新客推荐</code>: 在第一方数据的基础上，依赖第二方数据，针对“对自己的产品可能感兴趣”的用户进行广告投放，针对的是没有关注广告主网站的用户。</p>
<p><em><em>ADN 和 ADX 的差别在于，ADN将媒体资源分类后打包出售，而 ADX 针对每一次广告展现通过实时竞价的方式，单次售卖每一次广告展现</em></em></p>
<p><em><em>TD 和 DSP 的差别在于，TD 批量的从ADN 或者媒体采买广告，而 DSP 需要尽可能的估计每一次广告展现带来的期望价值，计算出一个合理的报价，通过实时竞价从ADX 购买广告</em></em></p>
<p><code>程序化交易(programmatic trade)</code></p>
<p><code>优选(preferred deals)</code>: 允许单个广告主按照自己的意愿挑选广告</p>
<p><code>私有交易市场(Private Market Place, PMP)</code>：邀请部分优质广告主，通过竞价方式，进行广告交易</p>
<p><code>媒介采买平台(media buying Platform)</code></p>
<p><code>原生广告(Native Advertising)</code>：将广告内容和页面信息尽量做到意向近似或展示形式近似</p>
<p><code>eCPM(expected Cost per Mille)</code>：千次展现期望收入，点击率和点击价值的乘积, <code>eCPM</code>的基础是对每次广告展现进行点击率预估</p>
<p><code>广告安全(AD safety)</code>：让合适的广告出现在合适的媒体上</p>
<p><code>CTR (Click Through Rate)</code>：点击率，广告点击和广告展现的比率</p>
<p><code>CVR (Conversion Rate)</code>：转化率，转化次数和到达次数的比例</p>
<pre><code>eCPM =  r(a,u,c) = μ(a,u,c) * v(a,u,c)
(a:广告 u:用户 c:环境 r: 总收入 μ:点击率 v:点击价值)</code></pre>
<p>从上述表达式得出: 当点击价值恒定是，CTR == eCPM<br>eCPM代表DSP的出价，为了快速花完预算，可以将eCPM 预估的高于市场价；为了获得性价比高的流量，将eCPM定位在市场价较低的地方</p>
<p><em><em>eCPM 一般指的是估计的千次展现收益; RPM 指的是千次展现收入; CPM 是千次展示成本</em></em></p>
<p>广告结算方式</p>
<ol>
<li><code>CPM 结算</code>：按照千次展示结算，供给方和需求方约定好前次展示的计费标准，展示的收益效果由需求方把控</li>
<li><code>CPC 结算</code>：即按点击结算，供给方（或中间市场）提供点击率数据，需求方估计点击价值，并且通过点击出价的方式向市场通知自己的估价。优点是，供给方通过大量收集用户行为数据可以相对准确的估计点击率；广告主通过分析用户的站内行为数据，对点击价值作出评估。</li>
<li><code>CPS(Cose per sale)/ CPA(Cost Per Action)/ROI(Return Of Investment) 结算</code>：需求方按照转化收益结算，对需求方来说极大的规避了风险，对供给方来说既要估计点击率又要估计点击价值；在一些场景中供给方无法准确估计点击价值，该结算方式要求供给方能够较准确的估计点击价值或者能借助完善的第三方转化监测估计点击价值。</li>
<li><code>CPT(Cost per Time)</code>：将某个广告位在某段时间内以独占的方式售卖给广告主，价格由双方约定，无需计量；是品牌广告的不二选择</li>
</ol>
<p><code>垂直广告网络(vertical ad network)</code>：特定主题的广告网络，适用<code>CPS(Cose per sale)/ CPA(Cost Per Action)/ROI(Return Of Investment) 结算</code></p>
<p><code>合约广告产品</code>: 按照时段售卖的CPT 广告和按照约定展示量售卖的CPM广告<br><code>竞价广告产品</code>: 主要是搜索广告</p>
<p><code>流量预测</code>: 在担保式投放中，合约中明确约定了投放的量；那么对于供应方系统和广告交易系统来说，精准的<code>流量预测</code>能够让供应方在售卖流量的时候不会因为低估流量而导致流量浪费，也不会因为高估流量导致无法完成合同约定的投放量，总而言之，就是指导媒体方售卖流量；媒体方大多数情况下会和多个广告主之间签订担保投放合同，当一次广告展示符合多个合约的要求，如何决策分配给那个合约能达到整体满足所有合约的目的？在线分配强依赖于<code>流量预测</code>的结果，提高在线分配的效率和准确性；而在竞价广告中供应方不在担保投放量，此时需要广告主根据自己估计的流量预估出价；</p>
<p><code>流量塑形(traffic shaping)</code>: 在有些情况下我们需要主动地影响流量，如修改首页链接入口（待续！）</p>
<p><code>在线分配</code>: 在担保式投放中，多个合约覆盖的人群可能有……待续</p>
<p><code>位置拍卖</code>: 针对一次展现的一组广告位，按照其经验价值排名，在某次广告请求中去除前S个高出价的广告一次放到排序号的S个广告位上，此时可以假设点击率仅与位置s有关，点击价值仅与广告a有关</p>
<p><code>第二高价</code>: 在一个广告位的多轮竞价中，广告主会倾向于逐步降低自己的出价，降到比第二高价高一点点即可成为最高价，为了避免这一现象，我们按照竞价对垒中的第二高价进行收费，此时广告主A出价1元，广告主B出价2元时，广告主A没有降价的动力，广告主B如果降价可能会比广告主A更低，而且降价后加个不会低于1元，保证了市场的收益。<br><code>广义第二高价(GSP， Generalized Second Price)</code>: 将<code>第二高价</code>推广到一系列广告位的竞拍中，对赢得每个位置的广告主，都按照他的下一位的广告位置出价来收取费用。</p>
<p><code>VCG定价</code>: 对于赢得了某个位置的广告主，其所付出的成本应该等于他占据的位置给其他市场参与者带来的价值损害。</p>
<p><code>市场保留价(MRP, Market Reserve Price)</code>:对拍的一个广告位的最低价格，当竞争充分、广告主深度足够时，MRP可以设置的比较高；针对不同流量可以设置不同的MRP。</p>
<p><code>价格挤压</code><br>    r = μ^k * bid(cpc)<br>    k：一个大于0的实数，当k接近正无穷的时候，价格r只与点击率有关；当k接近于0的时候，价格只与cpc出价有关，称为<code>价格挤压因子</code></p>
<p><code>单位流量变现能力(Revenue per Mille, RMP)</code>: 中小媒体没有优秀的品牌价值，无法销售优质品牌溢价广告，只能重点关注单位流量的变现能努力</p>
<blockquote>
<p><code>广告投放引擎</code>: 实时响应广告请求，并决策广告的投放，并且从全局优化的角度管理整体收益；采用的还是类搜索架构（检索+排序）</p>
<blockquote>
<p><code>广告投放机</code>: 结合<code>广告投放引擎</code>的其他模块，接受广告前端web服务器发送来的请求，完成广告投放决策并返回最后页面片段的主逻辑</p>
</blockquote>
<blockquote>
<p><code>广告检索</code>: 在线时根据<code>用户标签</code>和<code>页面标签</code>从<code>广告索引</code>中查找符合条件的广告候选，送入<code>广告排序</code>模块</p>
</blockquote>
<blockquote>
<p><code>广告排序</code>: 结合离线特征（<code>CTR模型和特征</code>）和在线特征（<code>实时点击率特征</code>）预估点击率，实时计算出eCPM，并按此排序</p>
</blockquote>
<blockquote>
<p><code>收益管理</code>: 将部分<code>广告排序</code>的结果进一步调整，尽量调整到全局收益最优</p>
</blockquote>
<blockquote>
<p><code>广告请求接口</code>: 接受广告请求，并且将决策好的广告返回给媒体</p>
</blockquote>
<blockquote>
<p><code>定制化用户划分</code>: 根据广告主的逻辑来划分用户群；从广告主处收集用户信息和产品接口，数据经过复杂的加工之后，通过 <code>数据高速公路</code>导入<code>受众定向</code>模块</p>
</blockquote>
<p><code>离线数据处理平台</code>: 生成报表；通过数据挖掘、机器学习进行受众定向、点击率评估、分配策略规划</p>
<blockquote>
<p><code>用户会话日志生成</code>: 从各个渠道收集到的日志（点击日志等）先整理成已维护ID为键的统一存储格式。</p>
</blockquote>
<blockquote>
<p><code>行为定向</code>: 根据日志中的行为给用户打上<code>结构化标签库</code>中的某些标签，并将结果存储在用户标签的在线缓存中，供广告投放机使用</p>
</blockquote>
<blockquote>
<p><code>上下文定向</code>: 结合<code>半在线页面抓取</code>和上下文页面标签的缓存，与行为定向互相配合，给上下文页面打上标签，并将结果存储到<code>页面标签</code>的在线缓存中，供广告投放机使用</p>
</blockquote>
<blockquote>
<p><code>点击率建模</code>: 在<code>分布式计算平台</code>上训练得到点击率的模型参数和相应特征，加载到缓存中供线上投放系统决策时使用</p>
</blockquote>
<blockquote>
<p><code>分配规划</code>: 根据广告系统全局优化的具体要求，利用离线日志数据进行规划，得到适合线上执行<code>分配方案</code></p>
</blockquote>
<blockquote>
<p><code>商业智能</code>:</p>
</blockquote>
</blockquote>
<p><code>广告排期系统</code>: 一般技术方案是将广告素材按预先确定的排期直接插入媒体页面，并通过<code>内容分发网络(Content Delivery Network CDN)</code>加速访问</p>
<p><code>奇异值分析</code><br><code>潜在语义分析</code></p>
]]></content>
      <categories>
        <category>计算广告</category>
      </categories>
      <tags>
        <tag>计算广告</tag>
      </tags>
  </entry>
  <entry>
    <title>重读计算广告</title>
    <url>/2018/05/14/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/%E9%87%8D%E8%AF%BB%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>看了一遍刘鹏老师的《计算广告》，获益匪浅，但是部分地方还是不够明确，决定重读一番，学习笔记记录如下，如有错漏敬请斧正。</p>
<h3 id="在线广告"><a href="#在线广告" class="headerlink" title="在线广告"></a>在线广告</h3><p>在线广告开创了以人群为投放目标，以产品为导向的技术型投放模式，得到了广告主的青睐。在线广告开启了大规模自动化的利用数据改善产品和提高收入的先河，提供了一种盈利模式。</p>
<h4 id="什么是大数据"><a href="#什么是大数据" class="headerlink" title="什么是大数据"></a>什么是大数据</h4><p>如果有的数据处理问题无法通过数据采样的方法来降低温处理的复杂程度，就必须利用一些专门为海量数据处理而设计的计算和存储技术来实现。</p>
<p>大数据问题的 <code>4V特征</code></p>
<ol>
<li>Volume (规模)</li>
<li>Variety (多样性)</li>
<li>Velocity (高速)</li>
<li>Value (价值)</li>
</ol>
<p>大数据问题的特征：当数据的采用率的递增叫显著提升解决问题的效果，而且两者基本成正比，这就是典型的大数据问题。</p>
<h4 id="为什么要学习计算广告"><a href="#为什么要学习计算广告" class="headerlink" title="为什么要学习计算广告"></a>为什么要学习计算广告</h4><p>计算广告作为目前最成熟的得到充分商业化和规模化的大数据应用<br>1） 提供了规模化的将用户行为数据转为可衡量的商业价值的完整产品线和解决方案；<br>2） 孕育和孵化了较为成熟的数据加工和交易产业链，并对其中的<code>用户隐私</code>边界有深入的探讨；<br>3） 由于商业上的限制条件，计算广告的技术和产品逻辑比个性推荐更加复杂周密；</p>
<h4 id="什么是广告"><a href="#什么是广告" class="headerlink" title="什么是广告"></a>什么是广告</h4><pre><code>    广告是由已经确定的`出资人`通过各种`媒介`进行的有关产品（商品、服务和观点）的，通常是有偿的、有组织的、综合的、劝服性的非人员的信息传播活动。
                                                                                                        ————《当代广告学》</code></pre>
<p>这个定义中有两个主动参与方 ———— <code>出资人</code> 和 <code>媒介</code>, 还有一个被动的参与方, 被劝服的广告的观看者。在计算广告中术语分别是：<code>需求方(Demand)</code>(广告主、广告主代理商、其他形式的采买方)、<code>供给方(Supply)</code>(媒体、其他形式的变现平台)、 <code>广告受众(Adversiter)</code></p>
<p>传统广告主要是电视、报纸广告，在大量投放和优化效果广告的能力显然是缺乏的，只能是宣传品牌形象、提升中长期购买率和利润空间；而在线广告可以实现低成本的投放个性化广告，而且部分数字数字（如搜索、电子商务）可以明确的知道用户的意图，能够很好的优化广告效果。</p>
<p><em><em>广告的根本目的是<code>广告主</code>通过<code>媒体</code>达到<code>低成本</code>的<code>用户</code>接触</em></em></p>
<p>这个定义中的 <code>底成本</code> 需要一个评价指标，这就是 ———— <code>投入产出比（Return On Investment, ROI）</code>，即某次广告活动的总产出与总投入的比例。总投入很容易确定，但是总产出无法确定，但是我们我们也可以通过对各个广告渠道的对比，评估广告成本是否令人满意。</p>
<pre><code>      一切付费的信息、产品或服务的传播渠道，都是广告。</code></pre>
<h4 id="在线广告创意类型"><a href="#在线广告创意类型" class="headerlink" title="在线广告创意类型"></a>在线广告创意类型</h4><blockquote>
<p>横幅广告</p>
<p>文字链接广告</p>
<p>富媒体广告</p>
<p>视频广告</p>
<blockquote>
<p>前插片广告： 视频播放前的</p>
<p>暂停广告：视频播放中，暂停时播放的广告</p>
</blockquote>
<p>社交广告：社交产品中的原生广告</p>
<p>移动广告</p>
<p>邮件定向营销广告</p>
</blockquote>
<h4 id="在线广告简史"><a href="#在线广告简史" class="headerlink" title="在线广告简史"></a>在线广告简史</h4><p>在线媒体出现并发展到一定的流量规模之后，就在页面上直接插入广告位，这种照搬报纸广告在互联网上展示广告的产品形式称为 <code>展示广告(display advertising)</code> , 而售卖广告的模式是采用合同的方式确定某一广告位在某一时间段为某特定广告主所独占，并且根据双方的要求，确定广告创意和投放策略，称为 <code>合约广告</code>。</p>
<p>随着在线媒体的流量快速增长以及在线广告逐渐被广告主了解接受，在线媒体提价的行为被接受，但是媒体流量和品牌认知度都相对稳定之后，提价就不再是提高收入的合适方案了。<br>但是很快在线广告不同于传统媒体广告的本质特点就被发现了：<br><em><em>在线广告可以对不同的广告受众展示不同的广告创意</em></em></p>
<p>这种广告投放的方式就是 <code>定向广告(trageted advertising)</code>。 而要做到这一点，首先要从技术上获取用户的属性标签，例如用户的性别、年龄等标签，这就是<code>受众定向</code>；而且这时候的广告不能再是静态的嵌入到网页中，而是响应前端的实时请求，根据用户标签自动选择并返回合适的广告， 这就是 <code>广告投放(ad serving)</code>。<br>此时广告的售卖方式还是以合同的形式进行，并且在合同中注明媒体需要保证广告的投放量以及投放量未完成时赔偿方案。这种<code>合约广告</code>的交易方式被称为<code>担保式投放（Guaranteed Delivery）</code>, 这种合约还是主要面对品牌广告主，计费方式是<code>按千次展示收费(Cost per Mille, CPM)</code>。</p>
<p>合约广告有两个技术难点：</p>
<ol>
<li>各个合约的目标受众会有交叉覆盖，如何有效的将流量分配到交叉覆盖上；</li>
<li>在在线环境下实时的完成每一次展示决策；<br>这两个难点的问题称为 <code>在线分配</code>， 可以使用 <code>带约束优化</code> 的数学框架来探索这个问题。</li>
</ol>
<p><code>定向投放</code>的目的是供给方为了<code>拆分流量</code>提高营收，但是<em>如果一开始就提供非常精细的定向，反而会造成售卖率下降</em>，品牌广告主都喜欢优质的流量，如果定向十分精确了略差的流量就卖不出去了。</p>
<p><code>受众定向</code>的产生使得市场发展呈现两个趋势</p>
<ol>
<li>定向标签越来越精准；</li>
<li>广告主的数量不断膨胀；</li>
</ol>
<p>上述两个趋势增加了 <code>在线分配</code> 问题的处理难度，降低了流量的变现能力。从业者开始考虑放弃量的保证，供给方只向广告主保证单位流量的成本，对每次展现都基本按照收益最高的原则来决策，这就是 <code>竞价广告</code>。</p>
<p><code>竞价广告</code> 的产生原因如上，然而现实中它的出现来自于 <code>搜索广告</code>，<code>搜索引擎</code>的关键词就是一个精准的定向，很自然的就采用的竞价的售卖方式<br>将搜索关键词换成浏览页面中的关键词就成了 <code>上下文广告</code>（信息流广告的鼻祖）</p>
<p>从宏观市场上看 <code>竞价广告</code> 摆脱了 <code>合约广告</code> 中合约的约束，让广告主能够充分竞争；但是微观上的最优方案并不是整个市场的最大收益。竞价机制的发展，诞生了 <code>广义第二高价 (Generalized Second Price, GSP)</code> 竞价理论。</p>
<p>有了竞价机制和受众定向，不被品牌广告主看好的中小互联网媒体将流量打包给一个组织，组织将媒体资源按照人群或者上下文标签打包售卖，用竞价的方式决定流量分配。这个组织就是 ———— <code>广告网络(ad Network, ADN)</code>。 <code>ADN</code> 采用的计费方式一般是 <code>按点击收费(Cost Per Click, CPC)</code>。最重要的是，ADN 的出现使得不受品牌广告主青睐的比较差流量有了变现的途径。</p>
<p>ADN 只通过出价接口提供价格约定，那么由谁来保证量呢？这就催生了一种需求方产品；此时流量采买发生了几点变化：</p>
<ol>
<li>流量采买更多的面向受众而非媒体或广告位进行采买；</li>
<li>需求方产品需要通过技术手段保证广告主量的要去，并在此基础上帮助广告主优化效果。</li>
</ol>
<p><em>问题：ADN 的竞价流程是什么样的？</em></p>
<p>AND 定义好定向标签，将流量分类打包出售，而不会去控制每次展示的出价；需求方选择了合适的标签组合并阶段性的调整出价来间接控制效果。而需求方产品对接多个 ADN 或媒体按人群一站式采买广告并优化投入产出比，这就是 <code>交易终端(Trading Desk, TD)</code>。</p>
<p>ADN 将媒体的广告受众打上了用户标签，然后批量售卖，但这不能满足需求方越来越明确的利益要求。例如：某电商需要通过给它的忠实用户投放广告来推广某产品，此时需求方需要按照自己的人群定义来挑选流量；流量拍卖的过程从广告主预先出价批量购买，变成了每次展示时实时出价，媒体方提供广告展示的页面的上下文页面URL和用户标识等信息给需求方，需求方就可以完成定制化的人群选择和出价，这就是 <code>实时竞价(Real Time Bidding, RTB)</code>。市场诞生了一个聚合大量媒体的剩余流量并且采用实时竞价方式为他们变现的产品形态 ———— <code>广告交易平台（ad Exchange, ADX）</code>。</p>
<p>通过实时竞价的方式，按照定制化的人群标签购买广告，这样的产品就是<code>需求方平台(Demand Side Platform, DSP)</code>。<code>DSP</code> 需要尽可能准确地估计每次展示带来的期望价值，而因为充分的环境信息使得深入计算和估计成为可能。基于 <code>DSP</code> 的广告采买方式叫作 <code>程序化交易(programmatic trade)</code>, 除了 <code>RTB</code> 外还有 <code>优选(perfered deals)</code> 以及 <code>私有交易市场(Private Market Place, PMP)</code>。</p>
<p>在在线广告的发展历史上，定向技术和交易形式的进化是一条主线。从固定位置合约交易到受众定向、担保投放，再到竞价交易方式，最后发展成开放的实时竞价交易市场。这一主线的核心驱动力是越来越多的数据源为广告决策提供支持，从而提升广告的效果。广告发展的另外一条主线是产品展现逻辑上的发展：从广告位和内容相对独立，到通过搜索广告认识到内容和广告对立起来未必是好的选择，搜索广告和信息流广告突出的效果就是因为内容的展现和触发逻辑高度一致，因此产生了将内容和广告以某种方式统一决策或排序的广告产品 ———— <code>原生广告</code>。<code>原生广告</code> 的思路在移动设备上很有前景。</p>
<h4 id="泛广告商业产品"><a href="#泛广告商业产品" class="headerlink" title="泛广告商业产品"></a>泛广告商业产品</h4><p><code>泛广告商业产品</code> 的本质都是 <code>付费推广</code>，这些付费推广模式的表现方式更加多样化，用户的感知程度和参与程度也大不相同，但是产品的销售模式却与狭义的广告基本相同，但这些商业产品本质上也是在线广告。</p>
<ol>
<li>团购</li>
<li>游戏联运</li>
<li>固定位导航</li>
<li>返利购买</li>
</ol>
<h3 id="计算广告基础"><a href="#计算广告基础" class="headerlink" title="计算广告基础"></a>计算广告基础</h3><p>计算广告的主要特点有 <code>可衡量的效果</code>以及相应的<code>计算优化</code>。</p>
<p>利润优化问题的概念框架</p>
<p>广告产品的收入衡量指标,也是计算广告中最核心的可衡量指标 ———— <code>千次展现期望收入(eCPM, excepted Cost Per Mille)</code>。<br><code>eCPM</code> 可分解为 <code>点击率(Click Through Rate, CTR)</code> 和 <code>点击价值</code></p>
<p>在线广告产品有很多种计费方式，不同的计费方式反映了不同的市场分工; 也就是说供给方和需求方如何分工估计点击率和点击价值，与整个市场的资源优化配置有关。</p>
<h4 id="广告信息接收过程"><a href="#广告信息接收过程" class="headerlink" title="广告信息接收过程"></a>广告信息接收过程</h4><ol>
<li>曝光：广告在页面上展示了</li>
<li>关注： 广告受众关注到了页面上的广告</li>
<li>理解： 广告受众理解了广告的诉求</li>
<li>接受： 广告表达的诉求得到广告受众的认同</li>
<li>保持： 追求长期转化的品牌广告，希望传达的信息给用户留下深刻的印象</li>
<li>决策： 广告最终带来的实际转化行为，例如购买</li>
</ol>
<h4 id="互联网广告的技术特点"><a href="#互联网广告的技术特点" class="headerlink" title="互联网广告的技术特点"></a>互联网广告的技术特点</h4><ol>
<li>技术和计算导向： 数字媒体的特点使得在线广告可以进行精确的受众定向；“由于在线广告有独特的竞价交易方式，可以对广告效果进行有效的预估和优化”。</li>
<li>效果的可衡量性： 广告的展示、点击数据直接可以衡量广告的效果</li>
<li>创意和投放方式的标准化：标准化的驱动力来自于受众定向和程序化购买</li>
<li>媒体概念的多样化：数字媒体的交互功能越来越丰富多彩，和线下媒体已经有了本质差别。不同在线媒体在转化的链条上位置不一样，有些更接近最后的决策，有些是为了吸引潜在用户。</li>
<li>数据驱动的投放决策：在线广告是目前最成熟的大数据引用。在线广告投放流程是：广泛收取用户的行为数据和广告反馈数据，利用云计算基础设施给用户打上合适的标签，同样根据数据在多个广告竞争同一次展示是作出决策，再将投放结果的统计数据反馈广告操作人员以调整投放策略。</li>
</ol>
<h4 id="计算广告的核心问题"><a href="#计算广告的核心问题" class="headerlink" title="计算广告的核心问题"></a>计算广告的核心问题</h4><pre><code>      计算广告的核心问题，是为一系列用户和环境的组合找到最适合的广告投放策略以优化整体广告活动的利润。</code></pre>
<p>上述问题的公式化</p>
<p>max E (ri - qi)</p>
<p>其中 i 表示从第 1 次到第 T 次之间的一次广告展示。优化目标是在这 T 次展示的总收入(r)与总成本(q)的差。</p>
]]></content>
      <categories>
        <category>计算广告</category>
      </categories>
      <tags>
        <tag>计算广告</tag>
      </tags>
  </entry>
  <entry>
    <title>Elastic Search 集群管理之动态扩容收缩</title>
    <url>/2019/03/16/%E6%8A%80%E6%9C%AF/elastic-search/elastic-search%E9%9B%86%E7%BE%A4%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<h1 id="Elastic-Search-集群简单介绍"><a href="#Elastic-Search-集群简单介绍" class="headerlink" title="Elastic Search 集群简单介绍"></a><code>Elastic Search</code> 集群简单介绍</h1><h2 id="Elastic-Search-节点重启"><a href="#Elastic-Search-节点重启" class="headerlink" title="Elastic Search 节点重启"></a><code>Elastic Search</code> 节点重启</h2><p><strong><em>注意：本人使用的是 <code>Elastic Search</code> 的版本是 <code>5.6.x</code>, 不同版本的操作 API 可能不一致</em></strong></p>
<ol>
<li>禁止分配分片</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X PUT <span class="string">&quot;localhost:9200/_cluster/settings&quot;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;transient&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;cluster.routing.allocation.enable&quot;: &quot;none&quot;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>停止不必要的索引的创建，并发出同步刷新请求（非必要步骤）</li>
</ol>
<p><strong><em>在重启节点的过程中，可以不停止索引的创建；但是如果你停止不必要的索引的创建，并发出同步刷新请求的话，分片的回复将会更加快速</em></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X POST <span class="string">&quot;localhost:9200/_flush/synced&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong><em>同步刷新操作只能是尽最大努力执行成功，如果有挂起的索引操作，这个操作将会失败，建议多次执行同步刷新请求</em></strong></p>
<ol start="3">
<li>修改节点配置，重启节点</li>
</ol>
<p>重启完节点之后可以查看节点是否重启成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/_cat/nodes&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>恢复节点分配</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X PUT <span class="string">&quot;localhost:9200/_cluster/settings&quot;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;transient&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;cluster.routing.allocation.enable&quot;: &quot;all&quot;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>等待节点回复</li>
</ol>
<p>使用如下指令查看集群状态，知道集群状态从 <code>yellow</code> 变为 <code>green</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/_cat/health&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>重复上述步骤，重启其他需要重启的节点</li>
</ol>
<h2 id="Elastic-Search-集群动态新增节点"><a href="#Elastic-Search-集群动态新增节点" class="headerlink" title="Elastic Search 集群动态新增节点"></a><code>Elastic Search</code> 集群动态新增节点</h2><h3 id="1-准备在新的机器启动-Elastic-Search-节点"><a href="#1-准备在新的机器启动-Elastic-Search-节点" class="headerlink" title="1. 准备在新的机器启动 Elastic Search 节点"></a>1. 准备在新的机器启动 <code>Elastic Search</code> 节点</h3><h4 id="1-1-从原有节点上拷贝文件到新机器上"><a href="#1-1-从原有节点上拷贝文件到新机器上" class="headerlink" title="1.1 从原有节点上拷贝文件到新机器上"></a>1.1 从原有节点上拷贝文件到新机器上</h4><h4 id="1-2-修改如下配置"><a href="#1-2-修改如下配置" class="headerlink" title="1.2 修改如下配置"></a>1.2 修改如下配置</h4><p>示例如下：将 <code>discovery.zen.minimum_master_nodes</code> 加一，在 <code>discovery.zen.ping.unicast.hosts:</code> 中新增 host <code>new.ip.3</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">discovery.zen.minimum_master_nodes:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">discovery.zen.ping.unicast.hosts:</span> [<span class="string">&quot;ip1&quot;</span>,<span class="string">&quot;ip2&quot;</span>, <span class="string">&quot;new.ip.3&quot;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="1-3-启动此节点"><a href="#1-3-启动此节点" class="headerlink" title="1.3 启动此节点"></a>1.3 启动此节点</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/elasticsearch -d</span><br></pre></td></tr></table></figure>

<h4 id="1-4-查看节点启动情况"><a href="#1-4-查看节点启动情况" class="headerlink" title="1.4 查看节点启动情况"></a>1.4 查看节点启动情况</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/_cat/nodes&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-5-等待集群回复"><a href="#1-5-等待集群回复" class="headerlink" title="1.5 等待集群回复"></a>1.5 等待集群回复</h4><p>使用如下指令查看集群状态，知道集群状态从 <code>yellow</code> 变为 <code>green</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/_cat/health&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-逐个重启其他节点"><a href="#2-逐个重启其他节点" class="headerlink" title="2. 逐个重启其他节点"></a>2. 逐个重启其他节点</h3><p>具体步骤见上述重启步骤，重启 <code>步骤3</code> 中修改 <code>config/elasticsearch.yml</code> 文件</p>
<p>将 <code>discovery.zen.minimum_master_nodes</code> 加一，在 <code>discovery.zen.ping.unicast.hosts:</code> 中新增 host <code>new.ip.3</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">discovery.zen.minimum_master_nodes:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">discovery.zen.ping.unicast.hosts:</span> [<span class="string">&quot;ip1&quot;</span>,<span class="string">&quot;ip2&quot;</span>, <span class="string">&quot;new.ip.3&quot;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="Elastic-Search-集群动态下线节点"><a href="#Elastic-Search-集群动态下线节点" class="headerlink" title="Elastic Search 集群动态下线节点"></a><code>Elastic Search</code> 集群动态下线节点</h2><h3 id="1-告知集群分配分配的时候排除待下线节点"><a href="#1-告知集群分配分配的时候排除待下线节点" class="headerlink" title="1. 告知集群分配分配的时候排除待下线节点"></a>1. 告知集群分配分配的时候排除待下线节点</h3><p>示例：排除 ip <code>10.0.0.1</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -XPUT localhost:9200/_cluster/settings -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">  &quot;transient&quot; :&#123;</span></span><br><span class="line"><span class="string">      &quot;cluster.routing.allocation.exclude._ip&quot; : &quot;10.0.0.1&quot;</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span>;<span class="built_in">echo</span></span><br></pre></td></tr></table></figure>

<h3 id="2-查看分片分配情况"><a href="#2-查看分片分配情况" class="headerlink" title="2. 查看分片分配情况"></a>2. 查看分片分配情况</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$curl</span> -XGET <span class="string">&#x27;http://localhost:9200/_nodes/NODE_NAME/stats/indices?pretty&#x27;</span></span><br></pre></td></tr></table></figure>

<p>执行上述指令得到</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_nodes&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;cluster_name&quot;</span>: <span class="string">&quot;CLUSTER_NAME&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;nodes&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;H447JUPgRSKZKQdzQ6H0gg&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;timestamp&quot;</span>: <span class="number">1551617699642</span>,</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;e93d15417&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;transport_address&quot;</span>: <span class="string">&quot;IP:9300&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;host&quot;</span>: <span class="string">&quot;IP&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;ip&quot;</span>: <span class="string">&quot;IP:9300&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;roles&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;master&quot;</span>,</span><br><span class="line">        <span class="string">&quot;data&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;indices&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;docs&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;count&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;deleted&quot;</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;store&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;size_in_bytes&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;throttle_time_in_millis&quot;</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;indexing&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;index_total&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;index_time_in_millis&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;index_current&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;index_failed&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;delete_total&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;delete_time_in_millis&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;delete_current&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;noop_update_total&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;is_throttled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">&quot;throttle_time_in_millis&quot;</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;get&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;total&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;time_in_millis&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;exists_total&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;exists_time_in_millis&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;missing_total&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;missing_time_in_millis&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;current&quot;</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;search&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;open_contexts&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;query_total&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;query_time_in_millis&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;query_current&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;fetch_total&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;fetch_time_in_millis&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;fetch_current&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;scroll_total&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;scroll_time_in_millis&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;scroll_current&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;suggest_total&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;suggest_time_in_millis&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;suggest_current&quot;</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;merges&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;current&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;current_docs&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;current_size_in_bytes&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;total&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;total_time_in_millis&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;total_docs&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;total_size_in_bytes&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;total_stopped_time_in_millis&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;total_throttled_time_in_millis&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;total_auto_throttle_in_bytes&quot;</span>: <span class="number">4320133120</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;refresh&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;total&quot;</span>: <span class="number">641</span>,</span><br><span class="line">          <span class="attr">&quot;total_time_in_millis&quot;</span>: <span class="number">66</span>,</span><br><span class="line">          <span class="attr">&quot;listeners&quot;</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;flush&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;total&quot;</span>: <span class="number">237</span>,</span><br><span class="line">          <span class="attr">&quot;total_time_in_millis&quot;</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;warmer&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;current&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;total&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;total_time_in_millis&quot;</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;query_cache&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;memory_size_in_bytes&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;total_count&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;hit_count&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;miss_count&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;cache_size&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;cache_count&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;evictions&quot;</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;fielddata&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;memory_size_in_bytes&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;evictions&quot;</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;completion&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;size_in_bytes&quot;</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;segments&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;count&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;memory_in_bytes&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;terms_memory_in_bytes&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;stored_fields_memory_in_bytes&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;term_vectors_memory_in_bytes&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;norms_memory_in_bytes&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;points_memory_in_bytes&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;doc_values_memory_in_bytes&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;index_writer_memory_in_bytes&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;version_map_memory_in_bytes&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;fixed_bit_set_memory_in_bytes&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;max_unsafe_auto_id_timestamp&quot;</span>: <span class="number">-9223372036854775808</span>,</span><br><span class="line">          <span class="attr">&quot;file_sizes&quot;</span>: &#123;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;translog&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;operations&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;size_in_bytes&quot;</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;request_cache&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;memory_size_in_bytes&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;evictions&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;hit_count&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;miss_count&quot;</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;recovery&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;current_as_source&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;current_as_target&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">&quot;throttle_time_in_millis&quot;</span>: <span class="number">90997</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到查询结果中 <code>indices</code> 大部分都是0 ，这是因为步骤 1 排除了当前节点后触发了分配的重新分配</p>
<h3 id="3-查看集群健康情况"><a href="#3-查看集群健康情况" class="headerlink" title="3. 查看集群健康情况"></a>3. 查看集群健康情况</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -XGET <span class="string">&#x27;http://127.0.0.1:9200/_cluster/health?pretty&#x27;</span></span><br></pre></td></tr></table></figure>

<p>确保集群集状态是 <code>green</code></p>
<h3 id="4-重启现有节点"><a href="#4-重启现有节点" class="headerlink" title="4. 重启现有节点"></a>4. 重启现有节点</h3><h4 id="4-1-禁止分配分片"><a href="#4-1-禁止分配分片" class="headerlink" title="4.1 禁止分配分片"></a>4.1 禁止分配分片</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X PUT <span class="string">&quot;localhost:9200/_cluster/settings&quot;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;transient&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;cluster.routing.allocation.enable&quot;: &quot;none&quot;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-2-停止不必要的索引的创建，并发出同步刷新请求（非必要步骤）"><a href="#4-2-停止不必要的索引的创建，并发出同步刷新请求（非必要步骤）" class="headerlink" title="4.2 停止不必要的索引的创建，并发出同步刷新请求（非必要步骤）"></a>4.2 停止不必要的索引的创建，并发出同步刷新请求（非必要步骤）</h4><p><strong><em>在重启节点的过程中，可以不停止索引的创建；但是如果你停止不必要的索引的创建，并发出同步刷新请求的话，分片的回复将会更加快速</em></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X POST <span class="string">&quot;localhost:9200/_flush/synced&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-修改节点配置，重启节点"><a href="#4-3-修改节点配置，重启节点" class="headerlink" title="4.3 修改节点配置，重启节点"></a>4.3 修改节点配置，重启节点</h4><p>修改 <code>config/elasticsearch.yml</code> 文件</p>
<p>示例如下：将 <code>discovery.zen.minimum_master_nodes</code> 减一，在 <code>discovery.zen.ping.unicast.hosts:</code> 中去除 host <code>new.ip.3</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">discovery.zen.minimum_master_nodes:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">discovery.zen.ping.unicast.hosts:</span> [<span class="string">&quot;ip1&quot;</span>,<span class="string">&quot;ip2&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>重启完节点之后可以查看节点是否重启成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/_cat/nodes&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-4-恢复节点分配"><a href="#4-4-恢复节点分配" class="headerlink" title="4.4 恢复节点分配"></a>4.4 恢复节点分配</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X PUT <span class="string">&quot;localhost:9200/_cluster/settings&quot;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;transient&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;cluster.routing.allocation.enable&quot;: &quot;all&quot;,</span></span><br><span class="line"><span class="string">    &quot;cluster.routing.allocation.exclude._ip&quot; : &quot;new.ip.3&quot;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-5-等待节点回复"><a href="#4-5-等待节点回复" class="headerlink" title="4.5 等待节点回复"></a>4.5 等待节点回复</h4><p>使用如下指令查看集群状态，直到集群状态从 <code>yellow</code> 变为 <code>green</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/_cat/health&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-6-重复上述步骤，逐步重启其他线上节点"><a href="#4-6-重复上述步骤，逐步重启其他线上节点" class="headerlink" title="4.6 重复上述步骤，逐步重启其他线上节点"></a>4.6 重复上述步骤，逐步重启其他线上节点</h4><h3 id="5-下线节点"><a href="#5-下线节点" class="headerlink" title="5. 下线节点"></a>5. 下线节点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep elasticsearch</span><br><span class="line"><span class="built_in">kill</span> PID</span><br></pre></td></tr></table></figure>

<h3 id="6-修改分片分配配置"><a href="#6-修改分片分配配置" class="headerlink" title="6. 修改分片分配配置"></a>6. 修改分片分配配置</h3><p>删除配置  <code>&quot;cluster.routing.allocation.exclude._ip&quot; : &quot;new.ip.3&quot;</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X PUT <span class="string">&quot;localhost:9200/_cluster/settings&quot;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;transient&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;cluster.routing.allocation.exclude._ip&quot; : null</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>排除分配分片的节点时候除了指定 <code>ip</code> 还可以指定节点名称 <code>name</code> 以及  <code>host</code></p>
<p>还可以指定ip 匹配规则</p>
<p>如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -XPUT localhost:9200/_cluster/settings -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">  &quot;transient&quot; :&#123;</span></span><br><span class="line"><span class="string">      &quot;cluster.routing.allocation.exclude._ip&quot; : &quot;10.0.0.*&quot;</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span>;<span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line">curl -XPUT localhost:9200/_cluster/settings -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">  &quot;transient&quot; :&#123;</span></span><br><span class="line"><span class="string">      &quot;cluster.routing.allocation.exclude._name&quot; : &quot;NODE_NAME&quot;</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span>;<span class="built_in">echo</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h6 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h6><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/rolling-upgrades.html" title="Rolling upgrades">Rolling upgrades</a><br><a href="https://stackoverflow.com/questions/17268495/how-to-remove-node-from-elasticsearch-cluster-on-runtime-without-down-time" title="How to remove node from elasticsearch cluster on runtime without down time">How to remove node from elasticsearch cluster on runtime without down time</a><br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/allocation-filtering.html" title="Shard Allocation Filtering">Shard Allocation Filtering</a><br><a href="https://stackoverflow.com/questions/33520384/elasticsearch-how-to-delete-a-cluster-setting" title="Elasticsearch: HOW-TO delete a (cluster) setting">Elasticsearch: HOW-TO delete a (cluster) setting</a></p>
]]></content>
      <categories>
        <category>elastic-search</category>
      </categories>
      <tags>
        <tag>elastic search</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink 探究之路 ———— Flink Job 重启策略</title>
    <url>/2019/01/26/%E6%8A%80%E6%9C%AF/flink/flink%E4%B9%8B%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h1 id="Flink-Job-重启策略"><a href="#Flink-Job-重启策略" class="headerlink" title="Flink Job 重启策略"></a>Flink Job 重启策略</h1><p>flink 提供多种重启策略，可以在 <code>flink-conf.yaml</code> 中通过配置 <code>restart-strategy</code> 参数设置默认使用的重启策略，也可以在 <code>job</code> 中指定重启策略。</p>
<p>flink 提供如下重启策略</p>
<ol>
<li>固定延时重启(Fixed delay)</li>
<li>故障率重启(Failure rate)</li>
<li>不重启(No restart)</li>
</ol>
<p>当 <code>job</code> 没有开启 <code>checkpoint</code> 的时候，一定是使用 <code>不重启</code> 策略，如果 <code>job</code> 开启了 <code>checkpoint</code> 但是没有设置重启策略的时候，将使用 <code>固定延时重启策略</code></p>
<h3 id="固定延时重启-Fixed-delay"><a href="#固定延时重启-Fixed-delay" class="headerlink" title="固定延时重启(Fixed delay)"></a>固定延时重启(Fixed delay)</h3><p><code>job</code> 发生故障后，尝试重启 n 次，每次重启间隔固定时间 t，n 次之后失败。</p>
<ol>
<li>在 <code>flink-conf.yaml</code> 中设置重启策略</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">restart-strategy: fixed-delay</span><br><span class="line">restart-strategy.fixed-delay.attempts: <span class="number">3</span> <span class="comment">// 故障发生后尝试重启次数</span></span><br><span class="line">restart-strategy.fixed-delay.delay: <span class="number">10</span> s <span class="comment">// 重启的间隔时间</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>job</code> 中直接指定重启策略</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.setRestartStrategy(RestartStrategies.fixedDelayRestart(</span><br><span class="line">  <span class="number">3</span>, <span class="comment">// number of restart attempts</span></span><br><span class="line">  Time.of(<span class="number">10</span>, TimeUnit.SECONDS) <span class="comment">// delay</span></span><br><span class="line">));</span><br></pre></td></tr></table></figure>

<h3 id="故障率重启-Failure-rate"><a href="#故障率重启-Failure-rate" class="headerlink" title="故障率重启(Failure rate)"></a>故障率重启(Failure rate)</h3><p>故障率重启策略在 <code>job</code> 发生故障后尝试重启，但是当在固定时间<code>failure rate interval</code> 内故障次数超过 <code>failure rate</code> 次后，<code>job</code> 被认定为故障。</p>
<p>举例说明：<code>job</code> 故障停止运行之后，在 5min 内重试 3次，每次间隔10s，如果3次之后依旧失败，则认定为故障</p>
<ol>
<li>在 <code>flink-conf.yaml</code> 中设置重启策略</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">restart-strategy: failure-rate</span><br><span class="line">restart-strategy.failure-rate.max-failures-per-interval: <span class="number">3</span>  <span class="comment">// 故障后尝试重启次数</span></span><br><span class="line">restart-strategy.failure-rate.failure-rate-interval: <span class="number">5</span> min  <span class="comment">// 故障后检查故障率的时间间隔</span></span><br><span class="line">restart-strategy.failure-rate.delay: <span class="number">10</span> s   <span class="comment">// 故障后两次尝试重启的间隔时间</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>job</code> 中直接指定重启策略</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.setRestartStrategy(RestartStrategies.failureRateRestart(</span><br><span class="line">  <span class="number">3</span>, <span class="comment">// max failures per interval</span></span><br><span class="line">  Time.of(<span class="number">5</span>, TimeUnit.MINUTES), <span class="comment">//time interval for measuring failure rate</span></span><br><span class="line">  Time.of(<span class="number">10</span>, TimeUnit.SECONDS) <span class="comment">// delay</span></span><br><span class="line">));</span><br></pre></td></tr></table></figure>

<h3 id="不重启策略-No-Restart"><a href="#不重启策略-No-Restart" class="headerlink" title="不重启策略(No Restart)"></a>不重启策略(No Restart)</h3><ol>
<li>在 <code>flink-conf.yaml</code> 中设置重启策略</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">restart-strategy: none</span><br></pre></td></tr></table></figure>


<ol start="2">
<li><code>job</code> 中直接指定重启策略</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.setRestartStrategy(RestartStrategies.noRestart());</span><br></pre></td></tr></table></figure>

<h6 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h6><p><a href="https://ci.apache.org/projects/flink/flink-docs-stable/dev/restart_strategies.html">https://ci.apache.org/projects/flink/flink-docs-stable/dev/restart_strategies.html</a></p>
<p>本人 flink 小白一枚，如有错漏之处，敬请斧正！</p>
]]></content>
      <categories>
        <category>flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>etcd 使用入门</title>
    <url>/2018/05/21/%E6%8A%80%E6%9C%AF/etcd/2018-05-21-etcd%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="etcd-使用入门"><a href="#etcd-使用入门" class="headerlink" title="etcd 使用入门"></a>etcd 使用入门</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>介绍 etcd 和 raft协议</p>
<h3 id="etcd-安装"><a href="#etcd-安装" class="headerlink" title="etcd 安装"></a>etcd 安装</h3><p>etcd 的安装有两种方式</p>
<ol>
<li>直接从<a href="%22https://github.com/coreos/etcd/releases/%22" title="release binary page">官网</a>下载 release 版本的二进制文件</li>
<li>下载源码手动编译安装</li>
</ol>
<p>个人倾向于使用 release 版本安装，下面开始下载安装</p>
<ol>
<li><p>找到下载的压缩包，解压</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">unzip etcd-v3.3.8-darwin-amd64.zip</span><br></pre></td></tr></table></figure>
</li>
<li><p>将解压的文件夹的移动到安装目录中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo mv /path/to/etcd /usr/<span class="built_in">local</span>/etcd</span><br></pre></td></tr></table></figure>
<p>此时我们可以先看看解压后有什么？</p>
<pre><code> ➜  etcd-v3.3.8-darwin-amd64 ll
 total 113064
 drwxr-xr-x  22 ?  staff   748B  6 16 00:55 Documentation
 -rw-r--r--   1 ?  staff    38K  6 16 00:55 README-etcdctl.md
 -rw-r--r--   1 ?  staff   7.1K  6 16 00:55 README.md
 -rw-r--r--   1 ?  staff   7.7K  6 16 00:55 READMEv2-etcdctl.md
 drwx------   3 ?  staff   102B  7 16 23:45 default.etcd
 -rwxr-xr-x   1 ?  staff    30M  6 16 00:55 etcd
 -rwxr-xr-x   1 ?  staff    25M  6 16 00:55 etcdctl</code></pre>
</li>
</ol>
<p>可以看到这里有两个可执行程序: <code>etcd</code> 和 <code>etcdctl</code></p>
<p><code>etcd</code>: etcd 服务端程序<br><code>etcdctl</code>: etcd 客户端程序</p>
<ol start="3">
<li>启动程序</li>
</ol>
<p>3.1 使用默认配置启动程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./etcd</span><br></pre></td></tr></table></figure>

<p>3.2 来一些启动配置，启动一个集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup ./etcd --name test1 --initial-advertise-peer-urls http://localhost:2380 \</span><br><span class="line">  --listen-peer-urls http://localhost:2380 \</span><br><span class="line">  --listen-client-urls http://localhost:2379,http://127.0.0.1:2379 \</span><br><span class="line">  --advertise-client-urls http://localhost:2379 \</span><br><span class="line">  --initial-cluster-token test-cluster \</span><br><span class="line">  --initial-cluster test1=http://localhost:2380,test2=http://localhost:2390,test3=http://localhost:2400 \</span><br><span class="line">  --initial-cluster-state new \</span><br><span class="line">  --data-dir /app/etcd/data1 &amp;</span><br><span class="line"></span><br><span class="line">nohup ./etcd --name test2 --initial-advertise-peer-urls http://localhost:2390 \</span><br><span class="line">  --listen-peer-urls http://localhost:2390 \</span><br><span class="line">  --listen-client-urls http://localhost:2389,http://127.0.0.1:2389 \</span><br><span class="line">  --advertise-client-urls http://localhost:2389 \</span><br><span class="line">  --initial-cluster-token test-cluster \</span><br><span class="line">  --initial-cluster test1=http://localhost:2380,test2=http://localhost:2390,test3=http://localhost:2400 \</span><br><span class="line">  --initial-cluster-state new \</span><br><span class="line">  --data-dir /app/etcd/data2 &amp;</span><br><span class="line"></span><br><span class="line">nohup ./etcd --name test3 --initial-advertise-peer-urls http://localhost:2400 \</span><br><span class="line">  --listen-peer-urls http://localhost:2400 \</span><br><span class="line">  --listen-client-urls http://localhost:2399,http://127.0.0.1:2399 \</span><br><span class="line">  --advertise-client-urls http://localhost:2399 \</span><br><span class="line">  --initial-cluster-token test-cluster \</span><br><span class="line">  --initial-cluster test1=http://localhost:2380,test2=http://localhost:2390,test3=http://localhost:2400 \</span><br><span class="line">  --initial-cluster-state new \</span><br><span class="line">  --data-dir /app/etcd/data3 &amp;</span><br></pre></td></tr></table></figure>

<h3 id="ETCD-简单指令操作"><a href="#ETCD-简单指令操作" class="headerlink" title="ETCD 简单指令操作"></a><code>ETCD</code> 简单指令操作</h3><ol>
<li><code>ETCD</code> 数据插入</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./etcdctl put key value</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>插入文件数据到 <code>ETCD</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat file | ./etcdctl put key</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>数据查看</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./etcdctl get key</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>集群健康度查看</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./etcdctl --endpoints=[endpoint1, endpoint2, endpoint3] endpoint health</span><br></pre></td></tr></table></figure>
<p>得到结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">endpoint1 is healthy: successfully committed proposal: took = 932.637µs</span><br><span class="line">endpoint2 is healthy: successfully committed proposal: took = 1.058401ms</span><br><span class="line">endpoint3 is healthy: successfully committed proposal: took = 1.127266ms</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>集群节点状态查询</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./etcdctl --endpoints=[endpoint1, endpoint2, endpoint3] endpoint status</span><br></pre></td></tr></table></figure>
<p>得到结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">endpoint1, 180821f2462664c9, 3.2.12, 555 MB, <span class="literal">true</span>, 169, 12167260</span><br><span class="line">endpoint2, b2b4375ce5b9bb02, 3.2.12, 555 MB, <span class="literal">false</span>, 169, 12167260</span><br><span class="line">endpoint3, e4927ddc8eb44d9e, 3.2.12, 555 MB, <span class="literal">false</span>, 169, 12167260</span><br></pre></td></tr></table></figure>

<pre><code>    注意：`ETCD` 的API 分为 `V2` 和 `V3` 两个版本，两者之间差距很大，上述 `etcdctl` 客户端的使用都是 `V3` API，在执行之前，请执行命令 `export ETCDCTL_API=3`</code></pre>
<ol start="6">
<li>数据备份</li>
</ol>
<p>将集群当前的数据全量备份到文件 <code>snapshot.db</code> 中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ETCDCTL_API=3 etcdctl --endpoints <span class="variable">$ENDPOINT</span> snapshot save snapshot.db</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>etcd</category>
      </categories>
      <tags>
        <tag>中间件</tag>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink 基本概念入门</title>
    <url>/2018/11/19/%E6%8A%80%E6%9C%AF/flink/flink%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="Flink-基本概念"><a href="#Flink-基本概念" class="headerlink" title="Flink 基本概念"></a>Flink 基本概念</h1><h2 id="基本名词"><a href="#基本名词" class="headerlink" title="基本名词"></a>基本名词</h2><h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a><code>Job</code></h3><p>以 <code>jar</code> 包的形式在 <code>flink</code> 中提交的可运行程序</p>
<h3 id="task"><a href="#task" class="headerlink" title="task"></a><code>task</code></h3><h3 id="stream"><a href="#stream" class="headerlink" title="stream"></a><code>stream</code></h3><p><code>flink</code> 作为一个流数据处理的引擎，就是针对一个或多个 <code>stream</code> 进行流计算处理，再输出到一个或多个 <code>stream</code> 中去，这里的 <code>stream</code> 可以使 mq，也可以是文件、也可以直接是控制台输入\输出。</p>
<h3 id="operator-amp-amp-task"><a href="#operator-amp-amp-task" class="headerlink" title="operator &amp;&amp; task"></a><code>operator</code> &amp;&amp; <code>task</code></h3><p><code>flink</code> 流处理流程中的每个操作(如 <code>map</code>, <code>keyBy</code>, <code>sink</code>, <code>source</code>等)都是 <code>operator</code></p>
<h3 id="operator-subtask"><a href="#operator-subtask" class="headerlink" title="operator subtask"></a><code>operator subtask</code></h3><p>每个 <code>operator</code> 可以分成多个 <code>operator subtask</code>，一个 <code>operator</code> 的并行度就是 <code>operator subtask</code> 的数量</p>
<h3 id="operator-chain"><a href="#operator-chain" class="headerlink" title="operator chain"></a><code>operator chain</code></h3><p><code>flink</code> 作为分布式运行系统，会将多个 <code>operator subtask</code> 关联成一个 <code>operator task</code>，这个过程就是 <code>operator chain</code>。</p>
<p>两个 <code>operator subtask</code> 能否关联起来，需要满足下列要求</p>
<ol>
<li>上下游的并行度一致</li>
<li>下游节点的入度为1 （也就是说下游节点没有来自其他节点的输入）</li>
<li>上下游节点都在同一个 slot group 中（下面会解释 slot group）</li>
<li>下游节点的 chain 策略为 ALWAYS（可以与上下游链接，map、flatmap、filter等默认是ALWAYS）</li>
<li>上游节点的 chain 策略为 ALWAYS 或 HEAD（只能与下游链接，不能与上游链接，Source默认是HEAD）</li>
<li>两个节点间数据分区方式是 forward（参考理解数据流的分区）<br>用户没有禁用 chain</li>
</ol>
<h2 id="分布式运行时环境"><a href="#分布式运行时环境" class="headerlink" title="分布式运行时环境"></a>分布式运行时环境</h2><h3 id="JobManager"><a href="#JobManager" class="headerlink" title="JobManager"></a><code>JobManager</code></h3><p><code>flink</code> 集群服务的 master 节点，用来协调分布式计算，负责进行任务调度，协调 checkpoints，协调错误恢复等等。一个集群中至少有一个 <code>JobManager</code>，如果有多个 <code>JobManager</code>，其中一个作为 <code>leader</code>，其余处于备用的状态。</p>
<h3 id="TaskManager"><a href="#TaskManager" class="headerlink" title="TaskManager"></a><code>TaskManager</code></h3><p><code>flink</code> 集群的 worker 节点，真正执行 dataflow 中的 tasks，并且对 streams 进行缓存和交换，集群中至少需要一个 <code>TaskManager</code>，每个 <code>TaskManager</code> 是一个 JVM 进程。</p>
<h3 id="Clients"><a href="#Clients" class="headerlink" title="Clients"></a><code>Clients</code></h3><p>连接 <code>flink 集群</code> 的客户端，向 <code>flink 集群</code> 提交计算任务</p>
<h3 id="Task-Slots"><a href="#Task-Slots" class="headerlink" title="Task Slots"></a><code>Task Slots</code></h3><p>每个 <code>TaskManager</code> 都是一个 JVM 进程，可以在不同的线程运行一个或多个线程，每个 <code>TaskManager</code> 通过 <code>Task Slots</code> 来控制可以接收多少个tasks。<br>每个 <code>Task Slots</code> 代表 <code>TaskManager</code> 中一个固定的资源子集，如果 1 个 <code>TaskManager</code> 有 3 个 <code>Task Slots</code>，它会将他的内存资源划分为 3 份分配给每个 slot。<br>通过调整 <code>Task Slots</code> 的数量而调整 subtasks 之间的隔离方式。当每个 <code>TaskManager</code> 只有一个 <code>Task Slot</code> 的时候，意味着每个 <code>task group</code> 运行在独立的的JVM 中。当一个 <code>TaskManager</code> 有多个 <code>slot</code> 的时候，意味着多个 在同一 JVM 进程中的 task 将共享 TCP 链接和心跳信息，他们也能共享。</p>
<p>DateStream API</p>
<p><code>source</code>: 数据来源</p>
<p><code>sink</code>: 处理结果输出</p>
<p><code>window</code>: 窗口</p>
]]></content>
      <categories>
        <category>flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>yarn 集群日常问题汇总</title>
    <url>/2018/11/19/%E6%8A%80%E6%9C%AF/flink/yarn%E9%9B%86%E7%BE%A4%E7%BB%B4%E6%8A%A4%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="yarn-日志"><a href="#yarn-日志" class="headerlink" title="yarn 日志"></a>yarn 日志</h1><h2 id="如何确定-yarn-日志位置"><a href="#如何确定-yarn-日志位置" class="headerlink" title="如何确定 yarn 日志位置"></a>如何确定 yarn 日志位置</h2><ol>
<li>当 <code>yarn.log-aggregation-enable = true</code> 时，<code>yarn</code> 集群中的 <code>application</code> 的日志将被聚合到 <code>yarn.nodemanager.remote-app-log-dir</code> 指向的目录中去，保留时间为 <code>yarn.log-aggregation.retain-seconds</code><br/></li>
</ol>
<p><strong><em><code>yarn.nodemanager.remote-app-log-dir</code> 指向的目录是 hdfs 目录</em></strong><br>2. 当 <code>yarn.log-aggregation-enable = false</code> 时，<code>yarn</code> 集群中的 <code>application</code> 的日志将被存储到 <code>yarn.nodemanager.log-dirs</code> 属性指向的在 <code>nodemanager nodes</code> 上的文件夹中，保留时间为 <code>yarn.nodemanager.log.retain-seconds</code></p>
<h2 id="为什么会有-application-没有日志"><a href="#为什么会有-application-没有日志" class="headerlink" title="为什么会有 application 没有日志"></a>为什么会有 application 没有日志</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn application does not have any log files.</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>yarn</category>
      </categories>
      <tags>
        <tag>yarn</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink DateStream API</title>
    <url>/2018/11/19/%E6%8A%80%E6%9C%AF/flink/Flink-DateStream-API-Desc/</url>
    <content><![CDATA[<h1 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h1><p><em>Chandy Lamport algorithm</em></p>
<h2 id="barrier"><a href="#barrier" class="headerlink" title="barrier"></a>barrier</h2><h2 id="checkpoint-configurations"><a href="#checkpoint-configurations" class="headerlink" title="checkpoint configurations"></a>checkpoint configurations</h2><h3 id="checkpoint-mode"><a href="#checkpoint-mode" class="headerlink" title="checkpoint mode"></a>checkpoint mode</h3><ol>
<li>exactly-once</li>
<li>at-least-once</li>
</ol>
<p><span style="color:red">是否可以给单个算子指定 <code>exactly-once</code> 或者 <code>at-least-once</code> </span></p>
<h3 id="checkpoint-interval"><a href="#checkpoint-interval" class="headerlink" title="checkpoint interval"></a>checkpoint interval</h3><h3 id="checkpoint-timeout"><a href="#checkpoint-timeout" class="headerlink" title="checkpoint timeout"></a>checkpoint timeout</h3><h3 id="minimum-time-between-checkpoints"><a href="#minimum-time-between-checkpoints" class="headerlink" title="minimum time between checkpoints"></a>minimum time between checkpoints</h3><h3 id="number-of-concurrent-checkpoints"><a href="#number-of-concurrent-checkpoints" class="headerlink" title="number of concurrent checkpoints"></a>number of concurrent checkpoints</h3><h3 id="externalized-checkpoints"><a href="#externalized-checkpoints" class="headerlink" title="externalized checkpoints"></a>externalized checkpoints</h3><ol>
<li><code>ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION</code>: 当 flink job 被取消的时候保存 <code>checkpoint</code>，也就是说当我们主动取消 job 的时候需要我手动删除</li>
<li><code>ExternalizedCheckpointCleanup.DELETE_ON_CANCELLATION</code>: 当 flink job 被取消的时候删除 <code>checkpoint</code>， 只有 job 状态是故障失败时 <code>checkpoint</code> 才会被保存。</li>
</ol>
<h4 id="retain-state-checkpoint"><a href="#retain-state-checkpoint" class="headerlink" title="retain state checkpoint"></a>retain state checkpoint</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">state.checkpoints.dir:</span> <span class="string">hdfs:///checkpoints/</span></span><br></pre></td></tr></table></figure>

<h1 id="state"><a href="#state" class="headerlink" title="state"></a>state</h1><h2 id="keyed-state"><a href="#keyed-state" class="headerlink" title="keyed state"></a>keyed state</h2><p><code>Keyed Stream</code> 的状态</p>
<h3 id="ListState"><a href="#ListState" class="headerlink" title="ListState"></a>ListState</h3><p>List 类型的状态集合</p>
<h3 id="ValueState"><a href="#ValueState" class="headerlink" title="ValueState"></a>ValueState</h3><p>单个状态</p>
<h3 id="MapState"><a href="#MapState" class="headerlink" title="MapState"></a>MapState</h3><p>Map 类型的状态集合</p>
<h3 id="ReducingState"><a href="#ReducingState" class="headerlink" title="ReducingState"></a>ReducingState</h3><p>合并统一类型的多个状态数据到一个状态数据</p>
<h3 id="AggregatingState"><a href="#AggregatingState" class="headerlink" title="AggregatingState"></a>AggregatingState</h3><h2 id="operator-state"><a href="#operator-state" class="headerlink" title="operator state"></a>operator state</h2><p><code>org.apache.flink.api.common.state.OperatorStateStore</code> 用于注册 operator state</p>
<p><code>getUnionListState</code>: 获取分布式集群中的 <code>ListState</code></p>
<p><code>getListState</code>: 获取单点的 <code>ListState</code></p>
<h1 id="state-backend"><a href="#state-backend" class="headerlink" title="state backend"></a>state backend</h1><ol>
<li>asynchronus</li>
<li>synchronus</li>
</ol>
<h2 id="memory-state-backends"><a href="#memory-state-backends" class="headerlink" title="memory state backends"></a>memory state backends</h2><p>缺点</p>
<ol>
<li>每个 <code>state</code> 大小限制是 5M</li>
<li><code>state</code> 的大小不能超过 <code>akka frame size</code></li>
<li><code>aggregate state</code> 必须存放在 <code>Job Manager</code> 的内存中</li>
</ol>
<h2 id="fs-state-backends"><a href="#fs-state-backends" class="headerlink" title="fs state backends"></a>fs state backends</h2><p>该模式需要配置文件系统URL，支持 <code>hdfs(hdfs://namenode:40010/flink/checkpoints)</code> 或 <code>本地文件(file:///data/flink/checkpoints)</code><br>将未完成的数据存储在 <code>TaskManager</code> 的内存中，而将 <code>state snapshot</code> 写入到文件系统或者文件夹中，最小化元数据被保存在JobManager的内存中（在高可用模式下，被保存在元数据checkpoint中）。<br>该模式默认 <code>异步</code> 写入 <code>state backend</code>，也可以改为 <code>同步</code> 写入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new FsStateBackend(path, false); &#x2F;&#x2F; true: 异步，false：同步</span><br></pre></td></tr></table></figure>
<h2 id="rocksdb-state-backends"><a href="#rocksdb-state-backends" class="headerlink" title="rocksdb state backends"></a>rocksdb state backends</h2><p>该模式需要配置文件系统URL，支持 <code>hdfs(hdfs://namenode:40010/flink/checkpoints)</code> 或 <code>本地文件(file:///data/flink/checkpoints)</code><br>将未完成的数据存储在 <code>rocksDB</code> 中，而将 <code>state snapshot</code> 写入配置的文件系统或者文件夹中，最小化元数据被保存在JobManager的内存中（在高可用模式下，被保存在元数据checkpoint中）。</p>
<p><code>RocksDBStateBackend</code> 只支持异步快照模式</p>
<p>缺点：</p>
<ol>
<li>因为RocksDB的JNI的API基于byte[]，状态中每个key和每个value所支持的最大值各为2^31字节。</li>
</ol>
<p><strong><em>注意：state使用了RocksDB的合并算子（如ListState），状态的大小很容易累积超过2^31字节，下一次状态恢复就会失败。这是当前RocksDB JNI的局限性。</em></strong></p>
<p><strong><em>RocksDBStateBackend是当前唯一一种提供增量checkpoint的state backend.</em></strong></p>
<h2 id="restart-strategies（重启策略）"><a href="#restart-strategies（重启策略）" class="headerlink" title="restart strategies（重启策略）"></a>restart strategies（重启策略）</h2><h1 id="Event-Time"><a href="#Event-Time" class="headerlink" title="Event Time"></a>Event Time</h1><h2 id="Processing-time"><a href="#Processing-time" class="headerlink" title="Processing time"></a>Processing time</h2><p><code>flink</code> 开始处理事件的时间</p>
<h2 id="Event-time"><a href="#Event-time" class="headerlink" title="Event time"></a>Event time</h2><p>时间发生的原始时间，由<code>事件发生器</code>自主设置</p>
<h2 id="Ingestion-time"><a href="#Ingestion-time" class="headerlink" title="Ingestion time"></a>Ingestion time</h2><p><code>Flink Source</code> 接收到事件的时间</p>
<h1 id="operator"><a href="#operator" class="headerlink" title="operator"></a>operator</h1><h2 id="operator-lifecycle"><a href="#operator-lifecycle" class="headerlink" title="operator lifecycle"></a>operator lifecycle</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; initialization phase</span><br><span class="line">OPERATOR::setup</span><br><span class="line">    UDF::setRuntimeContext</span><br><span class="line">OPERATOR::initializeState</span><br><span class="line">OPERATOR::open</span><br><span class="line">    UDF::open</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; processing phase (called on every element&#x2F;watermark)</span><br><span class="line">OPERATOR::processElement</span><br><span class="line">    UDF::run</span><br><span class="line">OPERATOR::processWatermark</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; checkpointing phase (called asynchronously on every checkpoint)</span><br><span class="line">OPERATOR::snapshotState</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; termination phase</span><br><span class="line">OPERATOR::close</span><br><span class="line">    UDF::close</span><br><span class="line">OPERATOR::dispose</span><br></pre></td></tr></table></figure>

<p><strong><em>注意：<code>initializeState()</code>包含operator state的初始化（例如register keyed state），也包含任务失败后从checkpoint中恢复state的逻辑。</em></strong></p>
]]></content>
      <categories>
        <category>flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>浮点数学习笔记</title>
    <url>/2017/12/06/%E6%8A%80%E6%9C%AF/golang/2017-12-06-%E6%B5%AE%E7%82%B9%E6%95%B0/</url>
    <content><![CDATA[<h2 id="浮点数学习笔记"><a href="#浮点数学习笔记" class="headerlink" title="浮点数学习笔记"></a>浮点数学习笔记</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近在工作中遇到汇率换算的问题，需要将用户订单中的的本币换算成美元，用 <code>golang</code> 写了个脚本进行换算，当把汇率变量的类型定义为 <code>float32</code> 的时候，计算结果存在不能接受的误差<br>查看了一下 <code>golang</code> 的官方文档，发现 <code>golang</code> 实现的浮点型数据是基于 <code>IEEE 754标准</code>，这一标准在存储小数的时候先天就 <code>存在误差</code>，下面会一一介绍。</p>
<h3 id="float-精度问题"><a href="#float-精度问题" class="headerlink" title="float 精度问题"></a><code>float</code> 精度问题</h3><p>先来个小例子，抛出问题</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">64.35</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">64.35</span>  <span class="comment">// 默认类型是 float64</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;this is a float32 %f \n&quot;</span>, a)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;this is a float64 %f \n&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果：</p>
<pre><code>      this is a float32 64.349998
      this is a float64 64.350000</code></pre>
<p>可以看到, 使用 <code>float32</code> 类型的时候， 小数 <code>64.35</code> 存储的并不精准；不难想象，对 <code>float32</code> 进行逻辑计算的时候肯定会产生误差；那么使用 <code>float64</code> 类型数据的时候，计算结果就一定精准吗？答案显然是<code>否定</code>的，下面给将给出答案</p>
<h3 id="为什么叫-浮点数"><a href="#为什么叫-浮点数" class="headerlink" title="为什么叫 浮点数"></a>为什么叫 <code>浮点数</code></h3><p>为什么叫 <code>浮点数</code>， <code>浮点数</code> 这个名词是相对 <code>定点数</code>来说的，从这两个名词中可以看出，这两个概念的差别就在于 <code>点</code>， 这里的 <code>点</code> 指的是小数中的 <code>小数点</code>；</p>
<p>大家都知道，计算机都是使用 <code>二进制</code> 的形式来存储和计算数据的，对于小数的处理也是如此；</p>
<p>存储小数的时候，计算机将小数分为 <code>整数</code> 和 <code>小数</code> 两个部分进行处理：</p>
<p><code>定点数</code> 就是将小数点的位置固定，分别分配固定的位数用于存储 <code>整数</code> 和 <code>小数</code> 部分，<br>例如，我们用 32bit 存储小数，第31位存储符号，23<del>30位存储 <code>整数</code>，0</del>22 位存储小数，如下图，</p>
<table>
<thead>
<tr>
<th>0</th>
<th>0000 1111</th>
<th>0100 0000 0000 0000 0000 000</th>
<th>15.25</th>
</tr>
</thead>
<tbody><tr>
<td>31bit符号位</td>
<td>23~30bit保存整数部分</td>
<td>0~22bit保存小数部分</td>
<td>十进制小数</td>
</tr>
</tbody></table>
<p>上面这个例子中 <code>定点数</code> 将小数点固定在 22bit 和 23bit 之间；可以很明显的看出，这种存储方式受到位数的限制，能表示的数字范围很小，上例中小数的范围就是 -255.xxx ~ 255.xxx </br><br>(ps：寡人太懒了，不想算[1/2 + 1/4 + … + 1/2<sup>-23</sup>])<br>也正是这个原因，计算机放弃了这种方式，采用了 <code>浮点数</code> 的方式。</p>
<p><code>浮点数</code> 从名称上来解释的就是，小数点的位置是浮动的；简单来说浮点数就是将一个数字用<code>科学计数法</code>表示，先将数字分为 <code>基数</code>、<code>指数</code>； 再将<code>基数</code>分为整数部分和小数部分，例如:<br>12345 = 1.2345 x 10<sup>4</sup>；当然这里是十进制，而计算机在存储<code>浮点数</code>的时候当然还是二进制</p>
<p>15.25 = 1111.01 = 1.11101 x 2<sup>3</sup></p>
<p>让我们用32bit 保存小数：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1000 0010</th>
<th>1110 1000 0000 0000 0000 000</th>
<th>15.25</th>
</tr>
</thead>
<tbody><tr>
<td>31bit符号位</td>
<td>23~30bit保存指数部分</td>
<td>0~22bit保存小数部分</td>
<td>十进制小数</td>
</tr>
</tbody></table>
<p>你能从这个二进制中看出小数点的位置吗？</br><br>这里大家要注意： <strong>浮点数不仅仅可以保存小数！整数也是可以的</strong>，但是用浮点数表示整数这种行为不鼓励，毕竟浮点数表示数字是不精确的</p>
<h3 id="IEEE-754-存储-浮点数"><a href="#IEEE-754-存储-浮点数" class="headerlink" title="IEEE 754 存储 浮点数"></a><code>IEEE 754</code> 存储 <code>浮点数</code></h3><p>上面讲<code>浮点数</code>的时候也基本介绍了 <code>IEEE 754</code> 标准</br><br><code>IEEE 754</code> 标准依赖于 <code>科学计数法</code>，将一个数字用二进制科学计数法表示，将一个数字分为<code>指数</code>和<code>基数</code>，用一位表示符号位，再将基数分为整数（二进制的整数部分当然是1了）和小数部分；<code>IEEE 754</code>规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80位实现）；如下：</p>
<table>
<thead>
<tr>
<th>表示方式</th>
<th>符号位（Sign,S）</th>
<th>指数部分(Exponent,E)</th>
<th>小数部分(Fraction,F)</th>
</tr>
</thead>
<tbody><tr>
<td>单精确度（32位）</td>
<td>1bit</td>
<td>8bit</td>
<td>23bit</td>
</tr>
<tr>
<td>双精确度（64位）</td>
<td>1bit</td>
<td>11bit</td>
<td>52bit</td>
</tr>
</tbody></table>
<p>一个单精确度（32位）浮点数的表达公式如下:<br/><br><strong>ｘ＝(－1)<sup>S</sup>×(1.F)×2<sup>Ｅ－127</sup> 　 　e＝Ｅ－127</strong></p>
<p><code>Sign</code>: 简写为S，符号位，很简单就是 1:负数 0:正数<br/><br><code>Exponent</code>: 简写为E，指数部分，计算公式是：<code>指数+接码偏移量(127)</code><br/><br><code>Fraction</code>: 简写为F，小数部分</p>
<p>到这里大家就很自然的会想到一个问题 <strong>阶码偏移量为何用127?</strong></p>
<p>这个问题也困扰我很久，看了<code>维基百科</code>等资料，最后在<code>知乎</code>上找到了一个比较靠谱的答案，引用如下：</p>
<p>主要是为了让表示的范围能够对称起来<br>这个算一算就清楚了。当阶码E 为全0且尾数M 也为全0时，表示的真值x 为零，结合符号位S 为0或1，有正零和负零之分。当阶码E 为全1且尾数M为全0时，表示的真值x 为无穷大，结合符号位S 为0或1，也有+∞和-∞之分。这样在32位浮点数表示中，要除去E，用全0和全1(255)10表示零和无穷大的特殊情况，指数的偏移值不选128(10000000)，而127(01111111)。对于规格化浮点数，阶码E范围是1<del>254。 分两种情况计算如下： 1）偏移值为127时，绝对值范围大致是：1.2*10^(-38)</del>3.4<em>10^(+38)； 2）如果偏移值取为128时， 绝对值范围大致是：5.9</em>10^(-39)~1.7*10^(+38)； 可见偏移值取127时，上下范围基本对称，相对合理点。</p>
<p>作者：yuanyuany<br>链接：<a href="https://www.zhihu.com/question/24784136/answer/144601879">https://www.zhihu.com/question/24784136/answer/144601879</a><br/><br>来源：知乎</p>
<p>如果是双精确度（64位）</p>
<h3 id="十进制-和-IEEE-754浮点数-相互转化"><a href="#十进制-和-IEEE-754浮点数-相互转化" class="headerlink" title="十进制 和 IEEE 754浮点数 相互转化"></a><code>十进制</code> 和 <code>IEEE 754浮点数</code> 相互转化</h3><p>下面来个小例子， 我们将 <code>64.35</code> 转化成<code>IEEE 754浮点数</code></p>
<ol>
<li>现将 <code>64.35</code> 用转化成 <code>二进制</code></li>
</ol>
<p>先看整数部分 <code>64</code> = <code>0100 0000</code></p>
<p>再来转化小数部分转二进制</p>
<p>0.35x2 = 0.7  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0 // 取计算结果整数部分</br><br>0.70x2 = 1.4  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1 // 取上一计算结果的小数部分乘以2 </br><br>0.40x2 = 0.8  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0 </br><br>0.80x2 = 1.6  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1 </br><br>0.60x2 = 1.2  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1 </br><br>0.20x2 = 0.4  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0 </br><br>0.40x2 = 0.8  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0 </br><br>0.80x2 = 1.6  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1 </br><br>0.60x2 = 1.2  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1 </br><br>0.40x2 = 0.8  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0 // 到这里已经是循环重复了，这里永远不会算出1.0，所以用 <code>IEEE 754</code> 表示的时候是无限循环 </br></p>
<p>小数部分： <code>0.35</code> = <code>01 0110 0110 ...</code></p>
<p>二进制结果  <code>64.35</code> = <code>1000000.0101100110...</code> = <em><em>1.0000 0001 0110 0110 0110… x 2<sup>6</sup></em></em></p>
<p>用 32bit <code>IEEE 754</code> 存储 <code>64.35</code></br><br>s = 0</br><br>expr = 127 + 6 = 133 = <code>1000 0101</code> </br><br>frag = <code>0000 0001 0110 0110 0110 011</code></br></p>
<p><code>IEEE 754</code> 32位存储 <code>64.35</code> 的情况如下</br><br><code>64.35</code> = <code>0 | 1000 0101 | 0000 0001 0110 0110 0110 011</code></p>
<p>用 64bit <code>IEEE 754</code> 存储 <code>64.35</code></br><br>s = 0</br><br>expr = 1023 + 6 = 1029 = <code>1000 0000 0101</code> </br><br>frag = <code>0000 0001 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110</code></br></p>
<p><code>IEEE 754</code> 64位存储 <code>64.35</code> 的情况如下</br><br><code>64.35</code> = <code>0 | 1000 0000 0101 | 0000 0001 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110</code></p>
<p>我们再将<code>IEEE 754浮点数</code> 还原成小数,</p>
<p>先看看32bit 的情况<br>看看，算出指数  1000 0101 - 1111111 = 133 - 127 = 6<br/><br>然后这个浮点数的二进制表示就是 <code>1.0000 0001 0110 0110 0110 011 x 2&lt;sup&gt;6&lt;/sup&gt;</code><br/><br>下面就是换算成<code>十进制</code><br>1.0000 0001 0110 0110 0110 011 x 2<sup>6</sup> = 100 0000.0101 1001 1001 1001 1</p>
<p>先看整数部分  0100 0000 = 64<br>在看小数部分 0.0101 1001 1001 1001 1 转十进制</p>
<p>1/2<sup>2</sup> + 1/2<sup>4</sup> + 1/2<sup>5</sup> + 1/2<sup>8</sup> + 1/2<sup>9</sup> + 1/2<sup>12</sup> + 1/2<sup>13</sup> + 1/2<sup>16</sup> + 1/2<sup>17</sup> = 0.349052429199219</p>
<p>结论: <code>0 | 1000 0101 | 0000 0001 0110 0110 0110 011</code> = <code>64.349052429199219</code></p>
<p>再看 64bit 的情况：<br/><br>1.0000 0001 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 x 2<sup>6</sup> = 100 0000.0101 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 10</p>
<p>0.0101 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 10 =<br>1/2<sup>2</sup> + 1/2<sup>4</sup> + 1/2<sup>5</sup> + 1/2<sup>8</sup> + 1/2<sup>9</sup> + 1/2<sup>12</sup> + 1/2<sup>13</sup> + 1/2<sup>16</sup> + 1/2<sup>17</sup> + 1/2<sup>20</sup> + 1/2<sup>21</sup> + 1/2<sup>24</sup> + 1/2<sup>25</sup> + 1/2<sup>28</sup> + 1/2<sup>29</sup> + 1/2<sup>32</sup> + 1/2<sup>33</sup> + 1/2<sup>36</sup> + 1/2<sup>37</sup> + 1/2<sup>40</sup> + 1/2<sup>41</sup> + 1/2<sup>44</sup> + 1/2<sup>45</sup> = 0.349999999999994</p>
<p>结论: <code>0 | 1000 0000 0101 | 0000 0001 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110</code> = <code>64.349999999999994</code></p>
<p>从这里也可以看出浮点数都不精确！当对精确有要求的时候尽量避免使用浮点数。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>浮点数</tag>
      </tags>
  </entry>
  <entry>
    <title>HBase 简介和使用 Sqoop 同步 Mysql 数据到 HBase</title>
    <url>/2018/08/26/%E6%8A%80%E6%9C%AF/hbase/hbase-sqoop/</url>
    <content><![CDATA[<h3 id="HBase-数据模型"><a href="#HBase-数据模型" class="headerlink" title="HBase 数据模型"></a><code>HBase</code> 数据模型</h3><h4 id="Namespace-命名空间"><a href="#Namespace-命名空间" class="headerlink" title="Namespace: 命名空间"></a><code>Namespace</code>: 命名空间</h4><p>类似于关系型数据库中的 <code>database schema</code></p>
<h4 id="Table-表"><a href="#Table-表" class="headerlink" title="Table: 表"></a><code>Table</code>: 表</h4><p>一个 <code>Namespace</code> 下有多个表，一个表可以包含多个行</p>
<h4 id="Row-行"><a href="#Row-行" class="headerlink" title="Row: 行"></a><code>Row</code>: 行</h4><p>在 <code>HBase</code> 中 <code>Row</code> 由一个 <code>Row Key</code> 和一个或多个列及其值组成，数据值的存储按照 <code>Row Key</code> 的字典顺序存储的。</p>
<h4 id="Column-列"><a href="#Column-列" class="headerlink" title="Column: 列"></a><code>Column</code>: 列</h4><p>在 <code>HBase</code> 中， 每个列有它所属的 <code>Column Family(列簇)</code>， 以及<code>Column Qualifier(列修饰符)</code>, 列名组成是 <code>Column Family:Column Qualifier</code></p>
<h4 id="Column-Family-列簇"><a href="#Column-Family-列簇" class="headerlink" title="Column Family: 列簇"></a><code>Column Family</code>: 列簇</h4><p>在 <code>HBase</code> 中将列进行分类，每个列都有它所属的<code>列簇</code>，<code>列簇</code> 把列和相应的值物理上联合在一起。创建表的时候，必须指定至少一个 <code>列簇</code>。每个列出是一个存储属性的集合，</p>
<h4 id="Column-Qualifier-列修饰符"><a href="#Column-Qualifier-列修饰符" class="headerlink" title="Column Qualifier: 列修饰符"></a><code>Column Qualifier</code>: 列修饰符</h4><p><code>列簇</code> 和 <code>列修饰符</code> 才是实际意义上的列唯一标识，假设存在 <code>列簇</code> content, 可以存在 <code>列修饰符</code> xml, 组成一个唯一的列标识 <code>content:xml</code>；创建表的时候，<code>列簇</code> 已经被指定了，但是 <code>列修饰符</code> 是可变的，可以再 <code>put</code> 指令中随意指定属于 <code>列簇</code> 的 <code>列修饰符</code>。</p>
<h4 id="Cell"><a href="#Cell" class="headerlink" title="Cell"></a><code>Cell</code></h4><p>一个Cell是行，列簇和列修饰符的组合，并且包含一个值和时间戳，时间戳代表着值的版本。</p>
<h4 id="Timestamp（时间戳）"><a href="#Timestamp（时间戳）" class="headerlink" title="Timestamp（时间戳）"></a><code>Timestamp</code>（时间戳）</h4><p>一个时间戳是连同值一起被写入的，是值版本的唯一标识，默认情况下，时间戳表示数据写入时RegionServer的时间，但是当你在写数据到Cell的时候，你可以指定一个不同的时间戳。</p>
<h3 id="HBase-常用指令"><a href="#HBase-常用指令" class="headerlink" title="HBase 常用指令"></a><code>HBase</code> 常用指令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> create_namespace <span class="string">&#x27;n1&#x27;</span> //  创建一个 namespace n1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> list_namespace        //  列出所有的 namespace</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> create <span class="string">&#x27;n1:t1&#x27;</span>, <span class="string">&#x27;CF1&#x27;</span>, <span class="string">&#x27;CF2&#x27;</span> // 创建表 t1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> list_namespace_tables <span class="string">&#x27;n1&#x27;</span>   // 列出 namespace n1 下的所有 table</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> describe <span class="string">&#x27;n1:t1&#x27;</span>      //  查看表结构</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> put <span class="string">&#x27;n1:t1&#x27;</span>, <span class="string">&#x27;rk&#x27;</span>, <span class="string">&#x27;CF1:name&#x27;</span>, <span class="string">&#x27;test&#x27;</span> // 往表 n1:t1 中 row key 是 rk 的行中插入列名称是 CF1:name 的值 <span class="string">&#x27;test&#x27;</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> get <span class="string">&#x27;n1:t1&#x27;</span>, <span class="string">&#x27;rk&#x27;</span> // 获取表 <span class="string">&#x27;n1:t1&#x27;</span> 中 row key 是 rk 的所有数据</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> scan <span class="string">&#x27;n1:t1&#x27;</span>      // 模糊查看表 n1:t1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> scan <span class="string">&#x27;n1:t1&#x27;</span>, FILTER=&gt;<span class="string">&quot;ColumnPrefixFilter(&#x27;name&#x27;) AND ValueFilter(=,&#x27;substring:test&#x27;)&quot;</span>  // 模糊查询，列修饰符前缀为name 且值中包含字段 <span class="built_in">test</span> 的数据</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> delete <span class="string">&#x27;n1:t1&#x27;</span>, <span class="string">&#x27;rk&#x27;</span>, <span class="string">&#x27;CF1:name&#x27;</span> // 删除 row key 是 rk 列 `CF1:name` 的数据</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">disable</span> <span class="string">&#x27;n1:t1&#x27;</span>      // 禁用表 n1:t1，被被删除之前必须先被禁用</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> is_enabled <span class="string">&#x27;n1:t1&#x27;</span>   // 查看表 n1:t1 是否可用</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> is_disabled <span class="string">&#x27;n1:t1&#x27;</span>  // 查看表 n1:t1 是否被禁用</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">enable</span> <span class="string">&#x27;n1:t1&#x27;</span>       // 启用表 n1:t1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> drop <span class="string">&#x27;n1:t1&#x27;</span>         // 删除表 n1:t1，注意：只能删除被禁用的表</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> drop_namespace <span class="string">&#x27;n1&#x27;</span>  // 删除命名空间 n1，注意：只能删除没有表的 namespace</span></span><br></pre></td></tr></table></figure>

<h3 id="sqoop-导出-mysql-数据到-HBase"><a href="#sqoop-导出-mysql-数据到-HBase" class="headerlink" title="sqoop 导出 mysql 数据到 HBase"></a><code>sqoop</code> 导出 <code>mysql</code> 数据到 <code>HBase</code></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HADOOP_CLASSPATH=/absolute/path/to/mysql-connector-java-5.1.15.jar  </span><br><span class="line">sqoop import --connect jdbc:mysql://ip:port/database_name --username &#x27;username&#x27; --password &#x27;password&#x27; --table &#x27;table_name&#x27; --columns &quot;id,name,code,description&quot; --hbase-table &#x27;test:hbase_table_name&#x27; --hbase-create-table --hbase-row-key &#x27;id,code&#x27; --column-family info</span><br></pre></td></tr></table></figure>

<p>上述命令行解析</p>
<ol>
<li><p>设置 <code>HADOOP_CLASSPATH</code><br/><br>首先需要设置 <code>HADOOP_CLASSPATH</code>，值是 <code>mysql-connector-java-5.1.15.jar</code> 的绝对路径，否则会报错：<code>java.lang.RuntimeException: Could not load db driver class: com.mysql.jdbc.Driver</code></p>
</li>
<li><p><code>--connect</code><br/><br>连接数据库的url，从这个数据库中导出数据</p>
</li>
<li><p><code>--username</code><br/><br>数据库用户名</p>
</li>
<li><p><code>--password</code><br/><br>数据库密码</p>
</li>
<li><p><code>--table</code><br/><br>导出数据的源数据库表</p>
</li>
<li><p><code>--columns</code><br/><br>本次导出的数据，可以一次导出多列，用逗号分隔，导出的列在hbase 中属于 <code>--column family</code> 参数指定的列簇，列名称是  <code>column family:mysql表中的列名</code>，需要注意的是，如果没有指定参数 <code>--hbase-row-key</code>，在hbase 表中的row key 将是 <code>--columns</code> 中第一列。</p>
</li>
<li><p><code>--hbase-table</code><br/><br>本次导入数据的 hbase 表，需要注意的是导入数据的hbase 表可以不存在，但是hbase 表所属的 namespace 必须是存在的，否则会报错：<br/></p>
<pre><code> Import failed: org.apache.hadoop.hbase.NamespaceNotFoundException: org.apache.hadoop.hbase.NamespaceNotFoundException: &#39;namespace&#39;</code></pre>
</li>
<li><p><code>--hbase-create-table</code><br/><br>如果导入数据的表不存在，则创建该表</p>
</li>
<li><p><code>--hbase-row-key</code><br/><br>设置 hbase 中的 <code>Row Key</code>，参数值是mysql 表中的列名，可以设置多个列合并成 <code>Row Key</code>, 用逗号分隔</p>
</li>
<li><p><code>--column-family</code><br/><br>指定导入数据所属的列簇，每次导入数据只能导入属于同一个<code>列簇</code> 的数据，如果 mysql 表中数据属于多个 <code>列簇</code>，只能通过多条指令分批导入。</p>
</li>
</ol>
<p><strong><em>注意：上述指令没有指定列分隔符和行分隔符，默认的列分隔符是 <code>&#39;\001&#39;</code>，在less 中显示是 <code>^A</code>；默认的行分隔符是 <code>&#39;\n&#39;</code>。</em></strong></p>
]]></content>
      <categories>
        <category>HBase</category>
      </categories>
      <tags>
        <tag>HBase</tag>
        <tag>Sqoop</tag>
      </tags>
  </entry>
  <entry>
    <title>golang GC</title>
    <url>/2018/05/16/%E6%8A%80%E6%9C%AF/golang/2018-05-16-golang-GC/</url>
    <content><![CDATA[<h3 id="golang-GC-浅谈"><a href="#golang-GC-浅谈" class="headerlink" title="golang GC 浅谈"></a>golang GC 浅谈</h3><p>Garbage collector (GC).</p>
<pre><code>    The GC runs concurrently with mutator threads, is type accurate (aka precise), allows multiple GC thread to run in parallel. It is a concurrent mark and sweep that uses a write barrier.</code></pre>
<p>golang 的 GC 和工作线程并行运行，*?类型准确？*，允许多个GC 线程并发运行, 通过 <code>write barrier</code> 实现并发的标记清除。</p>
<pre><code>            It is non-generational and non-compacting. Allocation is done using size segregated per P allocation areas to minimize fragmentation while eliminating locks in the common case.</code></pre>
<p>golang GC 不分代，不压缩。 golang 在分配内存的时候是预先将内存划分为固定大小的内存块，以尽量减少碎片，同时消除常见情况下的锁定。</p>
<pre><code>            The algorithm decomposes into several steps.
            This is a high level description of the algorithm being used. For an overview of GC a good place to start is Richard Jones&#39; gchandbook.org.</code></pre>
<p>gc 算法被分解成多个步骤<br>这里是对 <code>垃圾回收</code> 算法的高度概括，对于 <code>垃圾回收</code> 算法的综述和入门学习的资料是 <code>Richard Jones</code> 的 <a href="http://gchandbook.org/" title="gchandbook.org">gchandbook.org</a></p>
<pre><code>            The algorithm&#39;s intellectual heritage includes Dijkstra&#39;s on-the-fly algorithm, see
            Edsger W. Dijkstra, Leslie Lamport, A. J. Martin, C. S. Scholten, and E. F. M. Steffens. 1978.
            On-the-fly garbage collection: an exercise in cooperation. Commun. ACM 21, 11 (November 1978),
            966-975.
            For journal quality proofs that these steps are complete, correct, and terminate see
            Hudson, R., and Moss, J.E.B. Copying Garbage Collection without stopping the world.
            Concurrency and Computation: Practice and Experience 15(3-5), 2003.


            1. GC performs sweep termination.</code></pre>
<p>gc 执行清除</p>
<pre><code>            a. Stop the world. This causes all Ps to reach a GC safe-point.</code></pre>
<p><code>SWT</code>(Stop the word)：使所有用户线程到达一个 <code>GC</code> 安全点</p>
<pre><code>            b. Sweep any unswept spans. There will only be unswept spans if this GC cycle was forced before the expected time.



            2. GC performs the &quot;mark 1&quot; sub-phase. In this sub-phase, Ps are
            allowed to locally cache parts of the work queue.

                 a. Prepare for the mark phase by setting gcphase to \_GCmark
                 (from \_GCoff), enabling the write barrier, enabling mutator
                 assists, and enqueueing root mark jobs. No objects may be
                 scanned until all Ps have enabled the write barrier, which is
                 accomplished using STW.

                 b. Start the world. From this point, GC work is done by mark
                 workers started by the scheduler and by assists performed as
                 part of allocation. The write barrier shades both the
                 overwritten pointer and the new pointer value for any pointer
                 writes (see mbarrier.go for details). Newly allocated objects
                 are immediately marked black.

                 c. GC performs root marking jobs. This includes scanning all
                 stacks, shading all globals, and shading any heap pointers in
                 off-heap runtime data structures. Scanning a stack stops a
                 goroutine, shades any pointers found on its stack, and then
                 resumes the goroutine.

                 d. GC drains the work queue of grey objects, scanning each grey
                 object to black and shading all pointers found in the object
                 (which in turn may add those pointers to the work queue).</code></pre>
<p><code>write barrier</code>: 写屏障</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>gc</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 环境变量和 golang 脚本工具</title>
    <url>/2018/01/10/%E6%8A%80%E6%9C%AF/golang/golang%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8C%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="golang-环境变量"><a href="#golang-环境变量" class="headerlink" title="golang 环境变量"></a>golang 环境变量</h1><p>想要了解 go 的环境变量，我们可以通过 <code>go help environment</code> 指令来查看详细介绍，这里尝试翻译这一些详细介绍，并给出一些个人的认识，如有错漏，欢迎指正</p>
<h2 id="通用环境变量-General-purpose-environment-variables"><a href="#通用环境变量-General-purpose-environment-variables" class="headerlink" title="通用环境变量(General-purpose environment variables)"></a>通用环境变量(General-purpose environment variables)</h2><h3 id="GCCGO"><a href="#GCCGO" class="headerlink" title="GCCGO"></a>GCCGO</h3><p><code>gccgo</code> 属于 <code>gcc</code> 编译器集合，是 <code>gcc</code> 针对go 语言的前端实现；<code>gccgo</code> 的编译速度比gc较慢一点，但是可以生成更优的代码，因此程序执行速度会更快。<br>golang 的默认编译器是 <code>gc</code>, <code>gc</code> 编译器已支持主流的处理器，而 <code>gccgo</code> 也对 <code>gc</code> 不支持的处理器进行了支持测试；<br>通过Go正式版本安装的go命令已经可以支持 <code>gccgo</code>，需要使用 -compiler选项：<code>go build -compiler=gccgo</code> 。<br>对于用户，如果需要更好编译优化，或者是使用 <code>gc</code> 所不支持的处理器或操作系统，<code>gccgo</code> 可能是一个更好的选择。</p>
<h3 id="GOARCH"><a href="#GOARCH" class="headerlink" title="GOARCH"></a>GOARCH</h3><p>编译源代码的机器的处理器架构，它的值可以是 386、amd64 或 arm。</p>
<h3 id="GOBIN"><a href="#GOBIN" class="headerlink" title="GOBIN"></a>GOBIN</h3><p><code>go install</code> 编译出来的可执行文件的存放位置，<code>GOBIN</code> 的默认值是<code>GOPATH/bin</code><br>如果 <code>GOBIN</code> 设置了值，编译出来的可执行脚本将放置到到 <code>GOBIN</code> 设置的文件夹，而不是 .go 文件所在的src 文件夹同级的 bin 文件夹</p>
<h3 id="GOOS"><a href="#GOOS" class="headerlink" title="GOOS"></a>GOOS</h3><p>编译源代码的机器的操作系统, 它的值可以是 linux, darwin, windows, netbsd。</p>
<h3 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h3><p><code>GOPATH</code> 列举了机器上所有go代码所在位置，在Unix系统中，该值是以冒号分隔的字符串。<br>在Unix 系统中<code>GOPATH</code> 默认值是 <code>%HOME/go</code>， windows 系统中默认值是 <code>%USERPROFILE%\go</code><br><code>GOPATH</code> 中文件夹结构如下:</p>
<pre><code>            GOPATH=/home/user/go

            /home/user/go/
             src/
                 foo/
                     bar/               (go code in package bar)
                         x.go
                     quux/              (go code in package main)
                         y.go
             bin/
                 quux                   (installed command)
             pkg/
                 linux_amd64/
                     foo/
                         bar.a          (installed package object)</code></pre>
<p><code>src</code>: 存放 go 源文件<br><code>bin</code>: package main 中的go 文件编译之后产生的可执行文件存放位置<br><code>pkg</code>: 非 package main 中的go 文件编译之后产生的静态库文件(*.a)存放位置</p>
<p>设计开发中，需要将所有存放go 代码的位置都添加到 <code>GOPATH</code> 中去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export GOPATH&#x3D;:</span><br></pre></td></tr></table></figure>

<h3 id="GORACE"><a href="#GORACE" class="headerlink" title="GORACE"></a>GORACE</h3><p>竞争监测相关参数，详见 <a href="https://golang.org/doc/articles/race_detector.html">https://golang.org/doc/articles/race_detector.html</a>.<br><em>待补充</em></p>
<h3 id="GOROOT"><a href="#GOROOT" class="headerlink" title="GOROOT"></a>GOROOT</h3><p>go 安装目录</p>
<h3 id="GOTMPDIR"><a href="#GOTMPDIR" class="headerlink" title="GOTMPDIR"></a>GOTMPDIR</h3><p>The directory where the go command will write<br>temporary source files, packages, and binaries.</p>
<h3 id="GOCACHE"><a href="#GOCACHE" class="headerlink" title="GOCACHE"></a>GOCACHE</h3><p>存放go 编译系统编译过程中产生的缓存文件，如果这个文件过大，可以执行 <code>go clean --cache</code> 去清理这个文件夹</p>
<h2 id="cgo-相关环境变量"><a href="#cgo-相关环境变量" class="headerlink" title="cgo 相关环境变量"></a>cgo 相关环境变量</h2><h3 id="CC"><a href="#CC" class="headerlink" title="CC"></a>CC</h3><p><code>cgo</code> 编译 c语言代码时候使用的编译器, 需要用户额外安装</p>
<h3 id="CGO-ENABLED"><a href="#CGO-ENABLED" class="headerlink" title="CGO_ENABLED"></a>CGO_ENABLED</h3><p>是否支持 cgo， 取值是 0 或者 1</p>
<h3 id="CGO-CFLAGS"><a href="#CGO-CFLAGS" class="headerlink" title="CGO_CFLAGS"></a>CGO_CFLAGS</h3><p>cgo 编译 c 代码时传递的参数</p>
<h3 id="CGO-CFLAGS-ALLOW"><a href="#CGO-CFLAGS-ALLOW" class="headerlink" title="CGO_CFLAGS_ALLOW"></a>CGO_CFLAGS_ALLOW</h3><p>出于安全考虑，cgo 编译 c 代码时只能允许有限的参数， <code>CGO_CFLAGS_ALLOW</code> 的取值是一个 <code>正则表达式</code>，涵盖所有允许的参数名称</p>
<h3 id="CGO-CFLAGS-DISALLOW"><a href="#CGO-CFLAGS-DISALLOW" class="headerlink" title="CGO_CFLAGS_DISALLOW"></a>CGO_CFLAGS_DISALLOW</h3><p>和 <code>CGO_CFLAGS_ALLOW</code> 相反，<code>CGO_CFLAGS_ALLOW</code> 的取值也是一个 <code>正则表达式</code>，涵盖所有不允许的参数名称</p>
<h3 id="CGO-CPPFLAGS-CGO-CPPFLAGS-ALLOW-CGO-CPPFLAGS-DISALLOW"><a href="#CGO-CPPFLAGS-CGO-CPPFLAGS-ALLOW-CGO-CPPFLAGS-DISALLOW" class="headerlink" title="CGO_CPPFLAGS, CGO_CPPFLAGS_ALLOW, CGO_CPPFLAGS_DISALLOW"></a>CGO_CPPFLAGS, CGO_CPPFLAGS_ALLOW, CGO_CPPFLAGS_DISALLOW</h3><p>类似于 <code>CGO_CFLAGS</code>, <code>CGO_CFLAGS_ALLOW</code>, <code>CGO_CFLAGS_DISALLOW</code>, 不过是用于 <code>c</code> 预处理器</p>
<h3 id="CGO-CXXFLAGS-CGO-CXXFLAGS-ALLOW-CGO-CXXFLAGS-DISALLOW"><a href="#CGO-CXXFLAGS-CGO-CXXFLAGS-ALLOW-CGO-CXXFLAGS-DISALLOW" class="headerlink" title="CGO_CXXFLAGS, CGO_CXXFLAGS_ALLOW, CGO_CXXFLAGS_DISALLOW"></a>CGO_CXXFLAGS, CGO_CXXFLAGS_ALLOW, CGO_CXXFLAGS_DISALLOW</h3><p>类似于 <code>CGO_CFLAGS</code>, <code>CGO_CFLAGS_ALLOW</code>, <code>CGO_CFLAGS_DISALLOW</code>, 不过是用于 <code>c++</code> 编译器</p>
<h3 id="CGO-FFLAGS-CGO-FFLAGS-ALLOW-CGO-FFLAGS-DISALLOW"><a href="#CGO-FFLAGS-CGO-FFLAGS-ALLOW-CGO-FFLAGS-DISALLOW" class="headerlink" title="CGO_FFLAGS, CGO_FFLAGS_ALLOW, CGO_FFLAGS_DISALLOW"></a>CGO_FFLAGS, CGO_FFLAGS_ALLOW, CGO_FFLAGS_DISALLOW</h3><p>类似于 <code>CGO_CFLAGS</code>, <code>CGO_CFLAGS_ALLOW</code>, <code>CGO_CFLAGS_DISALLOW</code>, 不过是用于 <code>Fortran</code> 编译器</p>
<h3 id="CGO-LDFLAGS-CGO-LDFLAGS-ALLOW-CGO-LDFLAGS-DISALLOW"><a href="#CGO-LDFLAGS-CGO-LDFLAGS-ALLOW-CGO-LDFLAGS-DISALLOW" class="headerlink" title="CGO_LDFLAGS, CGO_LDFLAGS_ALLOW, CGO_LDFLAGS_DISALLOW"></a>CGO_LDFLAGS, CGO_LDFLAGS_ALLOW, CGO_LDFLAGS_DISALLOW</h3><p>类似于 <code>CGO_CFLAGS</code>, <code>CGO_CFLAGS_ALLOW</code>, <code>CGO_CFLAGS_DISALLOW</code>, 不过是用于 <code>c</code> 链接器</p>
<h3 id="CXX"><a href="#CXX" class="headerlink" title="CXX"></a>CXX</h3><p>cgo 编译 <code>C++</code>的编译器</p>
<h3 id="PKG-CONFIG"><a href="#PKG-CONFIG" class="headerlink" title="PKG_CONFIG"></a>PKG_CONFIG</h3><p>取值是 指向 <code>pkg_config</code> 工具的绝对路径</p>
<h2 id="架构相关的特殊目的的环境变量"><a href="#架构相关的特殊目的的环境变量" class="headerlink" title="架构相关的特殊目的的环境变量"></a>架构相关的特殊目的的环境变量</h2><h3 id="GOARM"><a href="#GOARM" class="headerlink" title="GOARM"></a>GOARM</h3><p>当 <code>GOARCH=arm</code> 时，arm 架构的处理器，它的取值是 5,6,7</p>
<h3 id="GO386"><a href="#GO386" class="headerlink" title="GO386"></a>GO386</h3><p>当 <code>GOARCH=386</code> 时，浮点指令集，它的取值是  387, sse2</p>
<h3 id="GOMIPS"><a href="#GOMIPS" class="headerlink" title="GOMIPS"></a>GOMIPS</h3><p>当 <code>GOARCH=mips&#123;,le&#125;</code> 时，指定是软浮点还是硬浮点</p>
<h2 id="特殊目的的环境变量"><a href="#特殊目的的环境变量" class="headerlink" title="特殊目的的环境变量"></a>特殊目的的环境变量</h2><h3 id="GOROOT-FINAL"><a href="#GOROOT-FINAL" class="headerlink" title="GOROOT_FINAL"></a>GOROOT_FINAL</h3><p>当go 根目录和go 安装目录不一致时，将 <code>GOROOT_FINAL</code> 设置为go 的根目录</p>
<h3 id="GIT-ALLOW-PROTOCOL"><a href="#GIT-ALLOW-PROTOCOL" class="headerlink" title="GIT_ALLOW_PROTOCOL"></a>GIT_ALLOW_PROTOCOL</h3><p><code>go get</code> 指令使用 <code>git fetch/clone</code> 获取 go 代码的时候允许使用的 <code>schema</code>, 多个 <code>schema</code> 用冒号分割；<br>如果 <code>GIT_ALLOW_PROTOCOL</code> 不包含某个 <code>schema</code>， <code>go get</code> 认为它是不安全的</p>
<h3 id="GO-EXTLINK-ENABLED"><a href="#GO-EXTLINK-ENABLED" class="headerlink" title="GO_EXTLINK_ENABLED"></a>GO_EXTLINK_ENABLED</h3><p>Whether the linker should use external linking mode<br>when using -linkmode=auto with code that uses cgo.<br>Set to 0 to disable external linking mode, 1 to enable it.</p>
<h1 id="go-提供的脚本工具"><a href="#go-提供的脚本工具" class="headerlink" title="go 提供的脚本工具"></a>go 提供的脚本工具</h1><h1 id="gofmt"><a href="#gofmt" class="headerlink" title="gofmt"></a>gofmt</h1><p>格式化 go 语言代码</p>
<pre><code>            使用示例: gofmt [flags] [path ...]
            -cpuprofile string
                write cpu profile to this file
            -d    在控制台输出格式化后的代码和源代码的对比
            -e    report all errors (not just the first 10 on different lines)
            -l    list files whose formatting differs from gofmt&#39;s
            -r string
                重写规则，如 &#39;a[b:len(a)] -&gt; a[b:]&#39; 将 `a[b:len(a)]` 替换成 `a[b:len(a)]`
            -s    简化源代码
            -w    将格式化结果写回源文件，而不是输出到控制台</code></pre>
<h3 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h3><h3 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a>go get</h3><h3 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h3><h4 id="交叉编译-cross-compile"><a href="#交叉编译-cross-compile" class="headerlink" title="交叉编译 (cross compile)"></a>交叉编译 (cross compile)</h4><p>Golang 支持交叉编译，在一个平台上生成另一个平台的可执行程序，这里备忘一下。</p>
<p>Mac 下编译 Linux 和 Windows 64位可执行程序</p>
<pre><code>            CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go
            CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go</code></pre>
<p>Linux 下编译 Mac 和 Windows 64位可执行程序</p>
<pre><code>            CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build main.go
            CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go</code></pre>
<p>Windows 下编译 Mac 和 Linux 64位可执行程序</p>
<pre><code>                SET CGO_ENABLED=0
                SET GOOS=darwin
                SET GOARCH=amd64
                go build main.go

                SET CGO_ENABLED=0
                SET GOOS=linux
                SET GOARCH=amd64
                go build main.go</code></pre>
<p>GOOS：目标平台的操作系统（darwin、freebsd、linux、windows）<br>GOARCH：目标平台的体系架构（386、amd64、arm）<br>交叉编译不支持 CGO 所以要禁用它</p>
<h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3>]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 内存管理浅析</title>
    <url>/2018/05/16/%E6%8A%80%E6%9C%AF/golang/golang%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong><em>从一个问题和回复开始了解 go语言内存管理</em></strong></p>
<h3 id="How-do-I-know-whether-a-variable-is-allocated-on-the-heap-or-the-stack"><a href="#How-do-I-know-whether-a-variable-is-allocated-on-the-heap-or-the-stack" class="headerlink" title="How do I know whether a variable is allocated on the heap or the stack?"></a>How do I know whether a variable is allocated on the heap or the stack?</h3><pre><code>    From a correctness standpoint, you don&#39;t need to know. Each variable in Go exists as long as there are references to it. The storage location chosen by the implementation is irrelevant to the semantics of the language.

    The storage location does have an effect on writing efficient programs. When possible, the Go compilers will allocate variables that are local to a function in that function&#39;s stack frame. However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors. Also, if a local variable is very large, it might make more sense to store it on the heap rather than the stack.

    In the current compilers, if a variable has its address taken, that variable is a candidate for allocation on the heap. However, a basic escape analysis recognizes some cases when such variables will not live past the return from the function and can reside on the stack.</code></pre>
<p>从 <a href="https://golang.org/doc/faq" title="go 语言官网">go语言官网</a> 的问题列表中有上面这个问题，简单翻译如下</p>
<h3 id="我们如何知道变量是分配在堆上还是栈上？"><a href="#我们如何知道变量是分配在堆上还是栈上？" class="headerlink" title="我们如何知道变量是分配在堆上还是栈上？"></a>我们如何知道变量是分配在堆上还是栈上？</h3><pre><code>明确地说，你不需要知道答案。 go语言的每个变量当它存在引用的时候它就会一直存在，语言对存储位置的选择与语言的语义无关。

存储位置确实会影响编写高效的程序。如果可能，Go编译器将在函数的栈中给本地变量分配存储空间。但是，如果编译器在函数返回后无法证明变量未被引用，则编译器必须在堆上分配变量以避免空指针。此外，如果局部变量非常大，将它存储在堆而不是栈上可能更有意义。

在当前主流的编译器中，如果变量有其他访问地址，则该变量是堆上分配的候选变量。但是，基本的逃逸分析可以识别某些情况，这些生命周期只在函数周期内的变量将分配在栈上。</code></pre>
<p>这个问题和答案告诉我们两个事情，一个是简单介绍了 <code>逃逸分析</code>，另一个就是 go语言官方开发者不认为我们需要了解 <code>内存分配</code>，现在我们需要去了解 <code>逃逸分析</code> 和 <code>内存管理</code>。</p>
<h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>先看看 <code>维基百科</code> 上关于 <code>逃逸分析</code> 的说明</p>
<pre><code>    「逃逸分析」是编译程序优化理论中确定指针动态范围的方法 ———— 分析程序哪些地方可以访问指针，它涉及到指针分析和形状分析。
    当一个变量在子程序中被分配时，一个指向变量的指针可能会逃逸到其它执行程序中，或者去调用子程序。如果使用尾递归优化（通常在函数编程语言中是需要的），对象也可能逃逸到被调用的子程序中。 如果一个子程序分配一个对象并返回一个该对象的指针，该对象可能在程序中的任何一个地方被访问到——这样指针就成功“逃逸”了。如果指针存储在全局变量或者其它数据结构中，它们也可能发生逃逸，这种情况是当前程序中的指针逃逸。 逃逸分析需要确定指针所有可以存储的地方，保证指针的生命周期只在当前进程或线程中。</code></pre>
<h3 id="golang-逃逸分析示例"><a href="#golang-逃逸分析示例" class="headerlink" title="golang 逃逸分析示例"></a>golang 逃逸分析示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go run -gcflags=&quot;-m -l&quot; escape_ayalysis_demo.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := returnString1()</span><br><span class="line">    s2 := returnStringPrt1()</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;s1:&quot;</span>, s1, <span class="string">&quot;, addr: &quot;</span>, &amp;s1, <span class="string">&quot;\ns2:&quot;</span>, s2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnString1</span><span class="params">()</span> <span class="params">(rs1 <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    rs1 = <span class="string">&quot;this is a variable in func will return&quot;</span></span><br><span class="line">    <span class="built_in">println</span>(rs1)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnStringPrt1</span><span class="params">()</span> <span class="params">(sp1 *<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    rspt1 := <span class="string">&quot;this is a variable in func will return&quot;</span></span><br><span class="line">    <span class="built_in">println</span>(rspt1)</span><br><span class="line">    <span class="keyword">return</span> &amp;rspt1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们使用 <code>go:noinline</code> 来禁止编译器使用内联代码来替换函数调用，<br/><br>然后我们使用  <code>gcflags=&quot;-m -m&quot;</code> 来查看编译器报告，<code>gcflags</code> 最多可以有四个 <code>-m</code>, 一般来说两个 <code>-m</code> 的信息已经足够了</p>
<pre><code>    &gt; go run -gcflags=&quot;-m -m&quot; escape_ayalysis_demo.go
    # command-line-arguments
    ./escape_ayalysis_demo.go:11:6: cannot inline returnString1: marked go:noinline
    ./escape_ayalysis_demo.go:18:6: cannot inline returnStringPrt1: marked go:noinline
    ./escape_ayalysis_demo.go:4:6: cannot inline main: non-leaf function
    ./escape_ayalysis_demo.go:21:9: &amp;rspt1 escapes to heap
    ./escape_ayalysis_demo.go:21:9:         from sp1 (return) at ./escape_ayalysis_demo.go:21:2
    ./escape_ayalysis_demo.go:19:2: moved to heap: rspt1
    ./escape_ayalysis_demo.go:7:33: main &amp;s1 does not escape
    this is a variable in func will return
    this is a variable in func will return
    s1: this is a variable in func will return , addr:  0xc42005ff68
    s2: 0xc42000e020</code></pre>
<p>这里可以看到函数 <code>returnString1</code> 中没有发生逃逸，因为 <code>returnString1</code> 的返回值类型是 <code>string</code>, <code>main</code> 函数通过值复制将 <code>rs1</code> 的值复制一份而得到 <code>s1</code>；<br>而函数 <code>returnStringPrt1</code> 的返回值是 <code>string</code> 类型的指针，在 <code>main</code> 函数中调用了 <code>returnStringPrt1</code> 时，可以访问指针 <code>sp1</code> 指向的变量，此时指针 <code>sp1</code> 和指针 <code>s2</code> 指向同一个变量，因此变量 <code>rspt1</code> 分配在堆空间中。</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>Memory allocator.<br>内存分配</p>
<p>This was originally based on tcmalloc, but has diverged quite a bit.<br><code>golang</code> 的内存分配的方法是在 <code>TCMalloc</code> 的基础上进行了一些改动，<code>TCMalloc(Thread-caching Malloc)</code> 介绍请看<br><a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">http://goog-perftools.sourceforge.net/doc/tcmalloc.html</a></p>
<h3 id="TCMalloc-Thread-caching-Malloc"><a href="#TCMalloc-Thread-caching-Malloc" class="headerlink" title="TCMalloc(Thread-caching Malloc)"></a><code>TCMalloc(Thread-caching Malloc)</code></h3><p><code>TCMalloc</code> 分配的内存主要是两个地方：<code>线程私有缓存(Thread Local Cache)</code> 和 <code>全局缓存堆（Central Heap）</code>；<br><code>TCMalloc</code> 为每个线程分配一个私有缓存，把 &lt;=32k 的对象视为 <code>小对象(Small Object)</code>，小对象的的内存分配先尝试从线程私有缓存上分配，如果线程私有缓存空间不足，再从全局缓存堆中申请一部分空间作为线程私有缓存，而周期性的垃圾回收会将线程私有缓存的空间归还给全局缓存堆；而大于 32k 的对象视为 <code>大对象(Large Object)</code>，大对象的分配直接在全局缓存堆上；</p>
<h3 id="小对象内存分配（Small-Object-Allocation）"><a href="#小对象内存分配（Small-Object-Allocation）" class="headerlink" title="小对象内存分配（Small Object Allocation）"></a>小对象内存分配（Small Object Allocation）</h3><p>线程本地缓存是一个单向链表 L1，链表 L1 的每个元素也是一个具有相同大小的空间对象的链表 l<sub>n</sub></p>
<p><img src="/assets/picture/theadheap.gif" title="Thread Local Cache Heap"></p>
<p><code>TCMalloc</code> 将线程本地缓存拆分成约170种大小类型的空闲对象列表，依次以 8bytes、16bytes、32bytes等大小递增</p>
<p>小对象内存分配具体步骤如下：</p>
<ol>
<li>计算对象大小，找到大于对象大小的最小的大小类型 m；</li>
<li>在当前线程中找到该大小类型的空闲对象链表 l<sub>m</sub>；</li>
<li>如果链表 l<sub>m</sub> 不为空，从链表中删除第一个空闲对象用于内存分配；这个操作过程中，<code>TCMalloc</code> 不需要加锁，这个对提高内存分配的效率很有帮助；</li>
<li>如果链表 l<sub>m</sub> 为空，从所有线程共享的 <code>Central Free List</code> 中获取一堆空闲对象，放到当前线程的私有缓存队列上去，在重复步骤3，从线程私有缓存中返回一个空闲对象</li>
</ol>
<p>The main allocator works in runs of pages.<br>Small allocation sizes (up to and including 32 kB) are<br>rounded to one of about 70 size classes, each of which<br>has its own free set of objects of exactly that size.<br>Any free page of memory can be split into a set of objects<br>of one size class, which are then managed using a free bitmap.</p>
<p>主要的内存分配器是工作在运行中的 <strong><em>?内存页?</em></strong> 上。<br>小对象分配的</p>
<p>golang 将内存切分成约70种固定大小的内存块，me</p>
<p>The allocator’s data structures are:</p>
<p>fixalloc: a free-list allocator for fixed-size off-heap objects,<br>    used to manage storage used by the allocator.<br>mheap: the malloc heap, managed at page (8192-byte) granularity.<br>mspan: a run of pages managed by the mheap.<br>mcentral: collects all spans of a given size class.<br>mcache: a per-P cache of mspans with free space.<br>mstats: allocation statistics.</p>
<p>Allocating a small object proceeds up a hierarchy of caches:</p>
<ol>
<li><p>Round the size up to one of the small size classes<br>and look in the corresponding mspan in this P’s mcache.<br>Scan the mspan’s free bitmap to find a free slot.<br>If there is a free slot, allocate it.<br>This can all be done without acquiring a lock.</p>
</li>
<li><p>If the mspan has no free slots, obtain a new mspan<br>from the mcentral’s list of mspans of the required size<br>class that have free space.<br>Obtaining a whole span amortizes the cost of locking<br>the mcentral.</p>
</li>
<li><p>If the mcentral’s mspan list is empty, obtain a run<br>of pages from the mheap to use for the mspan.</p>
</li>
<li><p>If the mheap is empty or has no page runs large enough,<br>allocate a new group of pages (at least 1MB) from the<br>operating system. Allocating a large run of pages<br>amortizes the cost of talking to the operating system.</p>
</li>
</ol>
<p>Sweeping an mspan and freeing objects on it proceeds up a similar<br>hierarchy:</p>
<ol>
<li><p>If the mspan is being swept in response to allocation, it<br>is returned to the mcache to satisfy the allocation.</p>
</li>
<li><p>Otherwise, if the mspan still has allocated objects in it,<br>it is placed on the mcentral free list for the mspan’s size<br>class.</p>
</li>
<li><p>Otherwise, if all objects in the mspan are free, the mspan<br>is now “idle”, so it is returned to the mheap and no longer<br>has a size class.<br>This may coalesce it with adjacent idle mspans.</p>
</li>
<li><p>If an mspan remains idle for long enough, return its pages<br>to the operating system.</p>
</li>
</ol>
<p>Allocating and freeing a large object uses the mheap<br>directly, bypassing the mcache and mcentral.</p>
<p>Free object slots in an mspan are zeroed only if mspan.needzero is<br>false. If needzero is true, objects are zeroed as they are<br>allocated. There are various benefits to delaying zeroing this way:</p>
<ol>
<li><p>Stack frame allocation can avoid zeroing altogether.</p>
</li>
<li><p>It exhibits better temporal locality, since the program is<br>probably about to write to the memory.</p>
</li>
<li><p>We don’t zero pages that never get reused.</p>
</li>
</ol>
<p>P: 运行是管理 G 并把他们映射到 Logical Processor，称之为P；P可以看作是一个抽象的资源或者一个上下文，它需要获取以便操作系统线程(称之为M)可以运行G。<br>M: 操作系统线程<br>G: goroutine，golang 中比线程还要轻量级的协程</p>
<p><code>fixalloc</code>: 固定大小的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> fixalloc <span class="keyword">struct</span> &#123;</span><br><span class="line">    size   <span class="keyword">uintptr</span>  <span class="comment">// 固定</span></span><br><span class="line">    first  <span class="function"><span class="keyword">func</span><span class="params">(arg, p unsafe.Pointer)</span> // <span class="title">called</span> <span class="title">first</span> <span class="title">time</span> <span class="title">p</span> <span class="title">is</span> <span class="title">returned</span></span></span><br><span class="line">    arg    unsafe.Pointer</span><br><span class="line">    list   *mlink</span><br><span class="line">    chunk  <span class="keyword">uintptr</span> <span class="comment">// use uintptr instead of unsafe.Pointer to avoid write barriers</span></span><br><span class="line">    nchunk <span class="keyword">uint32</span></span><br><span class="line">    inuse  <span class="keyword">uintptr</span> <span class="comment">// in-use bytes now</span></span><br><span class="line">    stat   *<span class="keyword">uint64</span></span><br><span class="line">    zero   <span class="keyword">bool</span> <span class="comment">// zero allocations</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 性能监控和故障处理工具</title>
    <url>/2016/09/12/%E6%8A%80%E6%9C%AF/java/2016-09-12-JVM%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h3 id="jps-JVM-Process-Status-Tool"><a href="#jps-JVM-Process-Status-Tool" class="headerlink" title="jps (JVM Process Status Tool)"></a>jps (JVM Process Status Tool)</h3><h4 id="显示指定系统中的所有虚拟机进程"><a href="#显示指定系统中的所有虚拟机进程" class="headerlink" title="显示指定系统中的所有虚拟机进程"></a>显示指定系统中的所有虚拟机进程</h4><pre><code>&gt; jps [ options ] [ hostid ]</code></pre>
<p><img src="/assets/picture/jps_help.png" alt="图片" title="JPS 指令说明"></p>
<p>jps 选项 [ options ] 说明：</br><br>-q 只输出LVMID 省略主类的名称；</br><br>-m 输出虚拟机进程启东市传递给主类main函数的参数；</br><br>-l 输出主类的名称，如果进程执行的是jar包，输出jar 路径；</br><br>-v 输出虚拟机进程启动时的JVM 参数</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="[ 注意 ]"></a>[ 注意 ]</h4><p>使用 jps 指令得到的输出结果可能是下面这样的</p>
<pre><code>pid -- process information unavailable</code></pre>
<p>JVM 会在本地文件系统中的 tmp 文件夹中新建 <code>hsperfdata_&#123;username&#125;/&#123;pid&#125;</code> 文件， 如果当前执行 jps 指令的用户没有属于自己的这个文件，就会出现这种提示</p>
<p>例如： 我们公司tomcat 的启动用户默认是 <code>tomcat</code>,  JVM 新建的文件是 <code>/tmp/hsperfdata_tomcat/pid</code>(这是在linux系统中)，这样导致了如下问题</p>
<h6 id="不管使用-root-用户权限还是-普通用户权限都不能执行-jps-指令"><a href="#不管使用-root-用户权限还是-普通用户权限都不能执行-jps-指令" class="headerlink" title="不管使用 root 用户权限还是 普通用户权限都不能执行 jps 指令"></a>不管使用 root 用户权限还是 普通用户权限都不能执行 jps 指令</h6><h5 id="上述问题解决方案"><a href="#上述问题解决方案" class="headerlink" title="上述问题解决方案"></a>上述问题解决方案</h5><pre><code>sudo -u tomcat jps pid</code></pre>
<hr>
<h3 id="jstat-JVM-Statistics-Monitoring-Tool"><a href="#jstat-JVM-Statistics-Monitoring-Tool" class="headerlink" title="jstat (JVM Statistics Monitoring Tool)"></a>jstat (JVM Statistics Monitoring Tool)</h3><pre><code> &gt; jstat [ option vmid [interval [s|ms] [count]]  ]</code></pre>
<p>参数  <code>interval</code>, <code>count</code> 代表查询的间隔时间和次数，如果省略这两个参数表示只查询一次<br>假设需要每 1s 查询一次进程 3234 的jvm gc信息，一共查询10次</p>
<pre><code>&gt; jstat -gc 3234 1s 10</code></pre>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th>作用描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-class</td>
<td>监视类装载、卸载数量、总空间以及类装载所耗费的时间</td>
</tr>
<tr>
<td align="left">-gc</td>
<td>监视 JVM 堆状况，包括 Eden区、两个survivor 区、老年代、永生代等的容量、已用空间、GC时间合计等信息</td>
</tr>
<tr>
<td align="left">-gccapacity</td>
<td>监视内容与 -gc 基本相同，但输出主要关注java 堆各个区域使用到的最大、最小空间</td>
</tr>
<tr>
<td align="left">-gcutil</td>
<td>监视内容与 -gc 基本相同，但输出主要关注已经使用空间占总空间的百分比</td>
</tr>
<tr>
<td align="left">-gccause</td>
<td>与 -gcutil 功能一样，但是会额外输出导致上一次 GC 产生的原因</td>
</tr>
<tr>
<td align="left">-gcnew</td>
<td>监视新生代 gc 状况</td>
</tr>
<tr>
<td align="left">-gcnewcapacity</td>
<td>监视内容与 -gcnew 基本相同，但输出主要关注新生代已经使用到的最大、最小空间</td>
</tr>
<tr>
<td align="left">-gcold</td>
<td>监视老年代 gc 状况</td>
</tr>
<tr>
<td align="left">-gcoldcapacity</td>
<td>监视内容与 -gcold 基本相同，但输出主要关注老年代已经使用到的最大、最小空间</td>
</tr>
<tr>
<td align="left">-gcpermcapacity</td>
<td>输出永久代已经使用到的最大、最小空间</td>
</tr>
<tr>
<td align="left">-compiler</td>
<td>输出JIT 编译器编译过的方法、耗时等信息</td>
</tr>
<tr>
<td align="left">-gccompilation</td>
<td>输出已经呗 JIT 编译的方法</td>
</tr>
</tbody></table>
<hr>
<h3 id="jinfo-Configuration-Info-for-java"><a href="#jinfo-Configuration-Info-for-java" class="headerlink" title="jinfo (Configuration Info for java)"></a>jinfo (Configuration Info for java)</h3><h4 id="实时查询和调整虚拟机各项参数"><a href="#实时查询和调整虚拟机各项参数" class="headerlink" title="实时查询和调整虚拟机各项参数"></a>实时查询和调整虚拟机各项参数</h4><pre><code>&gt; jinfo [ option ] pid

liam@liamchen-ubuntu:~$ jinfo -help
Usage:
    jinfo [option] &lt;pid&gt;
        (to connect to running process)
    jinfo [option] &lt;executable &lt;core&gt;
        (to connect to a core file)
    jinfo [option] [server_id@]&lt;remote server IP or hostname&gt;
        (to connect to remote debug server)

where &lt;option&gt; is one of:
    -flag &lt;name&gt;         to print the value of the named VM flag
    -flag [+|-]&lt;name&gt;    to enable or disable the named VM flag
    -flag &lt;name&gt;=&lt;value&gt; to set the named VM flag to the given value
    -flags               to print VM flags
    -sysprops            to print Java system properties
    &lt;no option&gt;          to print both of the above
    -h | -help           to print this help message</code></pre>
<hr>
<h3 id="jmap-Memory-Map-for-Java"><a href="#jmap-Memory-Map-for-Java" class="headerlink" title="jmap (Memory Map for Java)"></a>jmap (Memory Map for Java)</h3><h4 id="生成对存储快照"><a href="#生成对存储快照" class="headerlink" title="生成对存储快照"></a>生成对存储快照</h4><pre><code> &gt; jmap [ option ] vmid</code></pre>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th>作用描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-dump</td>
<td>生成 JVM 堆存储快照。 格式为: dump:[live,]format=b,file=<fileName>，其中live参数说明是否只dump 出存活的对象</td>
</tr>
<tr>
<td align="left">-finalizeinfo</td>
<td>显示在F-Queue 中等待Finalizer线程执行 finalize 方法的对象，只在 linux/solaris 平台下有效</td>
</tr>
<tr>
<td align="left">-heap</td>
<td>显示 JVM 堆详细信息，如使用那种回收器、参数配置、分代情况等。只在 linux/solaris 平台下有效</td>
</tr>
<tr>
<td align="left">-histo</td>
<td>显示堆中对象统计信息，包括类、实例数量、合计数量</td>
</tr>
<tr>
<td align="left">-permstat</td>
<td>以ClassLoader为统计口径，显示永生代内存状态，只在 linux/solaris 平台下有效</td>
</tr>
<tr>
<td align="left">-F</td>
<td>当 JVM 进程对 -dump 指令选项没有响应时，可使用这个选项强制生成dump 快照，只在 linux/solaris 平台下有效</td>
</tr>
</tbody></table>
<pre><code>使用示例：
&gt; jmap -dump:format=b,file=test.dump pid</code></pre>
<hr>
<h3 id="jhat-JVM-Heap-Analysis-Tool"><a href="#jhat-JVM-Heap-Analysis-Tool" class="headerlink" title="jhat (JVM Heap Analysis Tool)"></a>jhat (JVM Heap Analysis Tool)</h3><h4 id="与jmap搭配使用，-来分析-jmap-生成的-堆存储快照文件"><a href="#与jmap搭配使用，-来分析-jmap-生成的-堆存储快照文件" class="headerlink" title="与jmap搭配使用， 来分析 jmap 生成的 堆存储快照文件"></a>与jmap搭配使用， 来分析 jmap 生成的 堆存储快照文件</h4><pre><code>&gt; jhat test.dump</code></pre>
<p>当屏幕上出现 “Server is ready” 提示后，访问 <code>http://localhost:7000</code> 就能看到分析结果</p>
<h6 id="注意-分析工作比较消耗资源，可将dump-文件复制到其他机器上分析"><a href="#注意-分析工作比较消耗资源，可将dump-文件复制到其他机器上分析" class="headerlink" title="[ 注意 ] : 分析工作比较消耗资源，可将dump 文件复制到其他机器上分析"></a>[ 注意 ] : 分析工作比较消耗资源，可将dump 文件复制到其他机器上分析</h6><hr>
<h3 id="jstack-Stack-Trace-for-Java"><a href="#jstack-Stack-Trace-for-Java" class="headerlink" title="jstack (Stack Trace for Java)"></a>jstack (Stack Trace for Java)</h3><h4 id="生成JVM-当前时刻的线程快照"><a href="#生成JVM-当前时刻的线程快照" class="headerlink" title="生成JVM 当前时刻的线程快照"></a>生成JVM 当前时刻的线程快照</h4><pre><code>&gt; jstack [ option ] vmid</code></pre>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th>作用描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-l</td>
<td>除堆栈外，显示关于锁的附加信息</td>
</tr>
<tr>
<td align="left">-m</td>
<td>打印</td>
</tr>
<tr>
<td align="left">-F</td>
<td>当 JVM 进程对指令没有响应时，可使用这个选项强制生成 threaddump 快照，只在 linux/solaris 平台下有效</td>
</tr>
</tbody></table>
<h2 id="GC-日志"><a href="#GC-日志" class="headerlink" title="GC 日志"></a>GC 日志</h2><h3 id="日志设置"><a href="#日志设置" class="headerlink" title="日志设置"></a>日志设置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">JAVA_OPTS=<span class="string">&quot;-Xms8g -Xmx16g -XX:PermSize=512m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=../logs  -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:../logs/gc.log&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized 关键字</title>
    <url>/2016/07/27/%E6%8A%80%E6%9C%AF/java/2016-07-27-synchronized%20%E5%87%A0%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<h2 id="synchronized-几种使用方法比较"><a href="#synchronized-几种使用方法比较" class="headerlink" title="synchronized 几种使用方法比较"></a>synchronized 几种使用方法比较</h2><p><code>synchronized</code> 关键字在 Java 中出现的很早， Java 提供的实现原子性的内置锁机制，就是用这个关键字实现。<br><code>synchronized</code> 关键字可以修饰方法，也可以修饰一个代码块，实现一种互斥锁，这里就不做赘述。</p>
<p>下面讨论几个问题</p>
<h3 id="synchronized-关键字修饰-非静态方法，-锁定的是对象实例还是类？"><a href="#synchronized-关键字修饰-非静态方法，-锁定的是对象实例还是类？" class="headerlink" title="synchronized 关键字修饰 非静态方法， 锁定的是对象实例还是类？"></a>synchronized 关键字修饰 非静态方法， 锁定的是对象实例还是类？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncInnerReferenceLock1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;syncInnerReferenceLock1: [count] -- &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncInnerReferenceLock2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;syncInnerReferenceLock2: [count] -- &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SyncLockDemo syncLockDemo1 = <span class="keyword">new</span> SyncLockDemo();</span><br><span class="line"></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            syncLockDemo1.syncInnerReferenceLock1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            syncLockDemo1.syncInnerReferenceLock2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中有两个用 <code>synchronized</code>  关键字修饰的非静态方法， 在两个线程中运行这两个方法， 结果如下</p>
<pre><code>    syncInnerReferenceLock2: [count] -- 0
    syncInnerReferenceLock2: [count] -- 1
    syncInnerReferenceLock2: [count] -- 2
    syncInnerReferenceLock2: [count] -- 3
    syncInnerReferenceLock2: [count] -- 4
    syncInnerReferenceLock1: [count] -- 0
    syncInnerReferenceLock1: [count] -- 1
    syncInnerReferenceLock1: [count] -- 2
    syncInnerReferenceLock1: [count] -- 3
    syncInnerReferenceLock1: [count] -- 4

    Process finished with exit code 0

或

    syncInnerReferenceLock1: [count] -- 0
    syncInnerReferenceLock1: [count] -- 1
    syncInnerReferenceLock1: [count] -- 2
    syncInnerReferenceLock1: [count] -- 3
    syncInnerReferenceLock1: [count] -- 4
    syncInnerReferenceLock2: [count] -- 0
    syncInnerReferenceLock2: [count] -- 1
    syncInnerReferenceLock2: [count] -- 2
    syncInnerReferenceLock2: [count] -- 3
    syncInnerReferenceLock2: [count] -- 4

    Process finished with exit code 0</code></pre>
<p>从结果可以看出，两个线程是串行执行的，我们可以猜测： 修饰非静态方法的 <code>synchronized</code> 关键字锁定的是这个类的对象实例，下面我们来验证这个想法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncInnerReferenceLock1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;syncInnerReferenceLock1: [count] -- &quot;</span> + i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncInnerReferenceLock2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;syncInnerReferenceLock2: [count] -- &quot;</span> + i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> SyncLockDemo syncLockDemo1 = <span class="keyword">new</span> SyncLockDemo();</span><br><span class="line">  <span class="keyword">final</span> SyncLockDemo syncLockDemo2 = <span class="keyword">new</span> SyncLockDemo();</span><br><span class="line"></span><br><span class="line">  Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          syncLockDemo1.syncInnerReferenceLock1();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          syncLockDemo2.syncInnerReferenceLock2();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  t1.start();</span><br><span class="line">  t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们创建两个对象实例， 在两个线程中分别执行两个被 <code>synchronized</code> 关键字修饰的方法， 结果如下：</p>
<pre><code>    syncInnerReferenceLock2: [count] -- 0
    syncInnerReferenceLock1: [count] -- 0
    syncInnerReferenceLock2: [count] -- 1
    syncInnerReferenceLock1: [count] -- 1
    syncInnerReferenceLock1: [count] -- 2
    syncInnerReferenceLock1: [count] -- 3
    syncInnerReferenceLock1: [count] -- 4
    syncInnerReferenceLock2: [count] -- 2
    syncInnerReferenceLock2: [count] -- 3
    syncInnerReferenceLock2: [count] -- 4

    Process finished with exit code 0</code></pre>
<p>这里可以看到，连个线程是并行执行的，没有丝毫互斥的现象，从而论证了上面的猜测！</p>
<h3 id="synchronized-关键字修饰-静态方法，-锁定的是对象实例还是类？"><a href="#synchronized-关键字修饰-静态方法，-锁定的是对象实例还是类？" class="headerlink" title="synchronized 关键字修饰 静态方法， 锁定的是对象实例还是类？"></a><code>synchronized</code> 关键字修饰 <code>静态方法</code>， 锁定的是对象实例还是类？</h3><p>看了第一个问题，我们能不能说， <code>synchronized</code> 关键字修饰 <code>静态方法</code>， 锁定的是类呢？ 让我们看看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncLock1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;syncLock1: [count] -- &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncLock2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;syncLock2: [count] -- &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            syncLock1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            syncLock2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里把 <code>1</code> 中的两个方法修改成静态方法， 在两个线程中分别执行两个方法，结果如下：</p>
<pre><code>    syncLock1: [count] -- 0
    syncLock1: [count] -- 1
    syncLock1: [count] -- 2
    syncLock1: [count] -- 3
    syncLock1: [count] -- 4
    syncLock2: [count] -- 0
    syncLock2: [count] -- 1
    syncLock2: [count] -- 2
    syncLock2: [count] -- 3
    syncLock2: [count] -- 4

    Process finished with exit code 0

或

    syncLock2: [count] -- 0
    syncLock2: [count] -- 1
    syncLock2: [count] -- 2
    syncLock2: [count] -- 3
    syncLock2: [count] -- 4
    syncLock1: [count] -- 0
    syncLock1: [count] -- 1
    syncLock1: [count] -- 2
    syncLock1: [count] -- 3
    syncLock1: [count] -- 4

    Process finished with exit code 0</code></pre>
<p>可以从结果中看出，两个线程是串行执行，存在明显的互斥，<code>synchronized</code> 关键字修饰 <code>静态方法</code>， 锁定的确实是类</p>
<h3 id="synchronized-reference-和-synchronized-Clazz-class"><a href="#synchronized-reference-和-synchronized-Clazz-class" class="headerlink" title="synchronized(reference) {} 和 synchronized(Clazz.class) {}"></a>synchronized(reference) {} 和 synchronized(Clazz.class) {}</h3><p>synchorinizable 修饰类和对象的区别是什么呢？</p>
<p>在我看来， synchorinizable 修饰类和对象，可以抽象为 <code>类锁</code> 和 <code>对象锁</code></p>
<p>下面上代码</p>
<p>这是一个 <code>类锁</code> 的范例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">syncClazzLock</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SyncLockDemo.class) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;syncClazzLock: [count] -- &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是个 <code>对象锁</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncReferenceLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;syncReferenceLock: [count] -- &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用上面的锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> SyncLockDemo syncLockDemo = <span class="keyword">new</span> SyncLockDemo();</span><br><span class="line"></span><br><span class="line">     Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             syncClazzLock();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">     Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             syncLockDemo.syncReferenceLock();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">     t1.start();</span><br><span class="line">     t3.start();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果</p>
<pre><code>syncReferenceLock: [count] -- 0
syncClazzLock: [count] -- 0
syncReferenceLock: [count] -- 1
syncClazzLock: [count] -- 1
syncReferenceLock: [count] -- 2
syncClazzLock: [count] -- 2
syncReferenceLock: [count] -- 3
syncReferenceLock: [count] -- 4
syncClazzLock: [count] -- 3
syncClazzLock: [count] -- 4

Process finished with exit code 0</code></pre>
<p>从结果可以看出， 这两个线程的运行顺序是并行的，并不互斥。 因为 <code>syncClazzLock</code> 中 <code>synchronized</code> 关键字修饰的是类， 这个  <code>类锁</code> 作用于类的范围， 作用于类的静态方法、类的class 对象、类的静态代码块；而 <code>syncReferenceLock</code> 方法中 <code>synchronized</code> 关键字修饰的是对象， 这个 <code>对象锁</code> 最用于对象的范围，作用的对象示例的方法或一个对象实例上</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JAVA 并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>线上应用故障排查</title>
    <url>/2016/09/13/%E6%8A%80%E6%9C%AF/java/2016-09-13-CPU%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="CPU-100-处理流程"><a href="#CPU-100-处理流程" class="headerlink" title="CPU 100% 处理流程"></a>CPU 100% 处理流程</h4><p>当我们遇到 CPU 使用率过高的情况时(这里只考虑 <code>Linux/Solaris</code> 系统)<br>首先想到了 <code>top</code> 指令</p>
<pre><code> &gt; top</code></pre>
<p>先看看哪个进程使用的cpu 比较高,　当然这里只讲 JVM 使用 CPU 过高的情况;</p>
<p><img src="/assets/picture/top_cpu_fix.png" alt="图片" title="top 指令执行效果图"><br>这里的图片只是示例用，不存在cpu 使用率过高的问题</p>
<p>在查询到 vmid 后，查询虚拟机进程中哪个线程使用的 cpu 比较高</p>
<pre><code> &gt; ps -mp pid -o THREAD,tid,time</code></pre>
<p>确定了使用　cpu 过高的虚拟机线程 id 后，记录下　threadId</p>
<p>然后再使用　<code>jstack</code> 记录当前虚拟机线程信息快照</p>
<pre><code> $ jstack -l vmid　&gt; outofcpu.threaddump</code></pre>
<p> 这里已经获得了　<code>threadId</code> 和　当前的虚拟机线程信息快照信息</p>
<p> 我们可以考虑重启一下 tomcat 或者直接重启 JVM</p>
<p> 对于保存的　<code>threadId</code> 和　<code>outofcpu.threaddump</code><br> 在 threaddump 文件中查看　threadId 线程信息定位代码问题，达到修复目的</p>
<hr>
<h4 id="内存使用过高处理流程"><a href="#内存使用过高处理流程" class="headerlink" title="内存使用过高处理流程"></a>内存使用过高处理流程</h4><p>当我们遇到 <code>内存</code>  使用率过高的情况时(这里只考虑 <code>Linux/Solaris</code> 系统)<br /><br>首先想到了还是 <code>top</code> 指令</p>
<p><img src="/assets/picture/top_mem.png" alt="图片" title="top 指令执行效果图"></p>
<p>我们看到这里的tomcat 占用内存大到了 60% 多， 记录下 vmid</p>
<p>下面我们尝试查看这个进程中具体线程的内存使用情况<br><img src="/assets/picture/ps_thread_mem_bug.png" alt="图片" title="ps 指令无法查询进程中具体线程的内存适用情况"><br>这里可以看出</p>
<h6 id="ps-指令无法查询进程中具体线程的内存适用情况"><a href="#ps-指令无法查询进程中具体线程的内存适用情况" class="headerlink" title="ps 指令无法查询进程中具体线程的内存适用情况"></a>ps 指令无法查询进程中具体线程的内存适用情况</h6><br />
不过我们还有 java 提供的工具 jmap

<pre><code>&gt; sudo jmap -F -histo 12788 &gt; test.dump</code></pre>
<p>这里使用 <code>jmap -histo</code> 指令去 统计 JVM 堆中的对象信息</p>
<pre><code>&gt; sudo jmap -F -dump:format=b,file=test.all.dump 12788</code></pre>
<p>这里使用 <code>jmap -dump</code> 指令去生成JVM 堆存储快照， 后面在用 jhat visualvm 等工具进行分析</p>
<p>在分析之前，我们可以考虑一下是否需要重启服务</p>
<hr>
<p>这里在介绍一下 ps 的具体使用<br><img src="/assets/picture/ps_help.png" alt="图片" title="ps 帮助信息"></p>
<p>-m: 显示当前 <code>process id</code> 进程下的线程的信息<br>-o: 用户自定义显示列</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 基础知识</title>
    <url>/2017/09/12/%E6%8A%80%E6%9C%AF/java/JVM%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="如何标记对象是否死亡"><a href="#如何标记对象是否死亡" class="headerlink" title="如何标记对象是否死亡"></a>如何标记对象是否死亡</h1><ol>
<li><p>引用计数法</p>
<p>缺点：无法处理循环引用</p>
</li>
<li><p>根可达法</p>
</li>
</ol>
<p>JVM 使用的就是根可达法</p>
<h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><table>
<thead>
<tr>
<th>垃圾回收算法</th>
<th>优点</th>
<th>缺点</th>
<th>适用范围</th>
</tr>
</thead>
<tbody><tr>
<td>标记清除法</td>
<td>-</td>
<td>1.造成大量内存碎片; 2. 标记和清除的过程效率都很低</td>
<td>适用于老年代</td>
</tr>
<tr>
<td>标记整理法</td>
<td>1. 没有内存碎片; 2. 不会浪费内存空间</td>
<td>1. 效率更加低下</td>
<td>适用于存活率高的老年代</td>
</tr>
<tr>
<td>标记复制法</td>
<td>1. 效率提升，无需多次整理碎片</td>
<td>1. 浪费空间</td>
<td>适用于对象存活率低的新生代</td>
</tr>
<tr>
<td>分代回收法</td>
<td>1. 根据对象存活特点划分区域，适配最合适的回收算法</td>
<td>-</td>
<td>JVM 内存空间</td>
</tr>
</tbody></table>
<h1 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h1><h2 id="jdk8-之前的-hotspot-JVM-内存结构"><a href="#jdk8-之前的-hotspot-JVM-内存结构" class="headerlink" title="jdk8 之前的 hotspot JVM 内存结构"></a>jdk8 之前的 hotspot JVM 内存结构</h2><ul>
<li>程序计数器 ———— 程序计数器一块较小的内存空间，它可以看作是  <strong><em>当前线程所执行的字节码的行号指示器</em></strong>。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过更高级的方式去实现），字节解释器的工作就是改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器去完成。为了线程切换后能恢复到正确的执行位置，**<em>每条线程都需要有一个独立的程序计数器，独立存储。**</em> 这个区域不会出现 <code>OutOfMemoryError</code>；如果执行的是 native 方法，程序计数器的数值为 undefined。</li>
<li>栈<ul>
<li>虚拟机栈 ———— 虚拟机栈也是线程私有的，它的生命周期和线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个 <code>栈帧(Stack Frame)</code> 用于存储 <code>局部变量表</code>、<code>操作数栈</code>、<code>动态链接</code>、<code>方法出口</code> 等消息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。虚拟机栈可能会抛出 <code>OutOfMemoryError</code> 异常和 <code>StackOverflowError</code> 异常。<ul>
<li>局部变量表 ———— 存放编译期可知的各种基本类型数据（boolean、byte、char、short、int、long、double）、对象引用和 returnAddress 类型，其中 64 位长度的 long 和 double 类型的数据会占用 2 个局部变量空间。</li>
</ul>
</li>
<li>本地方法栈 ———— 本地方法栈和虚拟机栈的区别是，本地方法栈是为虚拟机使用到的 native 方法服务的，虚拟机规范对本地方法栈中方法使用的语言、使用方式没有强制规定，虚拟机可以自行实现；本地方法栈也可能会抛出 <code>OutOfMemoryError</code> 异常和 <code>StackOverflowError</code> 异常。</li>
</ul>
</li>
<li>堆 ———— JVM 管理的内存中最大的一块，由所有线程共享，在虚拟机启动的时候创建；堆唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。为了便于垃圾回收，堆使用分代收集算法，分为新生代和老年代；<ul>
<li>新生代 ———— 新生代进一步细分为 <code>Eden</code> 和 <code>Survivor</code>，<code>HotSpot 虚拟机</code>的实现中，<code>Survivor</code> 分为 <code>Survivor From</code> 和 <code>Survivor To</code>，三者的比例是 <code>Eden</code> : <code>Survivor From</code> : <code>Survivor To</code> 是 8:1:1；当 Survivor 空间不足的时候需要依赖老年代进行分配担保（也就是说大对象直接分配到老年代）。新生代使用标记复制收集法，对象实例先分配在 <code>Eden</code>，存活之后，将实例复制到其中一块 <code>Survivor</code> 区域，再将 <code>Eden</code> 区域进行清空。</li>
<li>老年代 ———— 老年用于存放超过 <code>Eden</code> 可分配空间的对象；存放新生代 <code>Survivor</code> 中内存不足时，老年代空间担保的对象；存放超过一定年龄的对象</li>
</ul>
</li>
<li>永生代（方法区）———— 线程共享的内存区域，存储已经被虚拟机加载的类信息、常量、静态变量、即时编辑器编译后的代码等数据</li>
</ul>
<h2 id="jdk8-之后的-JVM-内存结构"><a href="#jdk8-之后的-JVM-内存结构" class="headerlink" title="jdk8 之后的 JVM 内存结构"></a>jdk8 之后的 JVM 内存结构</h2><ul>
<li>程序计数器、虚拟机栈、本地方法栈、堆和 jdk8 之前的 JVM 内存结构是一致的，只有方法区变成了 <code>元空间</code></li>
</ul>
<h2 id="元空间和永久代的区别"><a href="#元空间和永久代的区别" class="headerlink" title="元空间和永久代的区别"></a>元空间和永久代的区别</h2><ol>
<li>元空间使用的本地内存空间，可以动态扩充</li>
<li>java8 把静态常量放到到 java heap</li>
<li>java8 把符号引用放到了 native heap</li>
<li>java8 把字面量转移到了 java heap</li>
<li>元空间和堆不相邻，full gc 的时候不会收集元空间</li>
</ol>
<h2 id="什么时候进入老年代"><a href="#什么时候进入老年代" class="headerlink" title="什么时候进入老年代"></a>什么时候进入老年代</h2><ol>
<li>对象初始大小超过新生代中 eden 可分配空间</li>
<li>对象年龄超过一定程度，这个阈值可能是 <code>-XX:MaxTenuringThreslod</code> 参数设置的（默认值15），也可能是 survivor 中 50% 以上对象的年龄</li>
<li>新生代 Survivor 中内存不足时，老年代进行空间分配担保，对象进入老年代</li>
</ol>
<h2 id="什么时候发生-老年代-GC"><a href="#什么时候发生-老年代-GC" class="headerlink" title="什么时候发生 老年代 GC"></a>什么时候发生 老年代 GC</h2><ol>
<li>老年代剩余可分配空间不足</li>
</ol>
<h2 id="Young-GC-的时候会扫描老年代吗？-Major-GC-的时候会扫描新生代吗？"><a href="#Young-GC-的时候会扫描老年代吗？-Major-GC-的时候会扫描新生代吗？" class="headerlink" title="Young GC 的时候会扫描老年代吗？ Major GC 的时候会扫描新生代吗？"></a>Young GC 的时候会扫描老年代吗？ Major GC 的时候会扫描新生代吗？</h2><ol>
<li>老年代回收的时候会将新生代中的对象作为 GC ROOT，同理新生代回收的时候，也需要考虑对象是否被老年代中的对象引用</li>
<li>JVM 为了避免每次YOUNG GC 的时候都去扫描老年代，维护了一个 <code>CardTable</code>, 其中将引用了新生代对象的老年代对象的地址置为 <code>dirty</code>， YOUNG GC 时候只需要扫描置为 <code>dirty</code> 的老年代区域即可</li>
<li>老年代GC 时候也需要扫描对象是否被新生代的对象引用</li>
</ol>
<h1 id="垃圾回收器对比"><a href="#垃圾回收器对比" class="headerlink" title="垃圾回收器对比"></a>垃圾回收器对比</h1><table>
<thead>
<tr>
<th>垃圾回收期</th>
<th>回收算法</th>
<th>特点</th>
<th>优点</th>
<th>缺点</th>
<th>适用范围</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>标记复制</td>
<td>1. 单线程 2. 全程 STW</td>
<td>1.单线程收集效率最高</td>
<td>1. 单线程 <br/>2. STW</td>
<td>新生代</td>
</tr>
<tr>
<td>ParNew</td>
<td>标记复制</td>
<td>Serial 的多线程版</td>
<td>1. 相比 Serial 来说，实现了多线程回收 <br/>2.可以和 CMS 配合使用</td>
<td>1. STW</td>
<td>新生代</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>标记复制</td>
<td>1. 多线程; <br/>2.达到一个<code>可控</code>的<code>吞吐量</code> <sub>注1</sub>  <br/> 3. 自适应调节策略</td>
<td>-</td>
<td>1. STW 2.不能和CMS配合使用</td>
<td>新生代</td>
</tr>
<tr>
<td>Serial Old</td>
<td>标记整理</td>
<td>老年代 Serial，使用标记整理算法</td>
<td>1.单线程收集效率最高</td>
<td>1. 单线程 <br/>2. STW</td>
<td>老年代</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>标记整理</td>
<td>老年代的 Parallel Scavenge，使用标记整理算法</td>
<td>1. 配合 Parallel Scavenge 实现高吞吐量有限</td>
<td>1. STW</td>
<td>老年代</td>
</tr>
<tr>
<td>CMS</td>
<td>标记清除</td>
<td>1. 专注于缩短STW 时间</td>
<td>1.多线程 2. STW 停顿时间短</td>
<td>1. 初始标记和重复标记的时候还是会 STW <br> 2. 产生大量碎片 <br/> 3. 并行清理的时候用户线程产生的垃圾称为浮动垃圾，只能在下一次回收中被清除 <br/> 4. 和用户线程抢CPU 资源</td>
<td>老年代</td>
</tr>
<tr>
<td>G1</td>
<td>标记整理</td>
<td>将整个JAVA堆分为一定大小的独立区域（Region），将区域标识位新生代Eden区域、新生代 Survivor区域、老年代区域，跟踪这些区域的垃圾堆积程度，优先收集垃圾堆积程度高的区域</td>
<td>1.没有碎片 <br/> 2.精确控制停顿 3. 避免全区的垃圾回收，保证低停顿的同时不影响吞吐量</td>
<td>1. 单线程 <br/>2. STW</td>
<td>JVM 堆</td>
</tr>
</tbody></table>
<p><strong><em>注1 吞吐量 = 运行用户代码的时间 / (运行用户代码的时间 + 垃圾收集时间)</em></strong></p>
<h1 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h1><p><img src="/assets/picture/jvm.cms.processing.flow.png" title="CMS 垃圾收集过程"></p>
<ol>
<li>初始标记(STW) —— 从新生代出发标记可达的老年代对象，从GC ROOTS 出发标记老年代对象</li>
<li>并发标记 —— 从 “初始标记” 标记的老年代出发，标记存活的老年代对象，将所有存活对象所在 Card 标记为 Dirty 状态;  后续只需要扫描这些对象，而不用扫描整个老年代 注意，这里不能标记出所有存活的数据，因为还有新晋升到老年代、或者直接在老年代分配的对象、或者更新老年代引用关系等等，需要重新标记</li>
<li>预处理 —— 标记新分配的新生代对象可达的老年代对象，标记老年代内引用发生变化的card 为 dirty</li>
<li>可中断的预处理 —— 循环处理标记新生代对象可达的老年代对象以及老年代内引用发生变化的对象，可以控制循环次数，循环时间上限为 5s，新生代eden 区使用率低于阈值（50%） 时循环退出；祈祷循环结束前进行一个 minor GC，也可以通过 <code>CMSScavengeBeforeRemark</code> 参数强制指定重新标记之前记性一次 minor GC</li>
<li>并发重新标记(STW) —— 并发重新标记，标记新生代可达的老年代对象，标记GC ROOTS 可达的老年代对象，重新标记老年代的 Dirty Card </li>
<li>并发清除</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>如何修改jar包中文件</title>
    <url>/2019/03/01/%E6%8A%80%E6%9C%AF/java/jar%E5%8C%85%E4%B8%AD%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<h2 id="修改jar-包中的文件"><a href="#修改jar-包中的文件" class="headerlink" title="修改jar 包中的文件"></a>修改jar 包中的文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.列出jar包中的文件清单</span></span><br><span class="line">jar tf genesys_data_etl-0.0.1-SNAPSHOT.jar</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.提取出内部jar包的指定文件</span></span><br><span class="line">jar xf genesys_data_etl-0.0.1-SNAPSHOT.jar BOOT-INF/classes/realtime/t_ivr_data_bj.json</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.然后可以修改文件</span></span><br><span class="line">vim BOOT-INF/classes/realtime/t_ivr_data_bj.json</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.更新配置文件到内部jar包.(存在覆盖，不存在就新增)</span></span><br><span class="line">jar uf genesys_data_etl-0.0.1-SNAPSHOT.jar BOOT-INF/classes/realtime/t_ivr_data_bj.json      </span><br><span class="line"></span><br><span class="line"><span class="comment">#4.1更新内部jar包到jar文件</span></span><br><span class="line">jar uf genesys_data_etl-0.0.1-SNAPSHOT.jar 内部jar包.jar     </span><br><span class="line"></span><br><span class="line"><span class="comment">#5.可以查看验证是否已经更改</span></span><br><span class="line">vim genesys_data_etl-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>jar</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次线上端口排查过程</title>
    <url>/2018/01/18/%E6%8A%80%E6%9C%AF/mac&amp;linux/netstat%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天在查看线上应用的时候发现一个服务启动之后报错断开已经被占用，但是<code>tomcat</code> 容器的日志中只说了端口已经被占用，但是没说是哪个端口被占用了，我们只能看看这个服务在其他机器上占用了什么接口，这时候我们就想到 <code>netstat</code> 指令</p>
<h2 id="netstat-查看端口占用情况"><a href="#netstat-查看端口占用情况" class="headerlink" title="netstat 查看端口占用情况"></a><code>netstat</code> 查看端口占用情况</h2><h3 id="常用-netstat-指令"><a href="#常用-netstat-指令" class="headerlink" title="常用 netstat 指令"></a>常用 <code>netstat</code> 指令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$netstat</span> -tlp | grep 99573</span><br><span class="line">tcp        0      0 0.0.0.0:24013           0.0.0.0:*               LISTEN      99573/java          </span><br><span class="line">tcp        0      0 0.0.0.0:17134           0.0.0.0:*               LISTEN      99573/java          </span><br><span class="line">tcp        0      0 0.0.0.0:sieve-filter    0.0.0.0:*               LISTEN      99573/java          </span><br><span class="line">tcp        0      0 0.0.0.0:18134           0.0.0.0:*               LISTEN      99573/java          </span><br><span class="line">tcp        0      0 localhost:19134         0.0.0.0:*               LISTEN      99573/java          </span><br><span class="line">tcp        0      0 0.0.0.0:commplex-main   0.0.0.0:*               LISTEN      99573/java          </span><br></pre></td></tr></table></figure>

<p><code>sieve-filter</code> 这个是什么？<code>commplex-main</code> 又是什么？我们怎么才能看到这两个端口的具体数值呢？</p>
<h3 id="netstat-指令常用参数"><a href="#netstat-指令常用参数" class="headerlink" title="netstat 指令常用参数"></a><code>netstat</code> 指令常用参数</h3><pre><code>netstat: 查看网络端口使用情况
    -a: 打印索引的套接字连接
    -t: 只打印TCP 连接信息
    -u: 只打印UDP 连接信息
    -p: 打印进程名称及进程ID
    -l: 打印所有在监听的服务端口
    -n: 用数字的形式打印端口信息，不对端口进行解析</code></pre>
<p>到这里我们就知道如何去打印具体的端口信息，去解决上面遇到的问题了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$netstat -tnlp | grep 99573</span><br><span class="line">tcp        0      0 0.0.0.0:24013           0.0.0.0:*               LISTEN      99573&#x2F;java          </span><br><span class="line">tcp        0      0 0.0.0.0:17134           0.0.0.0:*               LISTEN      99573&#x2F;java          </span><br><span class="line">tcp        0      0 0.0.0.0:2000    0.0.0.0:*               LISTEN      99573&#x2F;java          </span><br><span class="line">tcp        0      0 0.0.0.0:18134           0.0.0.0:*               LISTEN      99573&#x2F;java          </span><br><span class="line">tcp        0      0 localhost:19134         0.0.0.0:*               LISTEN      99573&#x2F;java          </span><br><span class="line">tcp        0      0 0.0.0.0:5000   0.0.0.0:*               LISTEN      99573&#x2F;java         </span><br></pre></td></tr></table></figure>
<h3 id="数据列说明"><a href="#数据列说明" class="headerlink" title="数据列说明"></a>数据列说明</h3><ol>
<li>Proto: 通信协议，tcp, udp, raw 等</li>
<li>Rece-Q: 接收队列中上午读取的数据，单位字节，一般是 0</li>
<li>Send-Q: 发送到远端尚未收到 ACK 的数据，单位字节，一般是0</li>
<li>Local Address: 通信连接中的本机地址及端口，一般情况下是 FQDN（全限定域名） 格式显示的地址，端口的显示格式默认是端口对应的服务名称，只有指定 <code>--numersic</code> 的时候才会按照数字形式打印</li>
<li>Foreign Address: 套接字的远端信息，地址加端口</li>
<li>State: 套接字连接状态<br>这里我们可以穿插讲解一下套接字连接状态</li>
</ol>
<p>6.1 ESTABLISHED 传输中断状态<br>6.2 SYN_SENT 客户端发起连接发送连接请求后的状态<br>6.3 SYN_RECV 套接字服务端接收到连接请求后的状态<br>6.4 FIN_WAIT1 客户端发起断开连接请求后的状态<br>6.5 FIN_WAIT2 断开连接请求方接收到对方回复之后，等待对方发起断开连接之后的状态<br>6.6 TIME_WAIT 客户端接收到服务端的断开连接的请求之后，向服务端发送ACK 信息后，进入此状态，是为了防止网络故障，进入 <code>TIME_WAIT</code> 后，如果服务端一直没有收到 ACK，会重新发送断开连接的请求<br>6.7 CLOSED 连接关闭的状态<br>6.8 CLOSED_WAIT 服务端接收到断开连接请求之后，发送ACK 之后<br>6.9 LAST_ACK 服务端确认数据发送完毕后，发送断开连接请求之后，进入此状态<br>6.10 LISTEN 暴露接口等待连接<br>6.11 CLOSING 连接双方同时发起断开连接的时候，出现的一个短暂的状态<br>6.12 UNKNOWN 未知的状态</p>
<h3 id="netstat-指令参数说明"><a href="#netstat-指令参数说明" class="headerlink" title="netstat 指令参数说明"></a><code>netstat</code> 指令参数说明</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$netstat</span> -h</span><br><span class="line">usage: netstat [-vWeenNcCF] [&lt;Af&gt;] -r         netstat &#123;-V|--version|-h|--<span class="built_in">help</span>&#125;</span><br><span class="line">       netstat [-vWnNcaeol] [&lt;Socket&gt; ...]</span><br><span class="line">       netstat &#123; [-vWeenNac] -I[&lt;Iface&gt;] | [-veenNac] -i | [-cnNe] -M | -s [-6tuw] &#125; [delay]</span><br><span class="line"></span><br><span class="line">        -r, --route              display routing table</span><br><span class="line">        -I, --interfaces=&lt;Iface&gt; display interface table <span class="keyword">for</span> &lt;Iface&gt;</span><br><span class="line">        -i, --interfaces         display interface table</span><br><span class="line">        -g, --groups             display multicast group memberships</span><br><span class="line">        -s, --statistics         display networking statistics (like SNMP)</span><br><span class="line">        -M, --masquerade         display masqueraded connections</span><br><span class="line"></span><br><span class="line">        -v, --verbose            be verbose</span><br><span class="line">        -W, --wide               don<span class="string">&#x27;t truncate IP addresses</span></span><br><span class="line"><span class="string">        -n, --numeric            don&#x27;</span>t resolve names</span><br><span class="line">        --numeric-hosts          don<span class="string">&#x27;t resolve host names</span></span><br><span class="line"><span class="string">        --numeric-ports          don&#x27;</span>t resolve port names</span><br><span class="line">        --numeric-users          don<span class="string">&#x27;t resolve user names</span></span><br><span class="line"><span class="string">        -N, --symbolic           resolve hardware names</span></span><br><span class="line"><span class="string">        -e, --extend             display other/more information</span></span><br><span class="line"><span class="string">        -p, --programs           display PID/Program name for sockets</span></span><br><span class="line"><span class="string">        -o, --timers             display timers</span></span><br><span class="line"><span class="string">        -c, --continuous         continuous listing</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        -l, --listening          display listening server sockets</span></span><br><span class="line"><span class="string">        -a, --all                display all sockets (default: connected)</span></span><br><span class="line"><span class="string">        -F, --fib                display Forwarding Information Base (default)</span></span><br><span class="line"><span class="string">        -C, --cache              display routing cache instead of FIB</span></span><br><span class="line"><span class="string">        -Z, --context            display SELinux security context for sockets</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &lt;Socket&gt;=&#123;-t|--tcp&#125; &#123;-u|--udp&#125; &#123;-U|--udplite&#125; &#123;-w|--raw&#125; &#123;-x|--unix&#125;</span></span><br><span class="line"><span class="string">           --ax25 --ipx --netrom</span></span><br><span class="line"><span class="string">  &lt;AF&gt;=Use &#x27;</span>-6|-4<span class="string">&#x27; or &#x27;</span>-A &lt;af&gt;<span class="string">&#x27; or &#x27;</span>--&lt;af&gt;<span class="string">&#x27;; default: inet</span></span><br><span class="line"><span class="string">  List of possible address families (which support routing):</span></span><br><span class="line"><span class="string">    inet (DARPA Internet) inet6 (IPv6) ax25 (AMPR AX.25)</span></span><br><span class="line"><span class="string">    netrom (AMPR NET/ROM) ipx (Novell IPX) ddp (Appletalk DDP)</span></span><br><span class="line"><span class="string">    x25 (CCITT X.25)</span></span><br></pre></td></tr></table></figure>


<h3 id="端口占用具体结论"><a href="#端口占用具体结论" class="headerlink" title="端口占用具体结论"></a>端口占用具体结论</h3><table>
<thead>
<tr>
<th>端口</th>
<th>使用协议</th>
<th>服务</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>5000</td>
<td>TCP/UDP</td>
<td>commplex-main</td>
<td></td>
</tr>
<tr>
<td>2000</td>
<td>TCP/UDP</td>
<td>sieve-filter</td>
<td></td>
</tr>
</tbody></table>
<p>结论：<br>        这里使用 <code>commplex-main</code> 和 <code>sieve-filter</code> 端口的是 <code>crashub</code></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka 中的偏移量</title>
    <url>/2017/12/10/%E6%8A%80%E6%9C%AF/kafka/2017-12-10-kafka%E5%A6%82%E4%BD%95%E6%8A%8A%E5%AE%9E%E7%8E%B0consumer%E6%8E%A7%E5%88%B6offset/</url>
    <content><![CDATA[<h1 id="kafka-中的偏移量"><a href="#kafka-中的偏移量" class="headerlink" title="kafka 中的偏移量"></a>kafka 中的偏移量</h1><h2 id="首先来了解一下Kafka所使用的基本术语："><a href="#首先来了解一下Kafka所使用的基本术语：" class="headerlink" title="首先来了解一下Kafka所使用的基本术语："></a>首先来了解一下Kafka所使用的基本术语：</h2><p><code>Topic</code>: Kafka将消息种子(Feed)分门别类，每一类的消息称之为一个主题(Topic).</p>
<p><code>Producer</code>: 发布消息的对象称之为主题生产者(Kafka topic producer)</p>
<p><code>Consumer</code>: 订阅消息并处理发布的消息的种子的对象称之为主题消费者(consumers)</p>
<p><code>Broker</code>: 已发布的消息保存在一组服务器中，称之为Kafka集群。集群中的每一个服务器都是一个代理(Broker). 消费者可以订阅一个或多个主题（topic），并从Broker拉数据，从而消费这些已发布的消息。</p>
<hr>
<h2 id="话题和日志-Topic和Log"><a href="#话题和日志-Topic和Log" class="headerlink" title="话题和日志 (Topic和Log)"></a>话题和日志 (Topic和Log)</h2><p>让我们更深入的了解Kafka中的Topic。</p>
<p>Topic是发布的消息的类别或者种子Feed名。对于每一个Topic，Kafka集群维护这一个分区的log，就像下图中的示例：</p>
<p><img src="/assets/picture/kafka-partition.png" alt="图片" title="Kafka partition log"></p>
<p>每一个分区都是一个顺序的、不可变的消息队列， 并且可以持续的添加。分区中的消息都被分了一个序列号，称之为<code>偏移量</code>(offset)，在每个分区中此<code>偏移量</code>都是唯一的。</p>
<p>Kafka集群保持所有的消息，直到它们过期， 无论消息是否被消费了。 实际上消费者所持有的仅有的元数据就是这个<code>偏移量</code>，也就是消费者在这个log中的位置。 这个<code>偏移量</code>由<code>消费者</code>控制：正常情况当消费者消费消息的时候，<code>偏移量</code>也线性的的增加。但是实际<code>偏移量</code>由消费者控制，消费者可以将<code>偏移量</code>重置为更老的一个<code>偏移量</code>，重新读取消息。 可以看到这种设计对消费者来说操作自如， 一个消费者的操作不会影响其它消费者对此log的处理。</p>
<p><img src="/assets/picture/kafka-offset.png" alt="图片" title="Kafka partition offset"></p>
<hr>
<h2 id="消费者-Consumers"><a href="#消费者-Consumers" class="headerlink" title="消费者(Consumers)"></a>消费者(Consumers)</h2><p>通常来讲，消息模型可以分为两种， <code>队列</code> 和 <code>发布-订阅</code> 式。 队列的处理方式是 一组消费者从服务器读取消息，一条消息只有其中的一个消费者来处理。在发布-订阅模型中，消息被广播给所有的消费者，接收到消息的消费者都可以处理此消息。Kafka为这两种模型提供了单一的消费者抽象模型： 消费者组 （consumer group）。 消费者用一个消费者组名标记自己。 一个发布在Topic上消息被分发给此消费者组中的一个消费者。 假如所有的消费者都在一个组中，那么这就变成了queue模型。 假如所有的消费者都在不同的组中，那么就完全变成了发布-订阅模型。 更通用的， 我们可以创建一些消费者组作为逻辑上的订阅者。每个组包含数目不等的消费者， 一个组内多个消费者可以用来扩展性能和容错。正如下图所示：<br>2个kafka集群托管4个分区（P0-P3），2个消费者组，消费组A有2个消费者实例，消费组B有4个。</p>
<p><img src="/assets/picture/kafka-customer-type.png" alt="图片" title="Kafka customer type"></p>
<p>正像传统的消息系统一样，Kafka保证消息的顺序不变。 再详细扯几句。传统的队列模型保持消息，并且保证它们的先后顺序不变。但是， 尽管服务器保证了消息的顺序，消息还是异步的发送给各个消费者，消费者收到消息的先后顺序不能保证了。这也意味着并行消费将不能保证消息的先后顺序。用过传统的消息系统的同学肯定清楚，消息的顺序处理很让人头痛。如果只让一个消费者处理消息，又违背了并行处理的初衷。 在这一点上Kafka做的更好，尽管并没有完全解决上述问题。 Kafka采用了一种分而治之的策略：分区。 因为Topic分区中消息只能由消费者组中的唯一一个消费者处理，所以消息肯定是按照先后顺序进行处理的。但是它也仅仅是保证Topic的一个分区顺序处理，不能保证跨分区的消息先后处理顺序。 所以，如果你想要顺序的处理Topic的所有消息，那就只提供一个分区。</p>
<hr>
<h2 id="偏移量-Offsets-的管理"><a href="#偏移量-Offsets-的管理" class="headerlink" title="偏移量(Offsets)的管理"></a>偏移量(Offsets)的管理</h2><p>如上文所述，kafka为分区中的每条消息保存一个 <code>偏移量（offset）</code>，这个<code>偏移量</code>是该分区中一条消息的唯一标示符。也表示消费者在分区的位置。例如，一个位置是5的消费者(说明已经消费了0到4的消息)，下一个接收消息的偏移量为5的消息。实际上有两个与消费者相关的“位置”概念：</p>
<p>消费者的位置给出了下一条记录的偏移量。它比消费者在该分区中看到的最大偏移量要大一个。 它在每次消费者在调用poll(long)中接收消息时自动增长。</p>
<p>“已提交”的位置是已安全保存的最后偏移量，如果进程失败或重新启动时，消费者将恢复到这个偏移量。消费者可以选择定期自动提交偏移量，也可以选择通过调用commit API来手动的控制(如：commitSync 和 commitAsync)。</p>
<h3 id="消费者如何提交-偏移量-Offsets"><a href="#消费者如何提交-偏移量-Offsets" class="headerlink" title="消费者如何提交 偏移量(Offsets)"></a>消费者如何提交 <code>偏移量(Offsets)</code></h3><ol>
<li>自动提交</li>
</ol>
<p>这种方式只要在启动时配置属性 <code>enable.auto.commit</code> 为 <code>true</code> 即可， 示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;auto.commit.interval.ms&quot;</span>, <span class="string">&quot;1000&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">    consumer.subscribe(Arrays.asList(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">    System.out.println(consumer);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">      <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;offset = %d, key = %s, value = %s%n&quot;</span>, record.offset(), record.key(),</span><br><span class="line">          record.value());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>手动提交</li>
</ol>
<p>在一些场景中，<code>消费者</code> 需要自行判定消息是否被消费了，如果没有判断为没有消费（ps:可能是消费失败了，需要重试），<code>消费者</code> 不会改变 offset；只有 <code>消费者</code> 判定消费成功是，才手动调用 <code>commitSync()</code> 或 <code>commitAsync()</code> 方法去提交 <code>偏移量</code>； 当然此时我们需要把 <code>enable.auto.commit</code> 置为 false。</p>
<p>下面给出个小例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"> props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line"> props.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"> props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;false&quot;</span>); <span class="comment">// 主动提交置为false</span></span><br><span class="line"> props.put(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line"> props.put(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line"> KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line"> consumer.subscribe(Arrays.asList(<span class="string">&quot;test&quot;</span>));</span><br><span class="line"> System.out.println(consumer);</span><br><span class="line"> <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">     ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">     <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">         System.out.printf(<span class="string">&quot;offset = %d, key = %s, value = %s%n&quot;</span>, record.offset(), record.key(),</span><br><span class="line">             record.value());</span><br><span class="line">         <span class="comment">// 逻辑处理</span></span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (success) &#123; <span class="comment">// 如果判定消费成功，则手动提交offset到 broker</span></span><br><span class="line">         consumer.commitSync();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费者如果控制偏移量"><a href="#消费者如果控制偏移量" class="headerlink" title="消费者如果控制偏移量"></a>消费者如果控制偏移量</h3><p>在一些场景下，消费者需要控制自己要读取的偏移量，此时用户可以通过API手动设置开始读取的 <code>偏移量</code></p>
<p>API 中提供以下方法：</p>
<ol>
<li><p>指定到某个分区的具体 offset<br>org.apache.kafka.clients.consumer.KafkaConsumer#seek(TopicPartition partition, long offset)</p>
</li>
<li><p>指定到某些分区的开始<br>org.apache.kafka.clients.consumer.KafkaConsumer#seekToBeginning(Collection<TopicPartition> partitions)</p>
</li>
<li><p>指定到某些分区的结束，从上次结束的位置开始消费<br>org.apache.kafka.clients.consumer.KafkaConsumer#seekToEnd(Collection<TopicPartition> partitions)</p>
</li>
</ol>
<p>此时我们需要知道当前的 <code>Topic</code> 的偏移量信息，<code>Kafka</code> 为我们提供了很友好的工具 <code>Get Offset Shell</code></p>
<p><code>Get Offset Shell</code><br>get offsets for a topic</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-run-class.sh kafka.tools.GetOffsetShell</span><br></pre></td></tr></table></figure>

<p>required argument [broker-list], [topic]</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>–broker-list [hostname:port,….]</td>
<td>REQUIRED: The list of hostname and [hostname:port] port of the server to connect to.</td>
</tr>
<tr>
<td>–max-wait-ms [Integer: ms]</td>
<td>The max amount of time each fetch request waits. (default: 1000)</td>
</tr>
<tr>
<td>–offsets [Integer: count]</td>
<td>number of offsets returned (default: 1)</td>
</tr>
<tr>
<td>–partitions [partition ids]</td>
<td>comma separated list of partition ids. If not specified, will find offsets for all partitions (default)</td>
</tr>
<tr>
<td>–time [Long: timestamp in milliseconds]</td>
<td>-1(latest) / -2 (earliest) timestamp; offsets will come before this timestamp, as in getOffsetsBefore</td>
</tr>
<tr>
<td>–topic [topic]</td>
<td>REQUIRED: The topic to get offsets from.</td>
</tr>
</tbody></table>
<p>示例：</p>
<p>查询最近的offset</p>
<pre><code>            ➜  kafka_2.12-1.0.0 bin/kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list localhost:9092 -topic test --time -1</code></pre>
<p>输出</p>
<pre><code>            test:0:52</code></pre>
<p>查询开始的的offset</p>
<pre><code>            ➜  kafka_2.12-1.0.0 bin/kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list localhost:9092 -topic test --time -2</code></pre>
<p>输出</p>
<pre><code>            test:0:0</code></pre>
<h3 id="偏移量的存储"><a href="#偏移量的存储" class="headerlink" title="偏移量的存储"></a><code>偏移量</code>的存储</h3><p>新版本的 <code>Kafka</code> 将偏移量信息存储在名为 <code>__consumer_offsets</code> 的topic 中,<br>也支持将 <code>偏移量</code> 信息存储在 <code>Zookeeper</code> 中</br><br>通过设置属性 <code>offsets.storage</code> 控制，<code>offsets.storage</code> 属性可选值有 <code>kafka</code> 和 <code>zookeeper</code></p>
<p>消费者也可以不使用 <code>Kafka</code> 提供的偏移量存储方案，可自定义存储方式，详见<a href="http://kafka.apache.org/0101/javadoc/org/apache/kafka/clients/consumer/KafkaConsumer.html#rebalancecallback" title="官方文档">官方文档</a></p>
]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 继承方式： scope import</title>
    <url>/2017/02/12/%E6%8A%80%E6%9C%AF/maven/Maven%20scope%20import/</url>
    <content><![CDATA[<h3 id="使用-scope-import-解决Maven-单继承问题"><a href="#使用-scope-import-解决Maven-单继承问题" class="headerlink" title="使用 scope import 解决Maven 单继承问题"></a>使用 <code>scope import</code> 解决Maven 单继承问题</h3><p><code>Maven</code> 本身支持继承，很多时候我们会创建多模块项目，而多个模块会引入相同的依赖项，这个时候我们就能使用 <code>Maven</code> 的父子工程结构，<br>创建一个父 pom 文件，其他子项目中的 pom 文件继承父pom</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>base.parent<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>--&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent.management<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样我们就能是的依赖项的管理更加有条理</p>
<p>但是 <code>Maven</code> 父子项目结构和 Java继承一样，都是单继承，一个子项目只能制定一个父 pom</p>
<p>很多时候，我们需要打破这种 <code>单继承</code></p>
<p>例如使用 <code>spring-boot</code> 的时候， 官方推荐的方式是继承父pom <code>spring-boot-starter-parent</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是如果项目中已经有了其他父pom， 又想用 <code>spring-boot</code> 怎么办呢？</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>就是使用 <code>scope import</code>， 还需要指定 <code>type pom</code></p>
<p><em>注意：<code>scope import</code> 只能在 <code>dependencyManagement</code> 中的使用</em></p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>mogilefs 基础介绍</title>
    <url>/2019/01/10/%E6%8A%80%E6%9C%AF/mogifs/mogilefs-base-desc/</url>
    <content><![CDATA[<h1 id="mogilefs"><a href="#mogilefs" class="headerlink" title="mogilefs"></a><code>mogilefs</code></h1><h2 id="mogilefs-介绍"><a href="#mogilefs-介绍" class="headerlink" title="mogilefs 介绍"></a><code>mogilefs</code> 介绍</h2><p>MogileFS是一个开源的分布式文件存储系统，由LiveJournal旗下的DangaInteractive公司开发。Danga团队开发了包括 Memcached、MogileFS、Perlbal 等多个知名的开源项目。目前使用MogileFS 的公司非常多，如日本排名先前的几个互联公司及国内的yupoo(又拍)、digg、豆瓣、1号店、大众点评、搜狗和安居客等，分别为所在的组织或公司管理着海量的图片。</p>
<h2 id="mogilefs-基本概念"><a href="#mogilefs-基本概念" class="headerlink" title="mogilefs 基本概念"></a><code>mogilefs</code> 基本概念</h2><h3 id="mogilefs-组成架构"><a href="#mogilefs-组成架构" class="headerlink" title="mogilefs 组成架构"></a><code>mogilefs</code> 组成架构</h3><p><code>tracker节点</code>: <code>tracker节点</code> 是应用程序 <code>mogilefsd</code>，通过数据库来保存元数据，提供API 响应客户端 <br/><br><code>storage节点</code>: <code>storage节点</code> 是应用程序 <code>mogstored</code>，本质上是一个 <code>WebDAV</code> 服务，默认监听 <code>7500</code> 端口，接受客户端的文件存储请求 <br/><br><code>database</code>: 用于存储元数据的 <code>mysql</code> 数据库 <br/></p>
<p><img src="https://s1.51cto.com/images/20171204/1512393806362708.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" title="mogilefs 结构图"></p>
<h3 id="mogilefs-数据存储相关概念"><a href="#mogilefs-数据存储相关概念" class="headerlink" title="mogilefs 数据存储相关概念"></a><code>mogilefs</code> 数据存储相关概念</h3><p><code>domain</code>: <code>mogilefs</code> 划分数据存储的容器，每一个 domain 中的数据的  key 不能重复，但是不同 domain 中数据的 key 可以重复；domain 的划分可以按照数据类型划分，也可以按照业务类型划分。<br/><br><code>host</code>: <code>mogilefs</code> 的每一个存储节点被称为一个 <code>host</code>，每个 <code>host</code> 有自己的 ID<br/><br><code>device</code>: 每个存储节点可以挂靠多个 <code>device</code>， 每个 <code>device</code> 对应一个时间存储数据的存储设备（硬盘），每个 <code>device</code> 有自己的ID<br/><br><code>class</code>: 对于存储在mogilefs 上的文件进行分类，同一 <code>domain</code> 下的文件可以分类不同类型，但是key 不同重复，上传文件时，可指定 <code>class</code>， 默认为 <code>default</code> <br/> </p>
<h2 id="mogilefs-基本操作"><a href="#mogilefs-基本操作" class="headerlink" title="mogilefs 基本操作"></a><code>mogilefs</code> 基本操作</h2><h3 id="mogadm"><a href="#mogadm" class="headerlink" title="mogadm"></a><code>mogadm</code></h3><h4 id="mogadm-check"><a href="#mogadm-check" class="headerlink" title="mogadm check"></a><code>mogadm check</code></h4><p>检查 <code>mogilefs</code> 集群状态</p>
<pre><code>    $mogadm check
    Checking trackers...
    127.0.0.1:7001 ... OK

    Checking hosts...
    [ 1] storage1 ... OK

    Checking devices...
    host device         size(G)    used(G)    free(G)   use%   ob state   I/O%
    ---- ------------ ---------- ---------- ---------- ------ ---------- -----
    [ 1] dev1           374.702     29.018    345.684   7.74%  writeable   0.0
    ---- ------------ ---------- ---------- ---------- ------
         total:   374.702     29.018    345.684   7.74%</code></pre>
<h4 id="mogadm-domain"><a href="#mogadm-domain" class="headerlink" title="mogadm domain"></a><code>mogadm domain</code></h4><p><code>mogilefs</code> 集群 <code>domain</code> 管理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mogadm domain add domain1 <span class="comment"># 新增 domain</span></span><br><span class="line">mogadm domain delete domain1 <span class="comment"># 删除 domain</span></span><br><span class="line">mogadm domain list <span class="comment"># 列出所有 domain</span></span><br></pre></td></tr></table></figure>

<h4 id="mogadm-host"><a href="#mogadm-host" class="headerlink" title="mogadm host"></a><code>mogadm host</code></h4><p><code>mogilefs</code> 集群 <code>host</code> 管理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新增 host</span></span><br><span class="line">mogadm --trackers=127.0.0.1:7001 host add host1 --ip=[<span class="variable">$ip</span>] --port=7500 --status=alive </span><br><span class="line">mogadm host delete host1 <span class="comment"># 删除 host, 不指定tracker 的时候默认使用本机 `127.0.0.1:7001`</span></span><br><span class="line">mogadm host list <span class="comment"># 列出所有 host</span></span><br></pre></td></tr></table></figure>

<h4 id="mogadm-device"><a href="#mogadm-device" class="headerlink" title="mogadm device"></a><code>mogadm device</code></h4><p><code>mogilefs</code> 集群 <code>device</code> 管理</p>
<h5 id="device-列出"><a href="#device-列出" class="headerlink" title="device 列出"></a><code>device</code> 列出</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mogadm device list <span class="comment"># 列出所有 host</span></span><br></pre></td></tr></table></figure>

<h5 id="新增-device"><a href="#新增-device" class="headerlink" title="新增 device"></a>新增 <code>device</code></h5><p>下面的例子中新增 <code>device</code></p>
<ol>
<li><p>进入 <code>/etc/mogilefs/mogstored.conf</code> 文件中配置的 <code>docroot</code>，例如 <code>cd /home1/mogdata</code></p>
</li>
<li><p>如果待挂载的 <code>device</code>（ID 命名为 dev2） 所在的硬盘和 <code>/home1</code> 所在硬盘不一致(例如 <code>/home2</code>)，需要在 <code>/home2</code> 中新建目录 <code>/home2/mogdata/dev2</code>，并在 <code>/home1/mogdata</code> 中创建软链</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -pv /home2/mogdata/dev2;</span><br><span class="line"><span class="built_in">cd</span> /home1/mogdata;</span><br><span class="line">ln -s /home2/mogdata/dev2 dev2;</span><br><span class="line">mogadm --trackers=127.0.0.1:7001 device add host1 dev2</span><br></pre></td></tr></table></figure>

<h5 id="device-状态修改"><a href="#device-状态修改" class="headerlink" title="device 状态修改"></a><code>device</code> 状态修改</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dev2 磁盘故障</span></span><br><span class="line">mogadm --trackers=127.0.0.1:7001 device mark host1 dev2 dead <span class="comment"># 将 dev2 置为死亡，不可用</span></span><br><span class="line"><span class="comment"># dev2 磁盘故障恢复，无法直接从 dead 更换到 alive，需先过渡到 down 状态</span></span><br><span class="line">mogadm --trackers=127.0.0.1:7001 device mark host1 dev2 down <span class="comment"># 将 dev2 置为 down 状态</span></span><br><span class="line">mogadm --trackers=127.0.0.1:7001 device mark host1 dev2 alive <span class="comment"># 将 dev2 置为 alive 状态</span></span><br></pre></td></tr></table></figure>

<h5 id="device-列表状态查询"><a href="#device-列表状态查询" class="headerlink" title="device 列表状态查询"></a><code>device</code> 列表状态查询</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mogadm --trackers=127.0.0.1:7001 device summary</span><br></pre></td></tr></table></figure>

<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mogupload --trackers=<span class="string">&quot;127.0.0.1:7001&quot;</span> --domain=[<span class="variable">$&#123;domain&#125;</span>] --key=[<span class="variable">$&#123;key&#125;</span>] --file=[<span class="variable">$&#123;file&#125;</span>] --class=[<span class="variable">$&#123;class&#125;</span>]</span><br></pre></td></tr></table></figure>

<p><code>--domain</code>: 指定上传文件的 <code>domain</code><br><code>--key</code>: 指定上传文件的 <code>key</code><br><code>--file</code>: 指定上传文件的路径<br><code>--class</code>: 指定上传文件的 <code>class</code>，可选项，默认值为 <code>default</code></p>
<h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mogfetch --trackers=host --domain=[<span class="variable">$&#123;domain&#125;</span>] --key=[<span class="variable">$&#123;key&#125;</span>] --file=[<span class="variable">$&#123;file&#125;</span>]</span><br></pre></td></tr></table></figure>

<p><code>--domain</code>: 指定上传文件的 <code>domain</code><br><code>--key</code>: 指定上传文件的 <code>key</code><br><code>--file</code>: 指定下载文件的路径及名称</p>
<h3 id="文件查看"><a href="#文件查看" class="headerlink" title="文件查看"></a>文件查看</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mogfileinfo  --trackers=<span class="string">&quot;127.0.0.1:7001&quot;</span> --domain=[<span class="variable">$&#123;domain&#125;</span>] --key=[<span class="variable">$&#123;key&#125;</span>]</span><br></pre></td></tr></table></figure>

<p><code>--domain</code>: 指定上传文件的 <code>domain</code><br><code>--key</code>: 指定上传文件的 <code>key</code></p>
<p>输出结果：</p>
<pre><code>- file: [$file]
class:                   default
devcount:                    1
domain:                 [$domain]
fid:                   30
key:      [$key]
length:                  608
- http://127.0.0.1:7500/dev1/0/000/000/0000000030.fid</code></pre>
]]></content>
      <categories>
        <category>mogilefs</category>
      </categories>
      <tags>
        <tag>mogilefs</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis 源码阅读(一)</title>
    <url>/2016/09/20/%E6%8A%80%E6%9C%AF/mybatis/2016-09-20-mybatis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<h6 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h6><p>我们开始从mybatis 启动流程开始阅读源码</p>
<p><code>mybatis</code> 的配置信息层次结构：</p>
<blockquote>
<p>configuration</p>
<blockquote>
<p>properties</p>
</blockquote>
<blockquote>
<p>settings</p>
</blockquote>
<blockquote>
<p>typeAliases</p>
</blockquote>
<blockquote>
<p>typeHandlers</p>
</blockquote>
<blockquote>
<p>objectFactory</p>
<p>objectWrapperFactory</p>
<p>reflectorFactory</p>
<p>plugins</p>
<p>environments</p>
<blockquote>
<p>transactionManager</p>
</blockquote>
<blockquote>
<p>dataSource</p>
</blockquote>
<p>databaseIdProvider</p>
<p>mappers</p>
</blockquote>
</blockquote>
<p>无论是结合 <code>Spring</code> 使用 <code>Mybatis</code> 还是单独使用，在启动的时候都需要经过这个入口 <code>SqlSessionFactoryBuilder</code> 来构建  <code>SqlSessionFactory</code></p>
<p>使用 <code>SqlSessionFactoryBuilder</code> 构建  <code>SqlSessionFactory</code> 有两种方：编码方式，Xml 配置方式；</p>
<p>获取  <code>SqlSessionFactory</code> 的主体调用流程如下：<br>org.apache.ibatis.session.SqlSessionFactoryBuilder#build(Reader or InputStream);<br>org.apache.ibatis.builder.xml.XMLConfigBuilder#XMLConfigBuilder();<br>org.apache.ibatis.builder.xml.XMLConfigBuilder#parse<br>org.apache.ibatis.builder.xml.XMLConfigBuilder#parseConfiguration<br>org.apache.ibatis.session.SqlSessionFactoryBuilder#build(org.apache.ibatis.session.Configuration)<br>得到的 <code>SqlSessionFactory</code> 的默认实现 <code>DefaultSqlSessionFactory</code></p>
<p>编码方式这里不做赘述， 配置文件的方式主要流程如下得到 <code>Configuration</code><br><img src="/assets/picture/mybatis_source_to_configuration.png" alt="图片" title="加载mybatis 配置信息的途径"></p>
<p>xml 配置方式主要依赖 <code>XMLConfigBuilder</code> 来解析配置文件</p>
<pre><code>    private void parseConfiguration(XNode root) &#123;
        try &#123;
          //issue #117 read properties first
          //解析 xml 中 &lt;properties&gt; 标签，主要是解析url 和 resource， 需要注意的是这两个配置不能同时存在
          propertiesElement(root.evalNode(&quot;properties&quot;));
          // 注册 type aliase 可以使用 package 扫描一个文件夹中的所有 带@Alias 注解的所有类
          // [注意] alias 会忽略大小写 toLowCase
          typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));
          pluginElement(root.evalNode(&quot;plugins&quot;));
          // MyBatis uses an `ObjectFactory` to create all needed new Objects.
          objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));
          //
          objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));
          reflectionFactoryElement(root.evalNode(&quot;reflectionFactory&quot;));
          settingsElement(root.evalNode(&quot;settings&quot;));
          // read it after objectFactory and objectWrapperFactory issue #631
          //
          environmentsElement(root.evalNode(&quot;environments&quot;));
          // 通过xml 中设置的type 别名构建 DatabaseIdProvider， 默认为 VendorDatabaseIdProvider
          // 再通过 DatabaseIdProvider 获取 databaseId， 设置到 Configuration.databaseId
          databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));
          // TypeHander 对应一个 Class 以及一个 JdbcType
          // 注册 TypeHander 时可以一个个的注册，也可以注册一个 package 中所有实现了 `TypeHandler` 接口的类
          // 通过继承 BaseTypeHandler 自定义的TypeHander
          // TypeHandler 如果没有通过 @MappedJdbcTypes 指定的JdbcType 则为null
          typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));
          mapperElement(root.evalNode(&quot;mappers&quot;));
        &#125; catch (Exception e) &#123;
          throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);
        &#125;
      &#125;</code></pre>
<p>mybatis 的重要组成部分是 mapper xml 文件，对于这些文件的解析很重要<br>解析 package 中的接口时，获取 package 下的所有接口， 依次直接使用 <code>MapperRegister</code> 注册 Interface –&gt; MapperProxyFactory</p>
<p>使用 <mapper> 标签中的 <code>mapperClass</code> 配置接口信息， 也是 <code>MapperRegister</code> 注册 Interface –&gt; MapperProxyFactory</p>
<p>使用 <mapper> 标签中的 <code>url</code> 或 <code>resource</code> 配置 mapper xml 文件的路径， 使用 <code>XmlMappperBuilder</code> 解析 xml 文件</p>
<p>这里先介绍 <code>MapperRegister</code> <code>MapperProxyFactory</code></p>
<p><code>MapperRegister</code> 中保存了 Interface –&gt; MapperProxyFactory 的map</p>
<p><code>mybatis</code> 中大量使用了设计模式， <code>MapperProxyFactory</code> 使用了工厂模式<br><code>MapperProxyFactory</code> 一看就是生产 <code>MapperProxy</code> 的工厂类， 提供 org.apache.ibatis.binding.MapperProxyFactory#newInstance(org.apache.ibatis.session.SqlSession)<br>方法获取 Mapper Interface 的实现类</p>
<p><code>MapperProxy</code> 是java 动态代理的使用，<code>MapperProxy</code> 实现了 <code>InvocationHandler</code> 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *    Copyright 2009-2015 the original author or authors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> *    you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> *    You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *       http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> *    See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> *    limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> org.apache.ibatis.binding;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lasse Voss</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// MapperProxy 代理的 Mapper 接口</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="comment">// 这里的Key 是 Mapper 接口中方法对象，Value 是方法对象的封装</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;Method, MapperMethod&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperProxyFactory</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getMapperInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;Method, MapperMethod&gt; <span class="title">getMethodCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 Sqlsession 获取 Mapper 接口</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>Configuration</code>: mybatis 配置信息的根节点</p>
<pre><code>      public Configuration() &#123;
          // 这里注册了很多类的别名，在需要的时候通过反射机制获取 类的实例
          typeAliasRegistry.registerAlias(&quot;JDBC&quot;, JdbcTransactionFactory.class);
          typeAliasRegistry.registerAlias(&quot;MANAGED&quot;, ManagedTransactionFactory.class);

          typeAliasRegistry.registerAlias(&quot;JNDI&quot;, JndiDataSourceFactory.class);
          typeAliasRegistry.registerAlias(&quot;POOLED&quot;, PooledDataSourceFactory.class);
          typeAliasRegistry.registerAlias(&quot;UNPOOLED&quot;, UnpooledDataSourceFactory.class);

          typeAliasRegistry.registerAlias(&quot;PERPETUAL&quot;, PerpetualCache.class);
          typeAliasRegistry.registerAlias(&quot;FIFO&quot;, FifoCache.class);
          typeAliasRegistry.registerAlias(&quot;LRU&quot;, LruCache.class);
          typeAliasRegistry.registerAlias(&quot;SOFT&quot;, SoftCache.class);
          typeAliasRegistry.registerAlias(&quot;WEAK&quot;, WeakCache.class);

          typeAliasRegistry.registerAlias(&quot;DB_VENDOR&quot;, VendorDatabaseIdProvider.class);

          typeAliasRegistry.registerAlias(&quot;XML&quot;, XMLLanguageDriver.class);
          typeAliasRegistry.registerAlias(&quot;RAW&quot;, RawLanguageDriver.class);

          typeAliasRegistry.registerAlias(&quot;SLF4J&quot;, Slf4jImpl.class);
          typeAliasRegistry.registerAlias(&quot;COMMONS_LOGGING&quot;, JakartaCommonsLoggingImpl.class);
          typeAliasRegistry.registerAlias(&quot;LOG4J&quot;, Log4jImpl.class);
          typeAliasRegistry.registerAlias(&quot;LOG4J2&quot;, Log4j2Impl.class);
          typeAliasRegistry.registerAlias(&quot;JDK_LOGGING&quot;, Jdk14LoggingImpl.class);
          typeAliasRegistry.registerAlias(&quot;STDOUT_LOGGING&quot;, StdOutImpl.class);
          typeAliasRegistry.registerAlias(&quot;NO_LOGGING&quot;, NoLoggingImpl.class);

          typeAliasRegistry.registerAlias(&quot;CGLIB&quot;, CglibProxyFactory.class);
          typeAliasRegistry.registerAlias(&quot;JAVASSIST&quot;, JavassistProxyFactory.class);

          // 注册语言管理驱动，默认语言管理驱动为：`XMLLanguageDriver`
          languageRegistry.setDefaultDriverClass(XMLLanguageDriver.class);
          languageRegistry.register(RawLanguageDriver.class);
        &#125;</code></pre>
<p><code>ObjectFactory</code>:</p>
<p><code>Reflector</code></p>
<p><code>ObjectWrapper</code></p>
<p><code>TransactionFactory</code></p>
<p><code>TypeAliasRegistry</code></p>
<p><code>LanguageRegistry</code></p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 索引</title>
    <url>/2016/09/07/%E6%8A%80%E6%9C%AF/mysql/2016-09-07-mysql%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[<h2 id="Mysql-索引"><a href="#Mysql-索引" class="headerlink" title="Mysql 索引"></a>Mysql 索引</h2><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p>mysql 索引分为 <code>聚簇索引</code> 和 <code>非聚簇索引</code><br/><br><code>聚簇索引</code>：数据的物理存储顺序和索引的顺序是一致的<br /><br><code>非聚簇索引</code>：数据的物理存储顺序和索引的顺序不一致<br /><br>很明显数据的物理存储顺序只有一种，所以 <code>聚簇索引</code> 只能有一个</p>
<h3 id="关于联合索引"><a href="#关于联合索引" class="headerlink" title="关于联合索引"></a>关于联合索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`grade_info`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">&#x27;自增主键&#x27;</span>,</span><br><span class="line">  <span class="string">`grade`</span> <span class="keyword">double</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;成绩&#x27;</span>,</span><br><span class="line">  <span class="string">`teacher_id`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;教师id&#x27;</span>,</span><br><span class="line">  <span class="string">`class_id`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;课程id&#x27;</span>,</span><br><span class="line">  <span class="string">`student_id`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;学生id&#x27;</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`grade_info_teacher_id_IDX`</span> (<span class="string">`teacher_id`</span>,<span class="string">`class_id`</span>,<span class="string">`student_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">30</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4</span><br></pre></td></tr></table></figure>
<p>先创建一个表，这个表中有个联合索引 <code>grade_info_teacher_id_IDX</code></p>
<p>下面插入几条数据：</p>
<p><img src="/assets/picture/multiindex.png" alt="图片" title="grade_info 中的数据"></p>
<p>下面开始讨论下面几个问题:</p>
<pre><code>   `grade_info_teacher_id_IDX` (teacher_id, class_id, student_id) 这个索引如果查询条件只有teacher_id，会用上索引么？&lt;br /&gt;
   如果查询条件中有teacher_id, student_id会用上索引么？&lt;br /&gt;
   如果查询条件中有class_id, student_id会用上索引么？&lt;br /&gt;
   如果查询条件中有teacher_id, class_id会用上索引么？&lt;br /&gt;</code></pre>
<p><img src="/assets/picture/mysql_index_a.png" alt="图片" title="使用索引第一列的情况"></p>
<p>很明显当查询条件中使用了联合索引的第一列的时候会用上索引</p>
<p><img src="/assets/picture/mysql_index_a_c.png" alt="图片" title="使用索引第一列和第三列的情况"></p>
<p>这里当查询条件使用联合索引的第一列和第三列的时候也会用上索引，<br>但是这里有个问题， 图中的查询条件只会查询出一条，但是现在问题出现了， 但<code>explain</code> 结果中的row 是 2， 这里得知 索引只用到了第一列</p>
<p><img src="/assets/picture/mysql_index_b_c.png" alt="图片" title="使用索引第二列、第三列的情况"><br>很明显，这种查询条件没用上索引</p>
<p><img src="/assets/picture/mysql_index_a_c.png" alt="图片" title="使用索引第一列、第二列的情况"><br>这里使用到了索引，而且索引的长度和 只使用第一列的时候相比更长； 可以确定这里使用了索引的前两列</p>
<h3 id="索引的限制"><a href="#索引的限制" class="headerlink" title="索引的限制"></a>索引的限制</h3><p>这里说的索引的限制将能解释上面联合索引的问题</p>
<h4 id="1-如果不是按照索引的最左列开始查询，则无法使用索引"><a href="#1-如果不是按照索引的最左列开始查询，则无法使用索引" class="headerlink" title="1. 如果不是按照索引的最左列开始查询，则无法使用索引"></a>1. 如果不是按照索引的最左列开始查询，则无法使用索引</h4><p>如果查询条件中有class_id, student_id会用上索引么？<br>这里就能回答这个问题，不会；</p>
<h4 id="2-不能跳过索引中的列"><a href="#2-不能跳过索引中的列" class="headerlink" title="2. 不能跳过索引中的列"></a>2. 不能跳过索引中的列</h4><p>如果查询条件中有teacher_id, student_id会用上索引么？<br>这里跳过了第二列，这个时候只使用索引的第一列</p>
<h4 id="3-如果查询中有某列的范围查询，则其右边的所有列的查询都不能使用索引优化查找"><a href="#3-如果查询中有某列的范围查询，则其右边的所有列的查询都不能使用索引优化查找" class="headerlink" title="3. 如果查询中有某列的范围查询，则其右边的所有列的查询都不能使用索引优化查找"></a>3. 如果查询中有某列的范围查询，则其右边的所有列的查询都不能使用索引优化查找</h4><p><img src="/assets/picture/mysql_index_a_b_c_range.png" alt="图片" title="索引全覆盖，但最左列是范围查询"><br>从 <code>explain</code> 中 row 是 3， 但是查询到结果只有一个，而只按照第一列范围查询结果是3，这个例子可以印证上述限制</p>
<h3 id="索引的选择"><a href="#索引的选择" class="headerlink" title="索引的选择"></a>索引的选择</h3><p>突然发现一个问题，mysql 是如何选择索引的？</p>
<p>下面看看这个表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS &#96;school&#96;;</span><br><span class="line">CREATE TABLE &#96;school&#96; (</span><br><span class="line">  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,</span><br><span class="line">  &#96;name&#96; varchar(20) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;学校名称&#39;,</span><br><span class="line">  &#96;phone&#96; varchar(20) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;学校电话&#39;,</span><br><span class="line">  &#96;addr&#96; varchar(255) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;学校地址&#39;,</span><br><span class="line">  &#96;email&#96; varchar(30) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;idx_name_phone_email&#96; (&#96;name&#96;,&#96;phone&#96;,&#96;email&#96;),</span><br><span class="line">  KEY &#96;idx_name_phone&#96; (&#96;name&#96;,&#96;phone&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;2 DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;学校&#39;</span><br></pre></td></tr></table></figure>

<p><code>idx_name_phone_email</code> 和 <code>idx_name_phone</code> 这两个索引，设置的 <em>极不合理</em> ，这里 <em>不推荐使用</em> ， 但是这种情况下，mysql 会选择哪个索引呢？</p>
<p>插入一条测试数据<br><img src="/assets/picture/school_long_idx.png" alt="图片"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc <span class="keyword">select</span> * <span class="keyword">from</span> school <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">&#x27;重庆邮电大学&#x27;</span> <span class="keyword">and</span> phone = <span class="string">&#x27;76822313&#x27;</span>\G</span><br></pre></td></tr></table></figure>
<p>执行一下上面这个 sql 语句，两个索引都可能被用到，会是哪一个呢？</p>
<p>这里我们能看到，使用的是 <code>idx_name_phone_email</code><br><img src="/assets/picture/school_long_idx2.png" alt="图片" title="使用索引 `idx_name_phone_email`"></p>
<p>这里做一个简单的猜想，为什么使用的是 <code>idx_name_phone_email</code>, 这和索引的声明顺序有关吗？</p>
<p>重新建表看看：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`school`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`school`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;学校名称&#x27;</span>,</span><br><span class="line">  <span class="string">`phone`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;学校电话&#x27;</span>,</span><br><span class="line">  <span class="string">`addr`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;学校地址&#x27;</span>,</span><br><span class="line">  <span class="string">`email`</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_name_phone`</span> (<span class="string">`name`</span>,<span class="string">`phone`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_name_phone_email`</span> (<span class="string">`name`</span>,<span class="string">`phone`</span>,<span class="string">`email`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">2</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">&#x27;学校&#x27;</span></span><br></pre></td></tr></table></figure>

<p>修改了索引定义顺序之后， 使用的索引也随之改变了</p>
<p><img src="/assets/picture/school_short_idx.png" alt="图片" title="使用索引 `idx_name_phone`"></p>
<p>好像，我们的猜想被证实了</p>
<h6 id="如果我们需要指定使用哪个索引呢？"><a href="#如果我们需要指定使用哪个索引呢？" class="headerlink" title="如果我们需要指定使用哪个索引呢？"></a>如果我们需要指定使用哪个索引呢？</h6><p><img src="/assets/picture/school_short_idx.png" alt="图片" title="使用 force index"></p>
<p><code>force index(idx_name)</code>: 使用这个关键字强制指定要用的索引即可</p>
<p>还有其他方式吗？</p>
<p>可以 <code>use index(idx_name)</code> 推荐使用的索引</p>
<p><img src="/assets/picture/school_use_idx.png" alt="图片" title="使用 use index"></p>
<h6 id="use-index-和-force-index-的区别"><a href="#use-index-和-force-index-的区别" class="headerlink" title="use index 和 force index 的区别"></a><code>use index</code> 和 <code>force index</code> 的区别</h6><pre><code>    If you use USE INDEX then you RECOMMEND optimizer to use this index, but it can use a table scan if optimizer thinks it will be faster. If you use FORCE INDEX then you MAKE optimizer to use this index even if it thinks a table scan is more efficient. Optimizer will use a table scan only if there is no way to use index to find rows.</code></pre>
<p>也就是说， 使用 <code>USE INDEX</code> 时 sql 优化可能会进行全表扫描，如果全表扫描更快的话； 而使用 <code>FORCE INDEX</code> 时，只能是使用索引，除非查询条件没有命中索引</p>
<p>指定使用索引还有一个使用场景，就是解决之前说到的 <em>范围查询时，索引无效</em></p>
<p><img src="/assets/picture/school_force_idx_range_query.png" alt="图片" title="范围查询时强制使用索引"></p>
<p>除了指定要使用的索引，还能指定不使用哪些索引</p>
<p><img src="/assets/picture/school_ignore_idx.png" alt="图片" title="使用 ignore index"></p>
<p>排除掉不使用的索引，就能使用想要使用的索引</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 避免重复插入</title>
    <url>/2017/01/14/%E6%8A%80%E6%9C%AF/mysql/2017-01-14-mysql%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%8F%92%E5%85%A5/</url>
    <content><![CDATA[<h3 id="mysql-避免重复插入"><a href="#mysql-避免重复插入" class="headerlink" title="mysql 避免重复插入"></a>mysql 避免重复插入</h3><p><code>mysql</code> 避免重复插入的方式有这样几种</p>
<ol>
<li>使用 <code>ignore</code> 关键字</li>
<li>使用 <code>replace</code> 关键字</li>
<li>使用 <code>on duplicate key update</code></li>
</ol>
<hr>
<h4 id="使用-ignore-关键字"><a href="#使用-ignore-关键字" class="headerlink" title="使用 ignore 关键字"></a>使用 <code>ignore</code> 关键字</h4><p>当表中存在<code>主键</code>或者<code>唯一索引</code>的时候, 避免重复插入的时候，就可以使用以下命令</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">ignore</span> <span class="keyword">into</span> table_name <span class="keyword">set</span> <span class="keyword">name</span> = ?, <span class="keyword">desc</span> = ?</span><br></pre></td></tr></table></figure>

<p>当表中已经存在数据的时候，本次 <code>insert</code> 会被忽略</p>
<p><em>注意：需要注意的是 <code>insert ignore</code> 在忽略某一次插入的时候自增id 还是会增长的，举例如下：</em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb1`</span> (</span><br><span class="line"> <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;名称&#x27;</span>,</span><br><span class="line"> <span class="string">`modify_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;2000-01-01 00:00:00&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line"> PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">&#x27;测试表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into tb1 value(1, &quot;name1&quot;, now());</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into tb1 value(1, &quot;name2&quot;, now());</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;1&#x27; for key &#x27;PRIMARY&#x27;</span><br><span class="line">mysql&gt; select * from tb1;</span><br><span class="line">+<span class="comment">----+-------+---------------------+</span></span><br><span class="line">| id | name  | modify_time         |</span><br><span class="line">+<span class="comment">----+-------+---------------------+</span></span><br><span class="line">|  1 | name1 | 2018-07-25 13:35:27 |</span><br><span class="line">+<span class="comment">----+-------+---------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">insert</span> <span class="keyword">ignore</span> <span class="keyword">into</span> tb1 <span class="keyword">value</span>(<span class="number">1</span>, <span class="string">&quot;name2&quot;</span>, <span class="keyword">now</span>());</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="使用-replace-关键字"><a href="#使用-replace-关键字" class="headerlink" title="使用 replace 关键字"></a>使用 <code>replace</code> 关键字</h4><p>除了 <code>insert ignore</code> 之外还有 <code>replace into</code> 这里也要求表中必须存在 <code>主键</code> 或者 <code>唯一索引</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">replace</span> <span class="keyword">into</span> table_name <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">&#x27;a&#x27;</span>, <span class="keyword">desc</span> = <span class="string">&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>

<p>表中 name 必须存在 <code>唯一索引</code> ， 如果表中已经存在 name = ‘a’ 的时候， desc 的值将变更为 ‘b’</p>
<hr>
<h4 id="使用-on-duplicate-key-update"><a href="#使用-on-duplicate-key-update" class="headerlink" title="使用 on duplicate key update"></a>使用 <code>on duplicate key update</code></h4><p>当表中存在<code>主键</code>或者<code>唯一索引</code>的时候, 避免重复插入的时候，还可以使用以下命令</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name(uniq_name, <span class="keyword">desc</span>) <span class="keyword">values</span>(<span class="string">&#x27;exists_name&#x27;</span>, <span class="string">&#x27;desc&#x27;</span>) <span class="keyword">on</span> <span class="keyword">duplicate</span> <span class="keyword">key</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">count</span> = <span class="keyword">count</span>+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>上面的语句在避免重复插入的同时，还可以修改某一字段， 如果不需要修改任何字段，请使用一下语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name(uniq_name, <span class="keyword">desc</span>) <span class="keyword">values</span>(<span class="string">&#x27;exists_name&#x27;</span>, <span class="string">&#x27;desc&#x27;</span>) <span class="keyword">on</span> <span class="keyword">duplicate</span> <span class="keyword">key</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">desc</span> = <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<p>可以说 <code>on duplicate key update</code> 能够实现 <code>insert ignore</code> 和 <code>replace into</code> 的功能！</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql InnoDB 锁</title>
    <url>/2019/07/01/%E6%8A%80%E6%9C%AF/mysql/msyql-innodb-locking/</url>
    <content><![CDATA[<h2 id="InnoDB-支持的锁"><a href="#InnoDB-支持的锁" class="headerlink" title="InnoDB 支持的锁"></a>InnoDB 支持的锁</h2><ol>
<li>共享锁(S)和排它锁(X)</li>
<li>意向锁</li>
<li>行锁</li>
<li>间隙锁（GAP 锁）</li>
<li>Next-Key Locks</li>
<li>插入意向锁</li>
<li>自增长字段锁</li>
<li>Predicate Locks for Spatial Indexes</li>
</ol>
<h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>行级锁，实质上是锁定在一个索引记录上，<code>select ... for update</code> 会加锁, <code>delete</code>, <code>update</code> 也会加锁</p>
<h2 id="GAP-锁"><a href="#GAP-锁" class="headerlink" title="GAP 锁"></a>GAP 锁</h2><p>间隙锁也是作用在索引记录上，但是不同的是， GAP 锁锁定的是两条索引记录之间的间隙，而没有锁定索引记录本身</p>
<h2 id="Next-Key-锁"><a href="#Next-Key-锁" class="headerlink" title="Next-Key 锁"></a>Next-Key 锁</h2><p><code>Next-Key 锁</code>是行级锁和 GAP 锁的集合，它会锁定命中的索引记录以及这个索引记录前的间隙。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring揭秘读书笔记 —— IOC 基本概念</title>
    <url>/2016/07/15/%E6%8A%80%E6%9C%AF/spring/2016-07-15-Spring%E6%8F%AD%E7%A7%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94IOC%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一直在使用Spring 这一开源项目， 但是在学习spring 的过程中一直没遇到让我心旷神怡的好书，看过 <code>《Spring技术内幕：深入解析Spring架构与设计原理（第2版）》</code>， 从源码角度讲解spring， 虽然也很不错， 但是略感枯燥。  另外就是开涛大神的 <code>跟我学Spring</code>(<a href="http://jinnianshilongnian.iteye.com/blog/1482071">http://jinnianshilongnian.iteye.com/blog/1482071</a>) 和 <code>跟我学Spring MVC</code>(<a href="http://jinnianshilongnian.iteye.com/blog/1617451">http://jinnianshilongnian.iteye.com/blog/1617451</a>), 这两个系列的博客，主要是从使用Spring 的角度出发，很适合初学者系列的学习Spring 的使用以及一些Spring 的原理。</p>
<h6 id="以上对两位大神的著作的评论仅属个人言论，欢迎大家指正"><a href="#以上对两位大神的著作的评论仅属个人言论，欢迎大家指正" class="headerlink" title="以上对两位大神的著作的评论仅属个人言论，欢迎大家指正"></a>以上对两位大神的著作的评论仅属个人言论，欢迎大家指正</h6><p>最近接触到一本比较 <code>古老</code> 的 Spring 学习书籍 ———— <code>《Spring揭秘》</code> , 这本书貌似现在已经停刊了，讲的 Spring 也是将的 <code>Spring 2.X</code> , 但是 Spring 的主要思想，在这本书中被作者用一种通俗易懂的语言表达的让人能一边看，一边笑着点头， 甚是舒畅。</p>
<hr>
<h2 id="IoC的基本概念读书笔记"><a href="#IoC的基本概念读书笔记" class="headerlink" title="IoC的基本概念读书笔记"></a>IoC的基本概念读书笔记</h2><h4 id="IoC-控制反转-————-我们的理念是：让别人为你服务"><a href="#IoC-控制反转-————-我们的理念是：让别人为你服务" class="headerlink" title="IoC [控制反转] ———— 我们的理念是：让别人为你服务"></a>IoC [控制反转] ———— 我们的理念是：让别人为你服务</h4><p>书中的比喻很形象<br><img src="/assets/picture/iocmetaphor.png" title="IoC形象比喻"></p>
<p>常见的 Ioc 实现方法</p>
<ol>
<li>构造方法注入</li>
<li>setter方法注入</li>
<li>接口注入</li>
</ol>
<p>三种方法中 <code>接口注入</code> 较为难理解<br>被注入的对象要想 Ioc Service Provider 为其注入依赖对象， 就要实现一个特定接口，特定的接口提供一个方法，用来为其注入一个依赖对象，这个特性接口就如同是上图比喻中的 “拿衣服的女朋友”</p>
<p>示例：<br><img src="/assets/picture/ioc.interfaceinsert.demo.png"><br>FxNewsProvider 希望能被注入依赖 IFXNewsListener, 使用接口注入时，实现 FXNewsListenerCallable 接口  FXNewListenerCallable 接口提供了 injectNewsListener 方法, 这个方法的参数的类型就是 IFXNewsListenr</p>
<p><code>接口注入</code>这种注入方式目前已经过时，不提倡使用</p>
<p><code>构造方法注入</code> 在对象构造完之后，就会立即进入就绪状态，可以马上使用。但是如果依赖的对象比较多，构造方法的参数列表会比较长，而且<code>构造方法注入</code>底层实现还是基于反射机制，而反射机制对于构造方法中相同类型的参数处理会有困难；而且构造方法不能被继承，不能设置默认值</p>
<p><code>setter方法注入</code> setter 方法参数单一，反射机制可以很好的支持，而且setter 方法能被继承，能够设置默认值</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>《Spring揭秘》</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql InnoDDB 的 undo log 和 mvcc</title>
    <url>/2020/07/01/%E6%8A%80%E6%9C%AF/mysql/mysql%20undo%20log%20%E5%92%8C%20mvcc/</url>
    <content><![CDATA[<h1 id="Mysql-InnoDB-的事务"><a href="#Mysql-InnoDB-的事务" class="headerlink" title="Mysql InnoDB  的事务"></a>Mysql InnoDB  的事务</h1><h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><h1 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h1><p>InnoDB  的行记录中有三个隐藏字段，<br>DB_TRX_ID: 记录最近更新这条信息的事务 ID，字段长度 6字节<br>DB_ROLL_PTR: 回滚指针，指向保存在 <code>rollback_segment</code> 中的 <code>undo log</code>, 长度 7 个字节<br>DB_ROW_ID: 行ID，如果 InnoDB 中没有自增长的聚簇索引，这个值会被认位是行的唯一标识存储在索引中</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Protobuf 简单使用</title>
    <url>/2017/01/01/%E6%8A%80%E6%9C%AF/protobuf/2017-01-01-Protobuf%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="一个简单的介绍"><a href="#一个简单的介绍" class="headerlink" title="一个简单的介绍"></a>一个简单的介绍</h3><p>Google Protocol Buffer( 简称 Protobuf) 是 Google 公司内部的混合语言数据标准，目前已经正在使用的有超过 48,162 种报文格式定义和超过 12,183 个 .proto 文件。他们用于 RPC 系统和持续数据存储系统。<br>Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 等多种语言的 API。<br>详见：<a href="https://github.com/google/protobuf">GitHub</a></p>
<h3 id="安装-protobuf"><a href="#安装-protobuf" class="headerlink" title="安装 protobuf"></a>安装 protobuf</h3><p>首先我们需要安装 protobuf</p>
<p>这里我介绍一下我在 macOS 中使用 <code>brew</code> 安装 <code>protobuf</code></p>
<ol>
<li>首先我们看看可以安装的选项</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew search protobuf</span><br></pre></td></tr></table></figure>
<p><img src="/assets/picture/brew_search_protobuf.png" alt="图片" title="brew search protobuf 结果图"></p>
<p><em>这里因为我已经安装了 <code>protobuf250</code>, 所以这里有个小 ✔️</em></p>
<p>如果这里的搜索结果中没有查看到版本相关信息， 执行下面的指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew tap homebrew/versions</span><br></pre></td></tr></table></figure>

<p>这样以后 使用 <code>brew search appName</code> 的时候就能看到不同版本的应用了</p>
<ol start="2">
<li>使用 brew 安装</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install protobuf250</span><br></pre></td></tr></table></figure>

<p>安装成功之后可以检验一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protoc -version</span><br></pre></td></tr></table></figure>

<h3 id="protoc-指令"><a href="#protoc-指令" class="headerlink" title="protoc 指令"></a>protoc 指令</h3><p>下面我们就能使用 <code>protoc</code> 指令来讲 <code>.proto</code> 文件编译成 protobuf 支持的其他语言的文件了，例如 <code>.java</code> 文件</p>
<p>指令如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">protoc --java_out=/path/to/java/out/dir/ ./Demo.proto</span><br></pre></td></tr></table></figure>

<p>将 <em>Demo.proto</em> 编译成 <em>Demo.java</em> 文件， 并且输入到 <code>/path/to/java/out/dir</code></p>
<p>具体介绍见<br><a href="%22https://summerbuger.github.io/2017/01/01/protoc%E6%8C%87%E4%BB%A4%E4%BB%8B%E7%BB%8D.html%22," title="protoc 指令介绍">protoc 指令介绍</a></p>
<h3 id="Intellij-Idea-使用-Google-Protocol-Buffers-Support"><a href="#Intellij-Idea-使用-Google-Protocol-Buffers-Support" class="headerlink" title="Intellij Idea 使用 Google Protocol Buffers Support"></a>Intellij Idea 使用 <code>Google Protocol Buffers Support</code></h3><p>当然，日常开发过程中，我们都是使用 <code>IDE</code>, 如 <code>Intellij Idea</code><br><code>Intellij Idea</code> 对 <code>protobuf</code> 的支持比较好</p>
<p>1 安装 <code>Google Protocol Buffers Support</code> 插件</p>
<p><img src="/assets/picture/intellij_idea_proto_plugin.png" alt="图片" title="搜索 proto 相关插件"><br><img src="/assets/picture/google_protocol_buffers_support.png" alt="图片" title="Google Protocol Buffers Support"></p>
<p>2 添加 <code>Protobuf Facet</code><br><img src="/assets/picture/project_setting_modules.png" alt="图片" title="Project Setting modules"><br><img src="/assets/picture/protobuf_facet.png" alt="图片" title="添加 Protobuf Facet"><br><img src="/assets/picture/java_output_dir.png" alt="图片" title="设置 java 文件输出文件夹"></p>
<p>3 点击 <code>Build Project</code> 按钮</p>
<h3 id="proto-文件"><a href="#proto-文件" class="headerlink" title=".proto 文件"></a><code>.proto</code> 文件</h3>]]></content>
      <categories>
        <category>protobuf</category>
      </categories>
      <tags>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title>protoc 指令介绍</title>
    <url>/2017/01/01/%E6%8A%80%E6%9C%AF/protobuf/2017-01-01-protoc%E6%8C%87%E4%BB%A4%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="protoc-指令介绍"><a href="#protoc-指令介绍" class="headerlink" title="protoc 指令介绍"></a>protoc 指令介绍</h3><p><code>protoc</code> 指令使用示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">protoc [参数] .proto文件路径</span><br></pre></td></tr></table></figure>

<p>使用 <code>protoc</code> 指令讲 <code>.proto</code> 文件编译成 <code>.java</code> 文件的简单使用如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">protoc --java_out=./ /path_to_proto_file/Demo.proto</span><br></pre></td></tr></table></figure>

<p>protoc 指令参数翻译如下</p>
<h6 id="注意：-protoc-对文件路径不敏感，所有参数中的路径，必须是绝对路径"><a href="#注意：-protoc-对文件路径不敏感，所有参数中的路径，必须是绝对路径" class="headerlink" title="注意： protoc 对文件路径不敏感，所有参数中的路径，必须是绝对路径"></a><em>注意： <code>protoc</code> 对文件路径不敏感，所有参数中的路径，必须是绝对路径</em></h6><hr>
<p>-I[PATH], –proto_path=[PATH]: 指定 import 修饰符扫描文件夹；可以指定多次，被指定的文件夹将按照先后制定顺序被扫描；如果没有指定，将使用当前文件夹作为扫描文件夹</p>
<h6 id="注意：-这里的-PATH-必须是绝对路径"><a href="#注意：-这里的-PATH-必须是绝对路径" class="headerlink" title="注意： 这里的[PATH]必须是绝对路径"></a><em>注意： 这里的[PATH]必须是绝对路径</em></h6><hr>
<p>–version: 查看 protoc 指令版本</p>
<hr>
<p>-h, –help: 查看帮助文档</p>
<hr>
<p>–encode=MESSAGE_TYPE</p>
<hr>
<p>–decode=MESSAGE_TYPE</p>
<p>–decode_raw</p>
<p>-o[FILE], –descriptor_set_out=[FILE]</p>
<p>–include_imports</p>
<p>–include_source_info</p>
<p>–error_format</p>
<hr>
<p>–java_out=[PATH]: 指定生成的java文件的输出文件夹</p>
<p><em>注意 <code>.proto</code> 文件中如果指定了 java_package， 会在输出文件夹中创建java 的package</em></p>
<hr>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ : ✗ protoc -h</span><br><span class="line">Usage: protoc [OPTION] PROTO_FILES</span><br><span class="line">Parse PROTO_FILES and generate output based on the options given:</span><br><span class="line">  -IPATH, --proto_path=PATH   Specify the directory in which to search for</span><br><span class="line">                              imports.  May be specified multiple times;</span><br><span class="line">                              directories will be searched in order.  If not</span><br><span class="line">                              given, the current working directory is used.</span><br><span class="line">  --version                   Show version info and exit.</span><br><span class="line">  -h, --help                  Show this text and exit.</span><br><span class="line">  --encode=MESSAGE_TYPE       Read a text-format message of the given type</span><br><span class="line">                              from standard input and write it in binary</span><br><span class="line">                              to standard output.  The message type must</span><br><span class="line">                              be defined in PROTO_FILES or their imports.</span><br><span class="line">  --decode=MESSAGE_TYPE       Read a binary message of the given type from</span><br><span class="line">                              standard input and write it in text format</span><br><span class="line">                              to standard output.  The message type must</span><br><span class="line">                              be defined in PROTO_FILES or their imports.</span><br><span class="line">  --decode_raw                Read an arbitrary protocol message from</span><br><span class="line">                              standard input and write the raw tag/value</span><br><span class="line">                              pairs in text format to standard output.  No</span><br><span class="line">                              PROTO_FILES should be given when using this</span><br><span class="line">                              flag.</span><br><span class="line">  -oFILE,                     Writes a FileDescriptorSet (a protocol buffer,</span><br><span class="line">    --descriptor_set_out=FILE defined in descriptor.proto) containing all of</span><br><span class="line">                              the input files to FILE.</span><br><span class="line">  --include_imports           When using --descriptor_set_out, also include</span><br><span class="line">                              all dependencies of the input files in the</span><br><span class="line">                              set, so that the set is self-contained.</span><br><span class="line">  --include_source_info       When using --descriptor_set_out, do not strip</span><br><span class="line">                              SourceCodeInfo from the FileDescriptorProto.</span><br><span class="line">                              This results in vastly larger descriptors that</span><br><span class="line">                              include information about the original</span><br><span class="line">                              location of each decl in the source file as</span><br><span class="line">                              well as surrounding comments.</span><br><span class="line">  --error_format=FORMAT       Set the format in which to print errors.</span><br><span class="line">                              FORMAT may be &#x27;gcc&#x27; (the default) or &#x27;msvs&#x27;</span><br><span class="line">                              (Microsoft Visual Studio format).</span><br><span class="line">  --plugin=EXECUTABLE         Specifies a plugin executable to use.</span><br><span class="line">                              Normally, protoc searches the PATH for</span><br><span class="line">                              plugins, but you may specify additional</span><br><span class="line">                              executables not in the path using this flag.</span><br><span class="line">                              Additionally, EXECUTABLE may be of the form</span><br><span class="line">                              NAME=PATH, in which case the given plugin name</span><br><span class="line">                              is mapped to the given executable even if</span><br><span class="line">                              the executable&#x27;s own name differs.</span><br><span class="line">  --cpp_out=OUT_DIR           Generate C++ header and source.</span><br><span class="line">  --java_out=OUT_DIR          Generate Java source file.</span><br><span class="line">  --python_out=OUT_DIR        Generate Python source file.</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>protobuf</category>
      </categories>
      <tags>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 中的 @ControllerAdvice</title>
    <url>/2016/12/10/%E6%8A%80%E6%9C%AF/spring/2016-12-10-SpringMvc-@ControllerAdvice/</url>
    <content><![CDATA[<h1 id="Spring-MVC-中的-ControllerAdvice"><a href="#Spring-MVC-中的-ControllerAdvice" class="headerlink" title="Spring MVC 中的 @ControllerAdvice"></a>Spring MVC 中的 @ControllerAdvice</h1><h2 id="ControllerAdvice-简介"><a href="#ControllerAdvice-简介" class="headerlink" title="@ControllerAdvice 简介"></a><code>@ControllerAdvice</code> 简介</h2><p><code>Spring MVC</code> 中常用的注解网上有很多介绍，<code>@ControllerAdvice</code> 这个注解相对来说少见一点；从名称上就能看出， <code>@ControllerAdvice</code> 是用来增强 <code>@Controller</code> 的</p>
<pre><code>            使用 `@ControllerAdvice` 注解可以增强控制器 Controller，带有 `@ControllerAdvice` 注解的类，可以包含 @ExceptionHandler、@InitBinder, 和 `@ModelAttribute` 注解的方法，
            并且这些注解的方法会通过控制器层次应用到所有 `@RequestMapping` 方法中，而不用一一在控制器内部声明。</code></pre>
<h2 id="使用-ControllerAdvice-进行异常处理"><a href="#使用-ControllerAdvice-进行异常处理" class="headerlink" title="使用 @ControllerAdvice 进行异常处理"></a>使用 <code>@ControllerAdvice</code> 进行异常处理</h2><p>看到上面这段话，大家有没有一种兴奋感？<br>在没有 <code>@ControllerAdvice</code> 之前， 我们是怎么使用 <code>@ExceptionHandler</code> 的呢？ 很简单，我们给 <code>Controller</code> 定义父类，在父类中创建一个方法，被 <code>@ExceptionHandler</code> 修饰的方法，</p>
<p>而有了 @ControllerAdvice 之后，我们并不需要定义什么父类，只要用 <code>@ControllerAdvice</code> 修饰一个类，它就能成为全局异常处理器了！</p>
<pre><code>            Talk is cheap, show me the code!</code></pre>
<p>先来一个 Controller:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/spring/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;test exceptions&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来一个 ControllerAdvice, 直接返回一个 json 格式的异常信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseControllerAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handlerException</span><span class="params">(Exception e, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;exception: &#123;&#125;&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来贴一下 spring 配置信息:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.springdemo.liam&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.web.bind.annotation.ControllerAdvice&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Service&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>看看运行结果，很不错，我们实现了全剧异常处理<br><img src="/assets/picture/errHandler.png" alt="图片"></p>
<p>到这里大家会比较疑惑，为什么 ControllerAdvice 可以被自动扫描呢？</p>
<p>先来看看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ControllerAdvice &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(&quot;basePackages&quot;)</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] assignableTypes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt;[] annotations() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到 <code>@ControllerAdvice</code> 是一个 <code>@Component</code>, 它当然能被扫描注册到上下文中</p>
<h2 id="ControllerAdvice-异常处理实现原理"><a href="#ControllerAdvice-异常处理实现原理" class="headerlink" title="@ControllerAdvice 异常处理实现原理"></a><code>@ControllerAdvice</code> 异常处理实现原理</h2><p>Spring MVC 中异常处理器中最常用的就是  <code>ExceptionHandlerExceptionResovler</code>，它维护了一个 @ControllerAdvice 注解修饰的类 @ExceptionHandler 修饰的异常处理方法的缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandlerExceptionResolver</span> <span class="keyword">extends</span> <span class="title">AbstractHandlerMethodExceptionResolver</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @ControllerAdvice 对应 ExceptionHandlerMethodResolver 的 Map 缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ControllerAdviceBean, ExceptionHandlerMethodResolver&gt; exceptionHandlerAdviceCache =</span><br><span class="line">            <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 缓存新建默认 HandlerMethodReturnValueHandler 时用到的 ResponseBodyAdvice 列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; responseBodyAdvice = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>exceptionHandlerAdviceCache</code> 在 <code>ExceptionHandlerExceptionResovler</code> 初始化的时候被赋值</p>
<p><img src="/assets/picture/exception_handler_init_with_controller_advice.png" alt="初始化 ExceptionHandlerExceptionResovler 中的 exceptionHandlerAdviceCache" title="初始化 ExceptionHandlerExceptionResovler 中的 exceptionHandlerAdviceCache"></p>
<p>在从处理器 Controller 中获取不到 @ExceptionHandler 修饰的异常处理方法后，会从 <code>exceptionHandlerAdviceCache</code> 中获取 <code>ExceptionHandlerExceptionResovler</code> 再获取到异常处理方法</p>
<p><img src="/assets/picture/find_exception_handler_from_controller_advice_cache.png" alt="从 @ControllerAdvice 缓存中获取 ExceptionHandler" title="从 @ControllerAdvice 缓存中获取 ExceptionHandler"></p>
<p><code>ExceptionHandlerExceptionResovler</code> 还会对调用返回值处理器对返回值进行处理，而初始化时候赋值的 <code>responseBodyAdvice</code> 会被用来新建默认的 <code>HandlerMethodReturnValueHandler</code>，主要是 <code>RequestResponseBodyMethodProcessor</code></p>
<p><img src="/assets/picture/init_request_response_body_method_processo_with_response_body_advice.png" alt="使用 responseBodyAdviceCache 创建 HandlerMethodReturnValueHandler" title="使用 responseBodyAdviceCache 创建 HandlerMethodReturnValueHandler"></p>
<p><img src="/assets/picture/invoke_return_value_hanlder_after_invoke_exception_handler_method.png" alt="调用 HandlerMethodReturnValueHandler 处理返回值" title="调用 HandlerMethodReturnValueHandler 处理返回值"></p>
<p>在 <code>RequestResponseBodyMethodProcessor</code> 中会调用 <code>ResponseBodyAdvice#beforeBodyWrite</code> 对返回结果进行插入处理</p>
<p><img src="/assets/picture/return_value_handler_invoke_message_converter_with_response_body_advice.png" alt="调用 ResponseBodyAdvice" title="调用 ResponseBodyAdvice"></p>
<p><code>ResponseBodyAdvice</code> 是 <code>Spring 4.2</code> 以来的新特性</p>
<p><code>ResponseBodyAdvice</code> 的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResponseBodyAdvice</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Whether this component supports the given controller method return type</span></span><br><span class="line"><span class="comment">     * and the selected &#123;<span class="doctag">@code</span> HttpMessageConverter&#125; type.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> returnType the return type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> converterType the selected converter type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if &#123;<span class="doctag">@link</span> #beforeBodyWrite&#125; should be invoked, &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invoked after an &#123;<span class="doctag">@code</span> HttpMessageConverter&#125; is selected and just before</span></span><br><span class="line"><span class="comment">     * its write method is invoked.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> body the body to be written</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> returnType the return type of the controller method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> selectedContentType the content type selected through content negotiation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> selectedConverterType the converter type selected to write to the response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request the current request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response the current response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the body that was passed in or a modified, possibly new instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">beforeBodyWrite</span><span class="params">(T body, MethodParameter returnType, MediaType selectedContentType,</span></span></span><br><span class="line"><span class="function"><span class="params">            Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType,</span></span></span><br><span class="line"><span class="function"><span class="params">            ServerHttpRequest request, ServerHttpResponse response)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是使用 @ControllerAdvice 加 ResponseBodyAdvice 的使用效果 ———— 在 ResponseBodyAdvice 中改写返回结果<br>实际业务中可以进行统一返回值处理，例如国际化处理等等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice(annotations = RestController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleResponseBodyAdvice</span> <span class="keyword">implements</span> <span class="title">ResponseBodyAdvice</span>&lt;<span class="title">Result</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验是否是需要的接入点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> returnType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> converterType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(MethodParameter returnType, Class converterType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> returnType.getMethod().getReturnType().equals(Result.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在往 outputStream 中写入返回结果之前，对返回结果进行处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">beforeBodyWrite</span><span class="params">(Result body, MethodParameter returnType, MediaType selectedContentType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  ServerHttpRequest request, ServerHttpResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> body.withRet(<span class="keyword">false</span>).withData(<span class="string">&quot;被 ResponseBodyAdvice 修改的结果&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test/rest&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result&lt;String&gt; <span class="title">testRest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="keyword">true</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看结果：</p>
<p><img src="/assets/picture/responseBodyDemo.png" alt="图片"></p>
<h2 id="ControllerAdvice-和-InitBinder、-ModelAttribute"><a href="#ControllerAdvice-和-InitBinder、-ModelAttribute" class="headerlink" title="@ControllerAdvice 和 @InitBinder、@ModelAttribute"></a>@ControllerAdvice 和 @InitBinder、@ModelAttribute</h2><p>在 Spring MVC 的组件中 <code>HandlerAdapter</code> 负责为请求匹配处理器、调用参数解析器解析参数、通过反射调用处理器、调用返回值处理器处理返回值；<br>而 <code>RequestMappingHandleAdapter</code> 是默认的第一个被调用的 <code>HanlderAdapter</code>, 它维护了 @ControllerAdvice 对应的 @InitBinder 的缓存以及 @ControllerAdvice 对应 @ModelAttribute 的缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestMappingHandlerAdapter</span> <span class="keyword">extends</span> <span class="title">AbstractHandlerMethodAdapter</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">// @ControllerAdvice 修饰的 Bean 和其中 @InitBinder 修饰的方法的映射缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt; initBinderAdviceCache = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// @ControllerAdvice 修饰的 Bean 和其中 @ModelAttribute 修饰的方法的映射缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt; modelAttributeAdviceCache = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RequestMappingHandleAdapter</code> 在初始化的时候会填充上述两个缓存</p>
<p><img src="/assets/picture/init_controller_advice_cache_for_handler_adapter.png" alt="初始化 @ControllerAdvice 缓存" title="初始化 @ControllerAdvice 缓存"></p>
<ul>
<li>首先查找到 @ControllerAdvice 修饰的 Bean</li>
<li>从 @ControllerAdvice Bean 中查找 @InitBinder 修饰的方法，放入 initBinderAdviceCache 中</li>
<li>从 @ControllerAdvice Bean 中查找 @ModelAttribute 修饰的方法，放入 modelAttributeAdviceCache 中</li>
</ul>
<p><img src="/assets/picture/fill_controller_advice_cache_for_handler_adapter.png" alt="查找 @InitBinder 和 @ModelAttribute放入缓存" title="查找 @InitBinder 和 @ModelAttribute放入缓存"></p>
<p><code>RequestMappingHandleAdapter</code> 在解析参数、调动处理器之前会做一些前置操作</p>
<ol>
<li>查找处理器 Controller 中或者 @ControllerAdvice 中 @InitBinder 修饰的方法，构建 WebDataBinderFactory，用于创建 WebDataBinder，在实例化 WebDataBinder 后调用 @InitBinder 修饰的方法对 WebDataBinder 进行自定义设置，而这个 WebDataBinderFactory 会用于调用 @ModelAttribute 修饰的方法，以及调用处理方法的过程中</li>
</ol>
<p><img src="/assets/picture/web_data_binder_factory_for_handler_adapter.png" alt="创建 WebDataBinderFactory" title="创建 WebDataBinderFactory"></p>
<ol start="2">
<li>调用 <code>@ControllerAttribute</code> 修饰的方法，将返回结果放入 Model 中；</li>
</ol>
<p><img src="/assets/picture/handler_adapter_init_model.png" alt="ModelFactory#initModel" title="ModelFactory#initModel"><br><img src="/assets/picture/handler_adapter_invoke_model_attribute_method.png" alt="ModelFactory#invokeModelAttributeMethods" title="ModelFactory#invokeModelAttributeMethods"><br><img src="/assets/picture/handler_adapter_do_invoke_method_attribute_method.png" alt="modelMethod.invokeForRequest" title="modelMethod.invokeForRequest"></p>
<ol start="3">
<li>调用 <code>@ControllerAttribute</code> 修饰的方法时，在 HandlerMethodArgumentResolver 中调用 WebDataBinderFactory 中 @InitBinder 修饰的方法创建 WebDataBiner，进行参数的校验及校验结果处理；在 @InitBinder 修饰的方法中可以对 WebDataBinder 的 Bean 进行自定义的设置</li>
</ol>
<p><img src="/assets/picture/web_data_binder_for_resolve_argument.png" alt="HandlerMethodArgumentResolver 使用 WebDataBinder" title="HandlerMethodArgumentResolver 使用 WebDataBinder"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring揭秘读书笔记 —— IOC BeanFactory</title>
    <url>/2016/07/15/%E6%8A%80%E6%9C%AF/spring/2016-07-15-Spring%E6%8F%AD%E7%A7%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94IOC%E4%B9%8BBeanFactory/</url>
    <content><![CDATA[<h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>Spring 的Ioc 容器除了是 Ioc Service Provider 还提供了其他的功能， 这边笔记将介绍 Ioc 容器的 Ioc 相关支持以及衍生的高级特性</p>
<p>Spring 中提供两种IOC 容器， <code>BeanFactory</code> 和  <code>ApplicationContext</code></p>
<h5 id="BeanFactory-1"><a href="#BeanFactory-1" class="headerlink" title="BeanFactory:"></a><code>BeanFactory</code>:</h5><p>基本类型的ICO 容器， 提供完整的IOC支持。 默认采用延迟初始化策略(lazy-load) 只有客户端对象需要访问容器中某个收管理的对象的时候， 才对该受管理的对象进行初始化以及依赖注入的操作。</p>
<h5 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a><code>ApplicationContext</code></h5><p>留待下章讲解</p>
<p>先看看 <code>BeanFactory</code> 的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Used to dereference a FactoryBean instance and distinguish it from beans created by the FactoryBean.</span></span><br><span class="line"><span class="comment">   * 这个前缀用于区分FactoryBean， 当想从BeanFactory 中获取一个FactoryBean 对象的时候，会返回这个工厂类</span></span><br><span class="line"><span class="comment">   * For example, if the bean named  myJndiObject is a FactoryBean, getting  myJndiObject will return the factory, not the instance returned by the factory.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String FACTORY_BEAN_PREFIX = <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment">     * (only applied when creating a new instance as opposed to retrieving an existing one)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 4.1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    String[] getAliases(String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/assets/picture/beanDefinition.png" title="BeanDefinition 类图"></p>
<p>讲到了 BeanFactory 不得不提 BeanDefinitionRegister</p>
<p><code>Spring IOC</code> 中的 <code>BeanDefinition</code> 封装了一个被管理的Bean 的所有信息， 再通过 <code>BeanDefinitionRegister</code> 将 Bean 注册到 IOC 容器中去</p>
<p>本章章节比较易懂， 这里主要讲讲没这么提及的FactoryBean。</p>
<h5 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean :"></a><code>FactoryBean</code> :</h5><p><code>FactoryBean</code> 从命名上看跟  <code>BeanFactory</code> 很容易混淆。 <code>FactoryBean</code> 是 Spring 提供的一种可以扩展容器对象实例化逻辑的接口， 这个命名主语是Bean，定语是Factory； 也就是说它是 Spring 管理的一个普通的Bean， 只是它相对于生产对象来说，它是一个工厂。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.liam.learn.ioc.factorybean.DateWithFactoryBean&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dateWithFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dateTimeFormatter&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;dateTimeFormatter&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dateTimeFormatter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.format.datetime.standard.DateTimeFormatterFactoryBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>


<p>获取FactoryBean 的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring-config.xml&quot;</span>);</span><br><span class="line">    DateTimeFormatterFactoryBean dateTimeFormatter = (DateTimeFormatterFactoryBean) applicationContext.getBean(<span class="string">&quot;&amp;dateTimeFormatter&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BeanFactory</code> 中的 <code>getObjectForBeanInstance</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Object beanInstance, String name, String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don&#x27;t let calling code try to dereference the factory if the bean isn&#x27;t a factory.</span></span><br><span class="line">   <span class="comment">// 如果 bean 的名称以&#x27;&amp;&#x27;开头 并且 bean的类型不属于 FactoryBean 将抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now we have the bean instance, which may be a normal bean or a FactoryBean.</span></span><br><span class="line">    <span class="comment">// If it&#x27;s a FactoryBean, we use it to create a bean instance, unless the</span></span><br><span class="line">    <span class="comment">// caller actually wants a reference to the factory.</span></span><br><span class="line">   <span class="comment">// 如果当前 Bean 的引用类型不是 FactoryBean 或者 bean 的名称以 &#x27;&amp;&#x27; 开头直接返回这个引用</span></span><br><span class="line">    <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object object = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span>) &#123;  <span class="comment">// 从缓存中获取FactoryBean 的引用</span></span><br><span class="line">        object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 如果缓存中没有这个FactoryBean 的引用； 将新建引用，存到缓存中，并返回</span></span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Return bean instance from factory.</span></span><br><span class="line">        FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">        <span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line">        <span class="keyword">if</span> (mbd == <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> synthetic = (mbd != <span class="keyword">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">        object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>《Spring揭秘》</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring揭秘读书笔记 —— 如何干涉IOC容器</title>
    <url>/2016/07/16/%E6%8A%80%E6%9C%AF/spring/2016-07-16-Spring%E6%8F%AD%E7%A7%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E5%B9%B2%E6%B6%89IOC%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Spring IOC 容器在加载 Bean 的时候，可以大致分为两个阶段</p>
<ol>
<li>容器启动阶段</li>
<li>Bean 实例化阶段</li>
</ol>
<h3 id="插手容器启动阶段"><a href="#插手容器启动阶段" class="headerlink" title="插手容器启动阶段"></a>插手容器启动阶段</h3><p>容器启动阶段简而言之就是将 通过注解或者在 xml 文件中配置信息，解析转化为 <code>BeanDefinition</code>， 再通过 <code>BeanDefinitionRegister</code> 注册到容器中<br>这个阶段主要是一些收集准备工作</p>
<p><code>Spring</code> 提供给我们插手这一阶段的方式是： 实现 <code>BeanFactoryPostProcessor</code></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>《Spring揭秘》</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 容器 和 Spring 容器</title>
    <url>/2017/01/21/%E6%8A%80%E6%9C%AF/spring/2017-01-21-SpringMvc%E5%92%8CSpring%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>在使用 <code>Spring MVC</code> 的过程中，遇到一个问题，在 <code>Spring 容器</code> 中注册的属性文件， 在 <code>SpringMVC 容器</code> 中无法用 <code>@Value</code> 标签引入！<br>按理说， <code>SpringMVC 容器</code> 应该能继承父容器中的所有Bean， 为什么不能使用父容器中引入的配置文件信息呢？</p>
<p><em>很遗憾，这个问题暂时没能找到答案，如果哪位大神能解答，请告知</em></p>
<p>但是问题还是要解决的， 我们只能换个思路解决。 如果 <code>SpringMVC 子容器</code> 和 <code>Spring 父容器</code> 如果合一了，不就不存在需要重复引入的问题吗？<br>那么问题来了：</p>
<h3 id="SpringMVC-容器和-Spring-容器能合一吗？"><a href="#SpringMVC-容器和-Spring-容器能合一吗？" class="headerlink" title="SpringMVC 容器和 Spring 容器能合一吗？"></a>SpringMVC 容器和 Spring 容器能合一吗？</h3><p>先来看看一般我们使用 <code>SpringMVC</code> 的 <code>web.xml</code> 配置文件，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE web-app PUBLIC</span><br><span class="line">        &quot;-&#x2F;&#x2F;Sun Microsystems, Inc.&#x2F;&#x2F;DTD Web Application 2.3&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;java.sun.com&#x2F;dtd&#x2F;web-app_2_3.dtd&quot; &gt;</span><br><span class="line"></span><br><span class="line">&lt;web-app&gt;</span><br><span class="line">    &lt;display-name&gt;Archetype Created Web Application&lt;&#x2F;display-name&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- spring 父容器配置文件路径 --&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">        &lt;param-value&gt;classpath:spring&#x2F;spring-root.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">    &lt;&#x2F;context-param&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- listener：加载spring 父容器 --&gt;</span><br><span class="line">    &lt;listener&gt;</span><br><span class="line">        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;</span><br><span class="line">    &lt;&#x2F;listener&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;dispatcher&lt;&#x2F;servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">                &lt;!-- spring mvc 子容器配置文件路径，如果不配置默认为 &#x2F;WEB-INF&#x2F;*-servlet.xml --&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">            &lt;param-value&gt;classpath:spring&#x2F;spring-mvc.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">        &lt;&#x2F;init-param&gt;</span><br><span class="line">    &lt;&#x2F;servlet&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;dispatcher&lt;&#x2F;servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;</span><br><span class="line">    &lt;&#x2F;servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">    &lt;error-page&gt;</span><br><span class="line">        &lt;error-code&gt;500&lt;&#x2F;error-code&gt;</span><br><span class="line">        &lt;location&gt;&#x2F;error.jsp&lt;&#x2F;location&gt;</span><br><span class="line">    &lt;&#x2F;error-page&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;web-app&gt;</span><br></pre></td></tr></table></figure>

<p><code>Tomcat</code> 在解析 <code>web.xml</code> 的时候先后加载 <code>listener</code> -&gt; <code>filter</code> -&gt; <code>servlet</code><br>先记载 <code>ContextLoaderListener</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 覆写 `ServletContextListener` 中的 `contextInitialized` 方法，</span></span><br><span class="line"><span class="comment">* 实现时，调用父类的 `initWebApplicationContext` 方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">    initWebApplicationContext(event.getServletContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletContext 当前 web 容器上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> spring 容器上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #ContextLoader(WebApplicationContext)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #CONTEXT_CLASS_PARAM</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #CONFIG_LOCATION_PARAM</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">&quot;Cannot initialize context because there is already a root application context present - &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;check whether you have multiple ContextLoader* definitions in your web.xml!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log logger = LogFactory.getLog(ContextLoader.class);</span><br><span class="line">        servletContext.log(<span class="string">&quot;Initializing Spring root WebApplicationContext&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;Root WebApplicationContext: initialization started&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建一个 WebApplicationContext 实例</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.context == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.context = createWebApplicationContext(servletContext);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.context <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">                ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) <span class="keyword">this</span>.context;</span><br><span class="line">                <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">                    <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">                    <span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">                    <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// The context instance was injected without an explicit parent -&gt;</span></span><br><span class="line">                        <span class="comment">// determine parent for root web application context, if any.</span></span><br><span class="line">                        ApplicationContext parent = loadParentContext(servletContext);</span><br><span class="line">                        cwac.setParent(parent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    configureAndRefreshWebApplicationContext(cwac, servletContext);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前创建的spring 父容器注册到 web 容器中， 属性名称是： org.springframework.web.context.WebApplicationContext.ROOT</span></span><br><span class="line">            servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.context);</span><br><span class="line"></span><br><span class="line">            ClassLoader ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            <span class="keyword">if</span> (ccl == ContextLoader.class.getClassLoader()) &#123;</span><br><span class="line">                currentContext = <span class="keyword">this</span>.context;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ccl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                currentContextPerThread.put(ccl, <span class="keyword">this</span>.context);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Published root WebApplicationContext as ServletContext attribute with name [&quot;</span> +</span><br><span class="line">                        WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                <span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">                logger.info(<span class="string">&quot;Root WebApplicationContext: initialization completed in &quot;</span> + elapsedTime + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.context;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Context initialization failed&quot;</span>, ex);</span><br><span class="line">            servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Context initialization failed&quot;</span>, err);</span><br><span class="line">            servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>DispatcherServlet</code> 继承 <code>FrameworkServlet</code>, <code>FrameworkServlet</code> 继承 <code>HttpServletBean</code><br><code>HttpServletBean</code> 继承 <code>HttpServlet</code>, 并且提供 <code>init</code> 方法</p>
<p>HttpServletBean 中的 <code>init</code> 方法调用抽象方法 <code>initServletBean</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Initializing servlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">        initServletBean();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Servlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27; configured successfully&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>FrameworkServlet</code> 实现 <code>initServletBean</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">            <span class="comment">// ...... 忽略</span></span><br><span class="line">            <span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">            initFrameworkServlet();</span><br><span class="line">            <span class="comment">// ...... 忽略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在 web 容器  ServletContext 中查找 属性为 org.springframework.web.context.WebApplicationContext.ROOT 的 WebApplicationContext Spring 父容器</span></span><br><span class="line">    WebApplicationContext rootContext =</span><br><span class="line">            WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">    WebApplicationContext wac = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前以及创建了  SpringMVC 子容器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">        wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line">        <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">            <span class="comment">// 如果 springmvc 子容器是 ConfigurableWebApplicationContext, 并且没有激活，设置 spring 父容器和 springmvc 子容器之前的父子容器关系</span></span><br><span class="line">            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line">            <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cwac.setParent(rootContext);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 配置刷下spring mvc 子容器</span></span><br><span class="line">                configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前没有创建 springmvc 子容器</span></span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 在 web 容器  ServletContext 中查找 属性为 org.springframework.web.context.WebApplicationContext.ROOT 的 spring 容器， 将这个父容器作为 spring mvc 子容器， 这种情况下， spring mvc 子容器和 spring 父容器就合一了！</span></span><br><span class="line">        wac = findWebApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果上一步没有在 web 容器  ServletContext 中查找到 属性为 org.springframework.web.context.WebApplicationContext.ROOT 的 WebApplicationContext Spring 容器；创建 contextConfigLocation 设置的配置文件注定的 springmvc 子容器</span></span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">        wac = createWebApplicationContext(rootContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...... 忽略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们找到了 两个容器合一的方法！ 果然是 <code>Time is cheap, show me the code</code>, 源码能告诉我们一切！<br>到这里， 找到了配置方式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">web-app</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/spring-root.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- listener --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- spring mvc --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 该servlet的spring上下文采用WebApplicationContext，不再重复生成上下文 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextAttribute<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>org.springframework.web.context.WebApplicationContext.ROOT<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p>下面在回头来看看之前没有解决的问题：</p>
<h3 id="为什么-SpringMVC-子容器-不能继承-Spring-父容器-引入的属性文件"><a href="#为什么-SpringMVC-子容器-不能继承-Spring-父容器-引入的属性文件" class="headerlink" title="为什么 SpringMVC 子容器 不能继承 Spring 父容器 引入的属性文件"></a>为什么 <code>SpringMVC 子容器</code> 不能继承 <code>Spring 父容器</code> 引入的属性文件</h3><p><em>待解决…</em></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 初涉</title>
    <url>/2017/02/12/%E6%8A%80%E6%9C%AF/spring/2017-02-12-SpringBoot/</url>
    <content><![CDATA[<h4 id="使用-Maven-构建-Spring-Boot-项目"><a href="#使用-Maven-构建-Spring-Boot-项目" class="headerlink" title="使用 Maven 构建 Spring-Boot 项目"></a>使用 <code>Maven</code> 构建 Spring-Boot 项目</h4><ol>
<li>继承父 pom 构建 Spring-Boot 项目</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- ...... the artifactId and groupId of the application --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 继承 spring-boot-starter-parent 使用 spring-boot的最优方法； 也可以不继承这个父pom，使用其他方法 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置插件，打包jar包 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- ...... the artifactId and groupId of the application --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- Override Spring Data release train provided by Spring Boot --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-releasetrain<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>Fowler-SR2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">              <span class="comment">&lt;!--  --&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置插件，打包jar包 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="dev-tools"><a href="#dev-tools" class="headerlink" title="dev-tools"></a>dev-tools</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 设置插件，打包jar包 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 使用 dev-tools 需要禁用默认的 excludeDevtools --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludeDevtools</span>&gt;</span>false<span class="tag">&lt;/<span class="name">excludeDevtools</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>DevToolsPropertyDefaultsPostProcessor</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC源码学习 —— MVC 配置加载过程</title>
    <url>/2016/12/01/%E6%8A%80%E6%9C%AF/spring/2016-12-01-SpringMVC%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-mvc%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="SpringMVC-配置加载过程"><a href="#SpringMVC-配置加载过程" class="headerlink" title="SpringMVC 配置加载过程"></a>SpringMVC 配置加载过程</h3><p><code>Spring</code> 中加载配置文件的工具类是 <code>xxxNamespaceHandler</code>， 解析 SpringMVC 的配置文件，加载默认配置的工具类就是 <code>MvcNameSpaceHandler</code>。</p>
<p>下面来看看 <code>MvcNameSpaceHandler</code> 的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注册 &lt;mvc:annotation-driven&gt; 配置标签解析类，具体解析内容见 [AnnotationDrivenBeanDefinitionParser]</span></span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;annotation-driven&quot;</span>, <span class="keyword">new</span> AnnotationDrivenBeanDefinitionParser());</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;default-servlet-handler&quot;</span>, <span class="keyword">new</span> DefaultServletHandlerBeanDefinitionParser());</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;interceptors&quot;</span>, <span class="keyword">new</span> InterceptorsBeanDefinitionParser());</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;resources&quot;</span>, <span class="keyword">new</span> ResourcesBeanDefinitionParser());</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;view-controller&quot;</span>, <span class="keyword">new</span> ViewControllerBeanDefinitionParser());</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;redirect-view-controller&quot;</span>, <span class="keyword">new</span> ViewControllerBeanDefinitionParser());</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;status-controller&quot;</span>, <span class="keyword">new</span> ViewControllerBeanDefinitionParser());</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;view-resolvers&quot;</span>, <span class="keyword">new</span> ViewResolversBeanDefinitionParser());</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;tiles-configurer&quot;</span>, <span class="keyword">new</span> TilesConfigurerBeanDefinitionParser());</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;freemarker-configurer&quot;</span>, <span class="keyword">new</span> FreeMarkerConfigurerBeanDefinitionParser());</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;velocity-configurer&quot;</span>, <span class="keyword">new</span> VelocityConfigurerBeanDefinitionParser());</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;groovy-configurer&quot;</span>, <span class="keyword">new</span> GroovyMarkupConfigurerBeanDefinitionParser());</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;script-template-configurer&quot;</span>, <span class="keyword">new</span> ScriptTemplateConfigurerBeanDefinitionParser());</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;cors&quot;</span>, <span class="keyword">new</span> CorsBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是 <code>AnnotationDrivenBeanDefinitionParser</code> 中的 <code>parse</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">        Object source = parserContext.extractSource(element);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册 `&lt;mvc:annotation-driven&gt;` 的组件信息</span></span><br><span class="line">        CompositeComponentDefinition compDefinition = <span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), source);</span><br><span class="line">        <span class="comment">// 将 `&lt;mvc:annotation-driven&gt;` 的组建信息 push 到解析配置的上下文的 栈 中去</span></span><br><span class="line">        parserContext.pushContainingComponent(compDefinition);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 `ContentNegotiationManager`, 如果 &lt;mvc:annotation-driven&gt; 中配置了 ContentNegotiationManager 的实现类名，则返回该实现的引用；</span></span><br><span class="line">        <span class="comment">// 如果没有配置，就会生成一个默认的 ContentNegotiationManager</span></span><br><span class="line">        <span class="comment">// ContentNegotiationManager: 1. 根据request 解析出 mediaType； 2. 根据 mediaType 解析出文件后缀名</span></span><br><span class="line">        RuntimeBeanReference contentNegotiationManager = getContentNegotiationManager(element, source, parserContext);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 RequestMappingHandlerMapping 的Bean 定义</span></span><br><span class="line">        RootBeanDefinition handlerMappingDef = <span class="keyword">new</span> RootBeanDefinition(RequestMappingHandlerMapping.class);</span><br><span class="line">        handlerMappingDef.setSource(source);</span><br><span class="line">        handlerMappingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        <span class="comment">// 默认 order 为0，优先使用这个 HandlerMapping</span></span><br><span class="line">        handlerMappingDef.getPropertyValues().add(<span class="string">&quot;order&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        handlerMappingDef.getPropertyValues().add(<span class="string">&quot;contentNegotiationManager&quot;</span>, contentNegotiationManager);</span><br><span class="line">        String methodMappingName = parserContext.getReaderContext().registerWithGeneratedName(handlerMappingDef);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 &lt;mvc:annotation-driven&gt; 标签设置了 enable-matrix-variables 属性，在 RequestMappingHandlerMapping 中添加 removeSemicolonContent 属性 如果要使用 matrix-variales 属性， removeSemicolonContent 必须是 false</span></span><br><span class="line">        <span class="keyword">if</span> (element.hasAttribute(<span class="string">&quot;enable-matrix-variables&quot;</span>)) &#123;</span><br><span class="line">            Boolean enableMatrixVariables = Boolean.valueOf(element.getAttribute(<span class="string">&quot;enable-matrix-variables&quot;</span>));</span><br><span class="line">            handlerMappingDef.getPropertyValues().add(<span class="string">&quot;removeSemicolonContent&quot;</span>, !enableMatrixVariables);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (element.hasAttribute(<span class="string">&quot;enableMatrixVariables&quot;</span>)) &#123;</span><br><span class="line">            Boolean enableMatrixVariables = Boolean.valueOf(element.getAttribute(<span class="string">&quot;enableMatrixVariables&quot;</span>));</span><br><span class="line">            handlerMappingDef.getPropertyValues().add(<span class="string">&quot;removeSemicolonContent&quot;</span>, !enableMatrixVariables);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取 &lt;mvc:annotation-driven&gt; 中的 path-matching 属性</span></span><br><span class="line">        <span class="comment">// 读取 path-matching 中的 suffix-pattern、trailing-slash、registered-suffixes-only</span></span><br><span class="line">      <span class="comment">// 设置 RequestMappingHandlerMapping 的 useSuffixPatternMatch、useTrailingSlashMatch、useRegisteredSuffixPatternMatch</span></span><br><span class="line">        <span class="comment">// 读取 path-matching 中的 path-helper （UrlPathHelper 或其自定义子类的全限定名）</span></span><br><span class="line">        <span class="comment">// 设置 RequestMappingHandlerMapping 的 UrlPathHelper，如果 path-helper 不为空则在 ParserContext 中设置当前 UrlPathHelper 的别名为 mvcUrlPathHelper</span></span><br><span class="line">        <span class="comment">// 读取 path-matching 中的 path-helper</span></span><br><span class="line">        <span class="comment">// 设置 RequestMappingHandlerMapping 中的 pathMatcher 默认为 AntPathMatcher(ant 风格的路径匹配器)，如果 path-helper 不为空则在 ParserContext 中设置当前 UrlPathHelper 的别名为 mvcPathMatcher</span></span><br><span class="line">        configurePathMatchingProperties(handlerMappingDef, element, parserContext);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RequestMappingHandlerMapping 设置 CorsConfiguration(跨域请求配置信息) 并且 将 corsConfigurations 注册到 ParserContext 中</span></span><br><span class="line">        RuntimeBeanReference corsConfigurationsRef = MvcNamespaceUtils.registerCorsConfigurations(<span class="keyword">null</span>, parserContext, source);</span><br><span class="line">        handlerMappingDef.getPropertyValues().add(<span class="string">&quot;corsConfigurations&quot;</span>, corsConfigurationsRef);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取 path-matching 中的 conversion-service 获取 conversionService 并且注册到 ParserContext 中去</span></span><br><span class="line">        RuntimeBeanReference conversionService = getConversionService(element, source, parserContext);</span><br><span class="line">        RuntimeBeanReference validator = getValidator(element, source, parserContext);</span><br><span class="line">        RuntimeBeanReference messageCodesResolver = getMessageCodesResolver(element);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        RootBeanDefinition bindingDef = <span class="keyword">new</span> RootBeanDefinition(ConfigurableWebBindingInitializer.class);</span><br><span class="line">        bindingDef.setSource(source);</span><br><span class="line">        bindingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        bindingDef.getPropertyValues().add(<span class="string">&quot;conversionService&quot;</span>, conversionService);</span><br><span class="line">        bindingDef.getPropertyValues().add(<span class="string">&quot;validator&quot;</span>, validator);</span><br><span class="line">        bindingDef.getPropertyValues().add(<span class="string">&quot;messageCodesResolver&quot;</span>, messageCodesResolver);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取配置信息中的 MessageConverter， 如果没有配置或者 register-defaults 为 true， 其实 register-defaults 默认为true</span></span><br><span class="line">        <span class="comment">// 也就是说不管你有没有配置 message-converters 属性  annotation-driven 都会为你注册这写 HttpMessageConverter:</span></span><br><span class="line">        <span class="comment">// ByteArrayHttpMessageConverter、StringHttpMessageConverter、ResourceHttpMessageConverter、SourceHttpMessageConverter、AllEncompassingFormHttpMessageConverter</span></span><br><span class="line">        <span class="comment">// 还有一些是否根据当前 classpath 中是否有对应的jar包才会添加的对应的 HttpMessageConverter</span></span><br><span class="line">        ManagedList&lt;?&gt; messageConverters = getMessageConverters(element, source, parserContext);</span><br><span class="line">        <span class="comment">// 获取用户自定义的 HandlerMethodArgumentResolver， 解析方法参数</span></span><br><span class="line">        ManagedList&lt;?&gt; argumentResolvers = getArgumentResolvers(element, parserContext);</span><br><span class="line">        <span class="comment">// 获取用户自定义的 HandlerMethodReturnValueHandler， 处理方法的返回值</span></span><br><span class="line">        ManagedList&lt;?&gt; returnValueHandlers = getReturnValueHandlers(element, parserContext);</span><br><span class="line">        String asyncTimeout = getAsyncTimeout(element);</span><br><span class="line">        RuntimeBeanReference asyncExecutor = getAsyncExecutor(element);</span><br><span class="line">        ManagedList&lt;?&gt; callableInterceptors = getCallableInterceptors(element, source, parserContext);</span><br><span class="line">        ManagedList&lt;?&gt; deferredResultInterceptors = getDeferredResultInterceptors(element, source, parserContext);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 RequestMappingHandlerAdapter 的 bean 定义</span></span><br><span class="line">        RootBeanDefinition handlerAdapterDef = <span class="keyword">new</span> RootBeanDefinition(RequestMappingHandlerAdapter.class);</span><br><span class="line">        handlerAdapterDef.setSource(source);</span><br><span class="line">        handlerAdapterDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        handlerAdapterDef.getPropertyValues().add(<span class="string">&quot;contentNegotiationManager&quot;</span>, contentNegotiationManager);</span><br><span class="line">        handlerAdapterDef.getPropertyValues().add(<span class="string">&quot;webBindingInitializer&quot;</span>, bindingDef);</span><br><span class="line">        handlerAdapterDef.getPropertyValues().add(<span class="string">&quot;messageConverters&quot;</span>, messageConverters);</span><br><span class="line">        addRequestBodyAdvice(handlerAdapterDef);</span><br><span class="line">        addResponseBodyAdvice(handlerAdapterDef);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (element.hasAttribute(<span class="string">&quot;ignore-default-model-on-redirect&quot;</span>)) &#123;</span><br><span class="line">            Boolean ignoreDefaultModel = Boolean.valueOf(element.getAttribute(<span class="string">&quot;ignore-default-model-on-redirect&quot;</span>));</span><br><span class="line">            handlerAdapterDef.getPropertyValues().add(<span class="string">&quot;ignoreDefaultModelOnRedirect&quot;</span>, ignoreDefaultModel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (element.hasAttribute(<span class="string">&quot;ignoreDefaultModelOnRedirect&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// &quot;ignoreDefaultModelOnRedirect&quot; spelling is deprecated</span></span><br><span class="line">            Boolean ignoreDefaultModel = Boolean.valueOf(element.getAttribute(<span class="string">&quot;ignoreDefaultModelOnRedirect&quot;</span>));</span><br><span class="line">            handlerAdapterDef.getPropertyValues().add(<span class="string">&quot;ignoreDefaultModelOnRedirect&quot;</span>, ignoreDefaultModel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (argumentResolvers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handlerAdapterDef.getPropertyValues().add(<span class="string">&quot;customArgumentResolvers&quot;</span>, argumentResolvers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (returnValueHandlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handlerAdapterDef.getPropertyValues().add(<span class="string">&quot;customReturnValueHandlers&quot;</span>, returnValueHandlers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (asyncTimeout != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handlerAdapterDef.getPropertyValues().add(<span class="string">&quot;asyncRequestTimeout&quot;</span>, asyncTimeout);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (asyncExecutor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handlerAdapterDef.getPropertyValues().add(<span class="string">&quot;taskExecutor&quot;</span>, asyncExecutor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handlerAdapterDef.getPropertyValues().add(<span class="string">&quot;callableInterceptors&quot;</span>, callableInterceptors);</span><br><span class="line">        handlerAdapterDef.getPropertyValues().add(<span class="string">&quot;deferredResultInterceptors&quot;</span>, deferredResultInterceptors);</span><br><span class="line">        String handlerAdapterName = parserContext.getReaderContext().registerWithGeneratedName(handlerAdapterDef);</span><br><span class="line"></span><br><span class="line">        String uriCompContribName = MvcUriComponentsBuilder.MVC_URI_COMPONENTS_CONTRIBUTOR_BEAN_NAME;</span><br><span class="line">        RootBeanDefinition uriCompContribDef = <span class="keyword">new</span> RootBeanDefinition(CompositeUriComponentsContributorFactoryBean.class);</span><br><span class="line">        uriCompContribDef.setSource(source);</span><br><span class="line">        uriCompContribDef.getPropertyValues().addPropertyValue(<span class="string">&quot;handlerAdapter&quot;</span>, handlerAdapterDef);</span><br><span class="line">        uriCompContribDef.getPropertyValues().addPropertyValue(<span class="string">&quot;conversionService&quot;</span>, conversionService);</span><br><span class="line">        parserContext.getReaderContext().getRegistry().registerBeanDefinition(uriCompContribName, uriCompContribDef);</span><br><span class="line"></span><br><span class="line">        RootBeanDefinition csInterceptorDef = <span class="keyword">new</span> RootBeanDefinition(ConversionServiceExposingInterceptor.class);</span><br><span class="line">        csInterceptorDef.setSource(source);</span><br><span class="line">        csInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(<span class="number">0</span>, conversionService);</span><br><span class="line">        RootBeanDefinition mappedCsInterceptorDef = <span class="keyword">new</span> RootBeanDefinition(MappedInterceptor.class);</span><br><span class="line">        mappedCsInterceptorDef.setSource(source);</span><br><span class="line">        mappedCsInterceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        mappedCsInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(<span class="number">0</span>, (Object) <span class="keyword">null</span>);</span><br><span class="line">        mappedCsInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(<span class="number">1</span>, csInterceptorDef);</span><br><span class="line">        String mappedInterceptorName = parserContext.getReaderContext().registerWithGeneratedName(mappedCsInterceptorDef);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 ExceptionHandlerExceptionResolver 的 Bean 定义</span></span><br><span class="line">        RootBeanDefinition exceptionHandlerExceptionResolver = <span class="keyword">new</span> RootBeanDefinition(ExceptionHandlerExceptionResolver.class);</span><br><span class="line">        exceptionHandlerExceptionResolver.setSource(source);</span><br><span class="line">        exceptionHandlerExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        exceptionHandlerExceptionResolver.getPropertyValues().add(<span class="string">&quot;contentNegotiationManager&quot;</span>, contentNegotiationManager);</span><br><span class="line">        exceptionHandlerExceptionResolver.getPropertyValues().add(<span class="string">&quot;messageConverters&quot;</span>, messageConverters);</span><br><span class="line">        exceptionHandlerExceptionResolver.getPropertyValues().add(<span class="string">&quot;order&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        addResponseBodyAdvice(exceptionHandlerExceptionResolver);</span><br><span class="line"></span><br><span class="line">        String methodExceptionResolverName =</span><br><span class="line">                parserContext.getReaderContext().registerWithGeneratedName(exceptionHandlerExceptionResolver);</span><br><span class="line"></span><br><span class="line">        RootBeanDefinition responseStatusExceptionResolver = <span class="keyword">new</span> RootBeanDefinition(ResponseStatusExceptionResolver.class);</span><br><span class="line">        responseStatusExceptionResolver.setSource(source);</span><br><span class="line">        responseStatusExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        responseStatusExceptionResolver.getPropertyValues().add(<span class="string">&quot;order&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        String responseStatusExceptionResolverName =</span><br><span class="line">                parserContext.getReaderContext().registerWithGeneratedName(responseStatusExceptionResolver);</span><br><span class="line"></span><br><span class="line">        RootBeanDefinition defaultExceptionResolver = <span class="keyword">new</span> RootBeanDefinition(DefaultHandlerExceptionResolver.class);</span><br><span class="line">        defaultExceptionResolver.setSource(source);</span><br><span class="line">        defaultExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        defaultExceptionResolver.getPropertyValues().add(<span class="string">&quot;order&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        String defaultExceptionResolverName =</span><br><span class="line">                parserContext.getReaderContext().registerWithGeneratedName(defaultExceptionResolver);</span><br><span class="line"></span><br><span class="line">        parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(handlerMappingDef, methodMappingName));</span><br><span class="line">        parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(handlerAdapterDef, handlerAdapterName));</span><br><span class="line">        parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(uriCompContribDef, uriCompContribName));</span><br><span class="line">        parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(exceptionHandlerExceptionResolver, methodExceptionResolverName));</span><br><span class="line">        parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(responseStatusExceptionResolver, responseStatusExceptionResolverName));</span><br><span class="line">        parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(defaultExceptionResolver, defaultExceptionResolverName));</span><br><span class="line">        parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(mappedCsInterceptorDef, mappedInterceptorName));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure BeanNameUrlHandlerMapping (SPR-8289) and default HandlerAdapters are not &quot;turned off&quot;</span></span><br><span class="line">      <span class="comment">// 创建默认的组件 BeanNameUrlHandlerMapping、HttpRequestHandlerAdapter、SimpleControllerHandlerAdapter</span></span><br><span class="line">        MvcNamespaceUtils.registerDefaultComponents(parserContext, source);</span><br><span class="line"></span><br><span class="line">        parserContext.popAndRegisterContainingComponent();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>如何正确的创建 prototype 类型的 bean</title>
    <url>/2017/03/01/%E6%8A%80%E6%9C%AF/spring/2017-03-01-Spring%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这里把使用 <code>Spring</code> 过程中遇到的问题做个记录，有些给出了解决方案，有些没有，欢迎同道读者斧正！</p>
<h1 id="如何正确的创建-prototype-类型的-Spring-bean"><a href="#如何正确的创建-prototype-类型的-Spring-bean" class="headerlink" title="如何正确的创建 prototype 类型的 Spring bean"></a>如何正确的创建 <code>prototype</code> 类型的 <code>Spring bean</code></h1><p>这里先尝试的去创建一个 <code>prototype</code> 的 <code>bean</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtoTypeComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> random;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ProtoTypeComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// random 值设置为一个随机值，</span></span><br><span class="line">    <span class="keyword">this</span>.random = ThreadLocalRandom.current().nextInt(<span class="number">100000</span>);</span><br><span class="line">    LOGGER.info(<span class="string">&quot;create a new ProtoTypeComponent with random:&#123;&#125;&quot;</span>, random);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> random;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们在Controller 中注入这个 <code>prototype bean</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> ProtoTypeComponent protoTypeComponent;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping(value = &quot;/hello&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;\&quot;class\&quot;: \&quot;&quot;</span> + protoTypeComponent + <span class="string">&quot;\&quot;, \&quot;random\&quot;:\&quot;&quot;</span></span><br><span class="line">        + protoTypeComponent.getRandom() + <span class="string">&quot;\&quot;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们开始请求这个 http 接口</p>
<p><img src="/assets/picture/prototypebeaninfo.png" title="请求上方 /hello 接口获取 prototype bean 信息"></p>
<p>不断的刷新页面，返回的结果都是一模一样！我们再来看看日志</p>
<p><img src="/assets/picture/prototypecomponent.png" title="请求上方 /hello 接口时的日志信息"></p>
<p>从上面的日志上我们看到这个 <code>prototype bean</code> 的构造方法只被调用了一次！</p>
<p>到这里，我感到奇怪了，为什么这个 <code>prototype bean</code> 成了 <code>singleton bean</code> 了？</p>
<p>这个时候我想了 《Spring揭秘》 中看到的正解， 之前这个现象出现的原因是 <code>HelloController</code> 是 <code>singleton</code> 类型的，这个 <code>bean</code> 只会被初始化一次， 而 <code>HelloController</code> 依赖的 <code>ProtoTypeComponent</code> 也只会被注入一次！<br>到这里，谜底揭晓：</p>
<p><em><code>singleton bean</code> 依赖的 <code>prototype bean</code> 会 “变成” <code>singleton bean</code></em></p>
<p>这里，解决这个问题的第一个方案也出现了：</p>
<pre><code>    依赖 `prototype bean` 也必须是 `prototype bean`</code></pre>
<p>很明显这个方案不能解决很多状况， 我们继续这个问题</p>
<p>再来翻翻 <code>《Spring 揭秘》</code> 找找答案<br>我们看到了两个答案</p>
<ol>
<li>使用方法注入</li>
<li>继承 ApplicationContextAware 每次去获取bean</li>
</ol>
<h2 id="使用方法注入"><a href="#使用方法注入" class="headerlink" title="使用方法注入"></a>使用方法注入</h2><p>在传统的 xml 配置方式中我们需要这样配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;protoTypeBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...impl.ProtoTypeService&quot;</span> <span class="attr">singleton</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span> = <span class="string">&quot;...impl.SimpleServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">&quot;getProtoTypeBean&quot;</span> <span class="attr">bean</span>=<span class="string">&quot;protoTypeBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>getProtoTypeBean 方法定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ProtoTypeService protoTypeBean;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProtoTypeService <span class="title">getProtoTypeBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> protoTypeBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们更倾向于使用注解，那么基于注解怎么实现上面这种方式呢？<br>我们这里引入 <code>@Lookup</code> 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An annotation that indicates &#x27;lookup&#x27; methods, to be overridden by the container</span></span><br><span class="line"><span class="comment"> * to redirect them back to the &#123;<span class="doctag">@link</span> org.springframework.beans.factory.BeanFactory&#125;</span></span><br><span class="line"><span class="comment"> * for a &#123;<span class="doctag">@code</span> getBean&#125; call. This is essentially an annotation-based version of the</span></span><br><span class="line"><span class="comment"> * XML &#123;<span class="doctag">@code</span> lookup-method&#125; attribute, resulting in the same runtime arrangement.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The resolution of the target bean can either be based on the return type</span></span><br><span class="line"><span class="comment"> * (&#123;<span class="doctag">@code</span> getBean(Class)&#125;) or on a suggested bean name (&#123;<span class="doctag">@code</span> getBean(String)&#125;),</span></span><br><span class="line"><span class="comment"> * in both cases passing the method&#x27;s arguments to the &#123;<span class="doctag">@code</span> getBean&#125; call</span></span><br><span class="line"><span class="comment"> * for applying them as target factory method arguments or constructor arguments.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Such lookup methods can have default (stub) implementations that will simply</span></span><br><span class="line"><span class="comment"> * get replaced by the container, or they can be declared as abstract - for the</span></span><br><span class="line"><span class="comment"> * container to fill them in at runtime. In both cases, the container will generate</span></span><br><span class="line"><span class="comment"> * runtime subclasses of the method&#x27;s containing class via CGLIB, which is why such</span></span><br><span class="line"><span class="comment"> * lookup methods can only work on beans that the container instantiates through</span></span><br><span class="line"><span class="comment"> * regular constructors: i.e. lookup methods cannot get replaced on beans returned</span></span><br><span class="line"><span class="comment"> * from factory methods where we cannot dynamically provide a subclass for them.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;Concrete limitations in typical Spring configuration scenarios:&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * When used with component scanning or any other mechanism that filters out abstract</span></span><br><span class="line"><span class="comment"> * beans, provide stub implementations of your lookup methods to be able to declare</span></span><br><span class="line"><span class="comment"> * them as concrete classes. And please remember that lookup methods won&#x27;t work on</span></span><br><span class="line"><span class="comment"> * beans returned from &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; methods in configuration classes; you&#x27;ll have</span></span><br><span class="line"><span class="comment"> * to resort to &#123;<span class="doctag">@code</span> <span class="doctag">@Inject</span> Provider&amp;lt;TargetBean&amp;gt;&#125; or the like instead.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.BeanFactory#getBean(Class, Object...)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.BeanFactory#getBean(String, Object...)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Lookup &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This annotation attribute may suggest a target bean name to look up.</span></span><br><span class="line"><span class="comment">     * If not specified, the target bean will be resolved based on the</span></span><br><span class="line"><span class="comment">     * annotated method&#x27;s return type declaration.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>从上面的代码能看出：<br>这个注解只能修饰方法，根据方法的返回值类型创建对应的Bean，底层机制是调用 <code>org.springframework.beans.factory.BeanFactory#getBean(Class, Object...)</code> 或 <code>org.springframework.beans.factory.BeanFactory#getBean(String, Object...)</code></p>
<p>先来使用 <code>@Lookup</code> 注解改成一下我们尝试创建 有状态的 <code>prototype bean</code></p>
<p>修正的代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ProtoTypeComponent protoTypeComponent;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping(value = &quot;/hello&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ProtoTypeComponent component = getProtoTypeComponent();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;\&quot;class\&quot;: \&quot;&quot;</span> + component + <span class="string">&quot;\&quot;, \&quot;random\&quot;:\&quot;&quot;</span></span><br><span class="line">        + component.getRandom() + <span class="string">&quot;\&quot;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Lookup</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ProtoTypeComponent <span class="title">getProtoTypeComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> protoTypeComponent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们运行起 <code>tomcat</code> 看看结果：</p>
<p><img src="/assets/picture/realProtoTypeComponent1.png"><br><img src="/assets/picture/realProtoTypeComponent2.png"></p>
<p>很明显，我们成功的创建了 <code>prototype bean</code>!</p>
<h3 id="Lookup-注解是如何入注入-prototype-类型的依赖的？"><a href="#Lookup-注解是如何入注入-prototype-类型的依赖的？" class="headerlink" title="@Lookup 注解是如何入注入 prototype 类型的依赖的？"></a>@Lookup 注解是如何入注入 prototype 类型的依赖的？</h3><p>下面我们来揭秘，<code>@Lookup</code> 注解是如果实现注入 <code>prototype bean</code> 的：</p>
<h4 id="Bean-的实例化"><a href="#Bean-的实例化" class="headerlink" title="Bean 的实例化"></a><code>Bean</code> 的实例化</h4><p>Bean 的创建主要是 <code>BeanFactory#doCreateBean</code> 方法，主要是三个步骤</p>
<ol>
<li>createBeanInstance: 通过构造函数，反射创建 Bean 的示例，但是没有填充任何属性</li>
<li>populateBean: 对 Bean 中的属性进行填充，处理依赖属性</li>
<li>initializeBean: 反射调用 afterPropertiesSet 方法或者自定义的 initMethod 进行初始化</li>
</ol>
<p><code>createBeanInstance</code> 方法中，Bean 的实例化流程主要如下</p>
<p>首先是在 <code>determineConstructorsFromBeanPostProcessors</code> 方法中通过 <code>BeanPostProcessor</code> 查找构造方法用于实例化 Bean</p>
<p><img src="/assets/picture/bean_instancetiation_with_constructor.png" alt="BeanFactory#createBeanInstance" title="BeanFactory#createBeanInstance"><br><img src="/assets/picture/BeanFactory.determineConstructorsFromBeanPostProcessors.png" alt="BeanFactory#determineConstructorsFromBeanPostProcessors" title="BeanFactory#determineConstructorsFromBeanPostProcessors"></p>
<p>其中，在 <code>AutowiredAnnotationBeanPostProcessor</code> 中的 <code>determineCandidateConstructors</code> 方法中在查找构造方法之前，会先对 <code>@Lookup</code> 注解修饰的方法进行处理</p>
<ol>
<li>在类中查找 <code>@Lookup</code> 修饰的方法</li>
<li>通过方法上的 <code>@Lookup</code> 注解的信息新建 <code>LookupOverride</code></li>
<li>将 <code>LookupOverride</code> 注入到 <code>BeanDefinition</code> 的 <code>methodOverrides</code> 中</li>
</ol>
<p>后面会用到 <code>BeanDefinition</code> 的 <code>methodOverrides</code></p>
<p><img src="/assets/picture/AutowiredAnnotationBeanPostProcessor.determineCandidateConstructors.png" alt="AutowiredAnnotationBeanPostProcessor.determineCandidateConstructors" title="AutowiredAnnotationBeanPostProcessor.determineCandidateConstructors"></p>
<p>而具体的实例化过程是调用 <code>InstantiationStrategy#instantiate</code> 进行实例化</p>
<p><img src="/assets/picture/instantiation_strategy_instantiate.png" alt="AbstractAutowireCapableBeanFactory#instantiateBean" title="AbstractAutowireCapableBeanFactory#instantiateBean"></p>
<p>这里就会查看 <code>BeanDefinition</code> 的 <code>methodOverrides</code> 是否有数据了，这里就会找到之前的 <code>LookupOverrides</code> 了, 找到之后就会通过 CGLIB 进行 Bean 的实例化了</p>
<p><img src="/assets/picture/instantiation_strategy_instatiate_bean.png" alt="InstantiationStrategy#instantiate" title="InstantiationStrategy#instantiate"><br><img src="/assets/picture/CglibSubclassingInstantiationStrategy.instantiateWithMethodInjection.png" alt="CglibSubclassingInstantiationStrategy#instantiateWithMethodInjection" title="CglibSubclassingInstantiationStrategy#instantiateWithMethodInjection"></p>
<p>通过 CGLIB 的 <code>Enhancer</code> 创建 Class，再通过反射进行实例化，最后设置 Callback，其中就有 <code>LookupOverrideMethodInterceptor</code></p>
<p><img src="/assets/picture/CglibSubclassCreator.instantiate.png" alt="CglibSubclassCreator#instantiate" title="CglibSubclassCreator#instantiate"><br><img src="/assets/picture/CglibSubclassCreator.createEnhancedSubclass.png" alt="CglibSubclassCreator#createEnhancedSubclass" title="CglibSubclassCreator#createEnhancedSubclass"><br><img src="/assets/picture/CglibSubclassCreator.CALLBACK_TYPES.png" alt="CglibSubclassCreator#CALLBACK_TYPES" title="CglibSubclassCreator#CALLBACK_TYPES"></p>
<p>而 <code>LookupOverrideMethodInterceptor</code> 是 CGLIB 中 <code>MethodInterceptor</code> 的实现，实现了对方法的代理；它的具体逻辑是代理 <code>@Lookup</code> 修饰的方法，先看 <code>@Lookup</code> 注解是否有 <code>value</code> 属性，如果有则将 <code>value</code> 作为 Bean 名称去 BeanFactory 中查找或创建 Bean 实例，如果没有则根据方法的返回值的 Class 去 BeanFactory 中查找或创建 Bean 实例。</p>
<p>简单来说就是忽略了 <code>@Lookup</code> 修饰的方法的具体实现，只按照方法的返回值或者 <code>@Lookup</code> 注解的 <code>value</code> 属性去容器中查找 Bean，这个时候查询的 Bean 的 Scope 可以是任何类型，也包括 <code>prototype</code></p>
<p><img src="/assets/picture/LookupOverrideMethodInterceptor.png" alt="LookupOverrideMethodInterceptor" title="LookupOverrideMethodInterceptor"></p>
<h2 id="继承-ApplicationContextAware-每次去获取bean"><a href="#继承-ApplicationContextAware-每次去获取bean" class="headerlink" title="继承 ApplicationContextAware 每次去获取bean"></a>继承 ApplicationContextAware 每次去获取bean</h2><p>这里不推荐使用 <code>ApplicationContextAware</code> 所以不给出方法了。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 如何解决单例的循环依赖</title>
    <url>/2020/06/10/%E6%8A%80%E6%9C%AF/spring/Spring%20%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8D%95%E4%BE%8B%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<h1 id="Spring-如何解决单例的循环依赖"><a href="#Spring-如何解决单例的循环依赖" class="headerlink" title="Spring 如何解决单例的循环依赖"></a>Spring 如何解决单例的循环依赖</h1><h2 id="Spring-循环依赖简单示例"><a href="#Spring-循环依赖简单示例" class="headerlink" title="Spring 循环依赖简单示例"></a>Spring 循环依赖简单示例</h2><p>Spring 容器中 Bean 的作用范围，最常见的就是下面两种</p>
<ul>
<li><code>singleton</code>: Spring 容器范围内的单例</li>
<li><code>prototype</code>: 原形，每次新建一个新的 bean</li>
</ul>
<p>而对于单例类型的 Bean，就存在一种循环依赖的情况，如下图</p>
<p><img src="/assets/picture/spring_bean_circular_dependencies.svg" alt="Spring 循环依赖" title="Spring 循环依赖"></p>
<p>这里我们就需要对这个循环依赖的情况进行分解，下面我们从代码出发，看看 Spring 中 Bean 的加载流程</p>
<h2 id="Spring-的-Bean-加载过程代码分析"><a href="#Spring-的-Bean-加载过程代码分析" class="headerlink" title="Spring 的 Bean 加载过程代码分析"></a>Spring 的 Bean 加载过程代码分析</h2><p>加载 Bean 的入口是在 BeanFactory 中，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是具体的 Bean 加载流程</p>
<h3 id="从三级缓存中尝试查找-Bean"><a href="#从三级缓存中尝试查找-Bean" class="headerlink" title="从三级缓存中尝试查找 Bean"></a>从三级缓存中尝试查找 Bean</h3><p><img src="/assets/picture/bean_factory_get_bean.jpg" alt="BeanFactory#getBean" title="BeanFactory#getBean"></p>
<p><code>BeanFactory</code> 获取 Bean 的具体实现是 <code>BeanFactory#doGetBean</code> 方法，在这方法中，首先会调用 <code>DefaultSingletonBeanRegistry#getSingleton</code> 方法从缓存中获取目标 Bean 的实例</p>
<p><img src="/assets/picture/bean_factory_get_singleton_from_cache.png" alt="DefaultSingletonBeanRegistry#getSingleton(java.lang.String)" title="DefaultSingletonBeanRegistry#getSingleton(java.lang.String)"></p>
<p>下面就是 <code>DefaultSingletonBeanRegistry#getSingleton</code> 方法的实现</p>
<p><img src="/assets/picture/singleton_bean_registry_get_singleton_from_three_cache.png" alt="DefaultSingletonBeanRegistry#getSingleton(java.lang.String, boolean)" title="DefaultSingletonBeanRegistry#getSingleton(java.lang.String, boolean)"></p>
<p>上述代码具体的查找逻辑流程如下：</p>
<p><img src="/assets/picture/get_bean_from_three_singleton_cache.svg" alt="从缓存中查找目标 Bean" title="从缓存中查找目标 Bean"></p>
<p>这里我们讲到了 <code>三级缓存</code>，三级缓存是 <code>DefaultSingletonBeanRegistry</code> 维护的三个 <code>ConcurrentHashMap</code>，用于保存单例对象或者它的工厂类实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 一级缓存，Bean 名称对应 Bean 实例的 Map */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 二级缓存，Bean 名称对应 Bean 实例的 Map，一般保存的是依赖其他单例的 Bean */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 三级缓存，Bean 名称对应创建 Bean 的 ObjectFactory 的 Map */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当前正在被创建的单例 Bean 的名称集合 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation =</span><br><span class="line">            Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的流程中会不断提到这个 <code>三级缓存</code></p>
<h3 id="通过自定义的-ObjectFactory-创建目标-Bean-实例"><a href="#通过自定义的-ObjectFactory-创建目标-Bean-实例" class="headerlink" title="通过自定义的 ObjectFactory 创建目标 Bean 实例"></a>通过自定义的 ObjectFactory 创建目标 Bean 实例</h3><p>从 <code>三级缓存</code> 中查找不到已经创建好的目标 Bean 的实例之后，接下来会去主动创建目标 Bean 的实例；这里主要是通过 ObjectFactory 去调用 <code>BeanFactory#createBean</code> 方法去创建实例</p>
<p><img src="/assets/picture/bean_factory_get_singleton_with_object_factory.png" alt="通过 ObjectFactory 创建单例" title="通过 ObjectFactory 创建单例"></p>
<p>创建 Bean 的外围流程是</p>
<ol>
<li>从一级缓存中获取 Bean 的实例，获取到了自动返回，否则进入下一步</li>
<li>将 Bean 名称放入正在被创建的单例名称集合中</li>
<li>通过 ObjectFactory 去调用 <code>BeanFactory#createBean</code> 方法去创建实例</li>
<li>将 Bean 名称从正在被创建的单例名称集合中移除</li>
<li>将单例对象放入一级缓存中</li>
</ol>
<p>下面是 <code>BeanFactory#createBean</code> 的具体逻辑，主要是调用 <code>doCreateBean</code> 方法</p>
<p><img src="/assets/picture/do_create_bean_with_object_factory.png" alt="通过 ObjectFactory 创建单例" title="通过 ObjectFactory 创建单例"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">       <span class="comment">// 省略 ......</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 实际创建 Bean 实例</span></span><br><span class="line">        Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">        <span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line">        <span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;Unexpected exception during bean creation&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用-BeanFactory-创建-Bean-实例"><a href="#调用-BeanFactory-创建-Bean-实例" class="headerlink" title="调用 BeanFactory 创建 Bean 实例"></a>调用 BeanFactory 创建 Bean 实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="comment">// 省略 ......</span></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                    <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略 ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面这个实际创建目标 Bean 实例的逻辑中，主要是三个步骤 </p>
<ol>
<li>createBeanInstance: 通过构造函数，反射创建 Bean 的示例，但是没有填充任何属性</li>
<li>populateBean: 对 Bean 中的属性进行填充，处理依赖属性</li>
<li>initializeBean: 反射调用 afterPropertiesSet 方法或者自定义的 initMethod 进行初始化</li>
</ol>
<p><strong><em>注意，在对Bean 进行了实例化之后，如果配置允许循环依赖，会将只是实例化，但是没有初始化的 Bean 实例放入三级缓存中</em></strong></p>
<h4 id="createBeanInstance"><a href="#createBeanInstance" class="headerlink" title="createBeanInstance"></a>createBeanInstance</h4><p>这个过程就是反射调用构造方法，不做赘述，有兴趣的同学可以去看看</p>
<h4 id="populateBean-对-Bean-进行属性填充"><a href="#populateBean-对-Bean-进行属性填充" class="headerlink" title="populateBean: 对 Bean 进行属性填充"></a>populateBean: 对 Bean 进行属性填充</h4><p>这里主要是通过调用 <code>InstantiationAwareBeanPostProcessor</code> 的实现，对 Bean 实例中的依赖属性进行注入处理；同时还在处理之前通过 <code>InstantiationAwareBeanPostProcessor</code> 进行实例化后的插入操作</p>
<p><img src="/assets/picture/process_prooperties_with_bean_post_processor.png" alt="BeanPostProcess 对Bean 进行属性填充" title="BeanPostProcess 对Bean 进行属性填充"></p>
<p><code>InstantiationAwareBeanPostProcessor#postProcessProperties</code> 方法主要是对 Bean 中的属性进行扫描，然后在容器中找到对应的依赖 Bean，进行依赖注入；<br><code>InstantiationAwareBeanPostProcessor</code> 的是实现主要是 <code>CommonAnnotationBeanPostProcessor</code> 和 <code>AutowiredAnnotationBeanPostProcessor</code></p>
<h5 id="AutowiredAnnotationBeanPostProcessor"><a href="#AutowiredAnnotationBeanPostProcessor" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a><code>AutowiredAnnotationBeanPostProcessor</code></h5><p><code>AutowiredAnnotationBeanPostProcessor</code> 中维护了一个可处理的注解的集合，并且在构造方法中进行初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowiredAnnotationBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">InstantiationAwareBeanPostProcessorAdapter</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">MergedBeanDefinitionPostProcessor</span>, <span class="title">PriorityOrdered</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Class&lt;? extends Annotation&gt;&gt; autowiredAnnotationTypes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AutowiredAnnotationBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.autowiredAnnotationTypes.add(Autowired.class);</span><br><span class="line">        <span class="keyword">this</span>.autowiredAnnotationTypes.add(Value.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.autowiredAnnotationTypes.add((Class&lt;? extends Annotation&gt;)</span><br><span class="line">                    ClassUtils.forName(<span class="string">&quot;javax.inject.Inject&quot;</span>, AutowiredAnnotationBeanPostProcessor.class.getClassLoader()));</span><br><span class="line">            logger.trace(<span class="string">&quot;JSR-330 &#x27;javax.inject.Inject&#x27; annotation found and supported for autowiring&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="comment">// JSR-330 API not available - simply skip.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AutowiredAnnotationBeanPostProcessor#postProcessProperties</code> 的主要逻辑如下:<br>首先，它的主体流程</p>
<ol>
<li>查找 @Autowired、@Value、@javax.inject.Inject 注解修饰的属性和方法</li>
<li>在 BeanFactory 中查找或者创建依赖的 Bean，通过反射进行这些依赖的注入</li>
</ol>
<p><img src="/assets/picture/autowired_meta_data_inject_flow.png" alt="AutowiredAnnotationBeanPostProcessor#postProcessProperties" title="AutowiredAnnotationBeanPostProcessor#postProcessProperties"></p>
<p>下面是 <code>步骤1</code> 的具体逻辑</p>
<p>1.1. 查找 @Autowired、@Value、@javax.inject.Inject 注解修饰的属性<br>1.2. 查找 @Autowired、@Value、@javax.inject.Inject 注解修饰的方法<br>1.3. 构架依赖注入的元数据<br>1.4. 将依赖注入的元数据放入缓存</p>
<p><img src="/assets/picture/bean_post_processor_build_autowired_meta_data.png" alt="AutowiredAnnotationBeanPostProcessor#findAutowiringMetadata" title="AutowiredAnnotationBeanPostProcessor#findAutowiringMetadata"><br><img src="/assets/picture/bean_post_processor_do_build_autowired_meta_data.png" alt="AutowiredAnnotationBeanPostProcessor#buildAutowiringMetadata" title="AutowiredAnnotationBeanPostProcessor#buildAutowiringMetadata"><br><img src="/assets/picture/bean_post_processor_find_autowired_annotation.png" alt="AutowiredAnnotationBeanPostProcessor#findAutowiredAnnotation" title="AutowiredAnnotationBeanPostProcessor#findAutowiredAnnotation"></p>
<p>下面是 <code>步骤2</code> 的具体逻辑：<br> 查找 <code>AutowiredAnnotationBeanPostProcessor</code> 支持的注解修饰的属性，通过属性的 Class 名称，在 <code>BeanFactory</code> 中找到目标 Bean 的实例，或者创建依赖 Bean 的实例，在通过反射，将依赖的 Bean 的实例赋值给这些属性<br>对于 <code>AutowiredAnnotationBeanPostProcessor</code> 支持的注解修饰的方法也是类似的，找到方法参数，通过参数的 Class 名称，在 <code>BeanFactory</code> 中找到目标 Bean 的实例，或者创建依赖 Bean 的实例；再将依赖的 Bean 的实例作为参数，通过反射调用注解修饰的方法</p>
<p>找到这些依赖关系之后，再将这些关系缓存起来，下次可以直接使用</p>
<p><img src="/assets/picture/autowired_annotation_field_inject.png" alt="AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement#inject" title="AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement#inject"><br><img src="/assets/picture/autowired_annotation_method_inject.png" alt="AutowiredAnnotationBeanPostProcessor.AutowiredMethodElement#inject" title="AutowiredAnnotationBeanPostProcessor.AutowiredMethodElement#inject"></p>
<p>在从 BeanFactory 中查找依赖的 Bean 的时候，如果存在循环依赖，A 和 B 相互依赖的时候，创建 A 的实例时候，实例化 A 之后，通过 BeanPostProcessor 注入 A 的依赖 B 的时候，A 已经被实例化，并且在存在于三级缓存中，这时候对 B 进行依赖注入的时候，会去 BeanFactory 中查找实例 A，从三级缓存中找到实例 A 的 ObjectFactory 之后，得到了实例 A，并将实例 A 从三级缓存中迁移到二级缓存中</p>
<p><img src="/assets/picture/bean_factory_get_instantiated_bean.png" alt="DefaultSingletonBeanRegistry#getSingleton(java.lang.String, boolean)" title="DefaultSingletonBeanRegistry#getSingleton(java.lang.String, boolean)"></p>
<h5 id="CommonAnnotationBeanPostProcessor"><a href="#CommonAnnotationBeanPostProcessor" class="headerlink" title="CommonAnnotationBeanPostProcessor"></a><code>CommonAnnotationBeanPostProcessor</code></h5><p><code>CommonAnnotationBeanPostProcessor</code> 和 <code>AutowiredAnnotationBeanPostProcessor</code> 类似，也是可以对一些注解修饰的依赖进行解析注入；<br><code>CommonAnnotationBeanPostProcessor</code> 支持对 <code>@Resource</code>、<code>@javax.xml.ws.WebServiceRef</code>、<code>javax.ejb.EJB</code> 修饰的属性和方法进行扫描手机，整理成依赖信息之后，从 <code>BeanFactory</code> 中查找或者创建依赖，再通过反射进行依赖注入；<br>具体代码逻辑和 <code>AutowiredAnnotationBeanPostProcessor</code> 类似，这里不做赘述。</p>
<h4 id="initializeBean-————-Bean-的初始化"><a href="#initializeBean-————-Bean-的初始化" class="headerlink" title="initializeBean ———— Bean 的初始化"></a>initializeBean ———— Bean 的初始化</h4><p><code>BeanFactory#initializeBean</code> 方法中主要是调用 Bean 的初始化方法，Bean 的初始化方法分为两种</p>
<ol>
<li><code>InitializingBean#afterPropertiesSet</code> 方法</li>
<li>BeanDefinition 中的 设置的 init 方法</li>
</ol>
<p>首先是调用初始化方法的入口</p>
<p><img src="/assets/picture/initialize_bean_invoke_init_method.png" alt="BeanFactory#initializeBean" title="BeanFactory#initializeBean"></p>
<p>对于 <code>InitilalizingBean</code> 的实现类，调用 <code>afterPropertiesSet</code> 方法</p>
<p><img src="/assets/picture/bean_factory_do_invoke_init_method.png" alt="BeanFactory#invokeInitMethods" title="BeanFactory#invokeInitMethods"></p>
<p>对于其他类，调用其 BeanDefinition 中设置的 init 方法</p>
<p><img src="/assets/picture/initialize_bean_invoke_custom_init_method.png" alt="BeanFactory#invokeCustomInitMethod" title="BeanFactory#invokeCustomInitMethod"></p>
<p>到这里就完成了 Bean 的实例化、依赖注入以及初始化；可以将 Bean 的实例放入一级缓存中</p>
<h2 id="循环依赖的解决流程说明"><a href="#循环依赖的解决流程说明" class="headerlink" title="循环依赖的解决流程说明"></a>循环依赖的解决流程说明</h2><p>介绍完了 Bean 的创建流程之后，再来看单例循环依赖的解决方案，就是嵌套多层 Bean 创建流程，在这个嵌套过程中，将实例化好的 Bean 放入三级缓存中，具体说明如下：</p>
<p><img src="/assets/picture/spring_bean_circular_dependencies.svg" alt="Spring 循环依赖" title="Spring 循环依赖"></p>
<p>在上面这个循环依赖的例子中，Bean A, B, C 的创建过程简要概括如下 </p>
<ul>
<li>Bean A 被实例化</li>
<li>Bean A 的实例 a 对应的 ObjectFactory 会存入第三级缓存 singletonFactories 中，此时 a.b 为 null</li>
<li>BeanPostProcessor 查找到 Bean A 的依赖 b </li>
<li>从 BeanFactory 中查找 Bean B 的实例，没有找到</li>
<li>对 Bean B 进行实例化</li>
<li>Bean B 的实例 b 对应的 ObjectFactory 会存入第三级缓存 singletonFactories 中，此时 b.c 为 null</li>
<li>BeanPostProcessor 查找到 Bean B 的依赖 c</li>
<li>从 BeanFactory 中查找 Bean C 的实例，没有找到</li>
<li>对 Bean C 进行实例化</li>
<li>Bean C 的实例 c 对应的 ObjectFactory 会存入第三级缓存 singletonFactories 中，此时 c.a 为 null</li>
<li>BeanPostProcessor 查找到 Bean C 的依赖 a</li>
<li>从 BeanFactory 的三级缓存中找到了实例 a 对应的 ObjectFactory，通过 ObjectFactory 获取到了实例 a</li>
<li>返回实例 a 的同时，将实例 a 放入二级缓存 earlySingletonObjects 中，并将实例 a 对应的 ObjectFactory 从三级缓存 singletonFactories 中删除</li>
<li>通过反射将实例 a 赋值给 c.a</li>
<li>对实例 c 进行初始化，并将实例 c 放入一级缓存 singletonObjects 中</li>
<li>返回实例 c，通过反射将实例 c 复制给 b.c</li>
<li>对实例 b 进行初始化，并将实例 b 放入一级缓存 singletonObjects 中</li>
<li>返回实例 b，通过反射将实例 b 复制给 a.b</li>
<li>对实例 a 进行初始化，并将实例 a 放入一级缓存 singletonObjects 中</li>
</ul>
<p><img src="/assets/picture/spring.circular.reference.solving.png" alt="Spring 循环依赖处理流程" title="Spring 循环依赖处理流程"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Bean 生命周期</title>
    <url>/2020/06/20/%E6%8A%80%E6%9C%AF/spring/Spring%20Bean%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="Spring-的启动流程和-Bean-的生命周期"><a href="#Spring-的启动流程和-Bean-的生命周期" class="headerlink" title="Spring 的启动流程和 Bean 的生命周期"></a>Spring 的启动流程和 Bean 的生命周期</h1><p>为了探究一下 Spring 的启动流程和 Bean 的生命周期，这里启动了一个 <code>Spring Boot</code> 的 Web MVC 服务 ，从代码出发，分析 Spring 的启动流程和 Bean 的生命周期</p>
<h2 id="Spring-应用的启动"><a href="#Spring-应用的启动" class="headerlink" title="Spring 应用的启动"></a>Spring 应用的启动</h2><p>我们从 <code>SpringApplication#run</code> 方法开始入手，在这里回去创建一个 ApplicationContext，并且对 ApplicationContext 进行初始化刷新</p>
<p><img src="/assets/picture/spring_application_run.png" alt="SpringApplication#run" title="SpringApplication#run"></p>
<p>在 <code>SpringApplication#run</code> 方法中创建 ApplicationContext 的时候，会应用的类型去除去创建对应的 ApplicationContext， 而基于 <code>Servlet API</code> 的 Web 应用对应的 ApplicationContext 是 <code>AnnotationConfigServletWebServerApplicationContext</code></p>
<p><img src="/assets/picture/spring_application_create_application_context.PNG" alt="创建 ApplicationContext" title="创建 ApplicationContext"></p>
<h2 id="ApplicationContext-的初始化刷新-————-refresh-方法"><a href="#ApplicationContext-的初始化刷新-————-refresh-方法" class="headerlink" title="ApplicationContext 的初始化刷新 ———— refresh() 方法"></a><code>ApplicationContext</code> 的初始化刷新 ———— <code>refresh()</code> 方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        <span class="comment">// 初始化容器的状态及开始时间</span></span><br><span class="line">        <span class="comment">// 初始化占位符属性配置文件资源</span></span><br><span class="line">        <span class="comment">// 校验必填的占位符属性是否被解析处理</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        <span class="comment">// 刷新或者创建一个 DefaultListableBeanFactory</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        <span class="comment">// BeanFactory 的准备工作，进行一些设置</span></span><br><span class="line">        <span class="comment">// 设置 BeanFacotory 的类加载器</span></span><br><span class="line">        <span class="comment">// 设置 SpEL 表达式解析器</span></span><br><span class="line">        <span class="comment">// 设置文件资源及属性配置加载器</span></span><br><span class="line">        <span class="comment">// 设置需要忽略的依赖</span></span><br><span class="line">        <span class="comment">// 设置 BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext 等被解析的依赖</span></span><br><span class="line">        <span class="comment">// 注册 ApplicationListener 探测器到 Context 中</span></span><br><span class="line">        <span class="comment">// 注册 LoadTimeWeaverAware 探测器到 Context 中</span></span><br><span class="line">        <span class="comment">// 注册 LoadTimeWeaver 设置临时类加载器</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            <span class="comment">// 在 Context 中的 BeanFactory 在初始化之后，进行自定义的修改，例如扫描指定包中或者指定注解修饰的 Bean </span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            <span class="comment">// 触发 BeanFactoryPostProcessor 和 BeanDefinitionRegistryPostProcessor 对BeanDefinition 进行自定义修改</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            <span class="comment">// 向 BeanFactory 中注册 BeanPostProcessor</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            <span class="comment">// 初始化 MessageSource，用于参数替换和国际化</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            <span class="comment">// 从 BeanFactory 获取 ApplicationEventMulticaster，注册到 ApplicationContext 中去，如果没有则新建 SimpleApplicationEventMulticaster</span></span><br><span class="line">            <span class="comment">// ApplicationEventMulticaster 管理一组 ApplicationListener， 并且向这些 ApplicationListener 广播事件消息</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            <span class="comment">// ApplicationContext 的子类初始化特殊的 Bean</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            <span class="comment">// 从 BeanFactory 中获取出所有的 ApplicationListener 并向 ApplicationEventMulticaster 注册</span></span><br><span class="line">            <span class="comment">// 通过 ApplicationEventMulticaster 向 ApplicationListener 广播早期的事件消息</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            <span class="comment">// 实例化 BeanFactory 中的所有非懒加载的单例对象</span></span><br><span class="line">            <span class="comment">// 1. 为 BeanFactory 注册 ConversionService，ConversionService 类型转化的工具类</span></span><br><span class="line">            <span class="comment">// 2. 注册解析内嵌的字符串的 StringValueResolver</span></span><br><span class="line">            <span class="comment">// 3. 初始化 LoadTimeWeaverAware </span></span><br><span class="line">            <span class="comment">// 4. 将为加载 LoadTimeWeaverAware 的临时的 ClassLoader 设置为 null</span></span><br><span class="line">            <span class="comment">// 5. 将 Configuration 置为冻结，将所有的 Bean 的定义元数据都缓存起来，不接受后续改动</span></span><br><span class="line">            <span class="comment">// 6. 将所有非懒加载的单例 Bean 都实例化并且初始化</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            <span class="comment">// 完成刷新操作</span></span><br><span class="line">            <span class="comment">// 1. 清理资源加载相关的缓存</span></span><br><span class="line">            <span class="comment">// 2. 初始化 ApplicationContext 中的 LifecycleProcessor，用于管理 Bean 的生命周期，如果没有 LifecycleProcessor 则新建一个 DefaultLifecycleProcessor 用于此初始化动作</span></span><br><span class="line">            <span class="comment">// 3. 通知 LifecycleProcessor 刷新事件，通过 Lifecycle 触发Bean 的启动操作，如 Tomcat web 服务器的启动</span></span><br><span class="line">            <span class="comment">// 4. 发布完成刷新事件给 ApplicationListener</span></span><br><span class="line">            <span class="comment">// 5. 向 LiveBeansView 注册 ApplicationContext</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ApplicationContext 初始化失败之后，将创建好的 Bean 清除掉</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重置 ApplicationContext 的状态</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>ApplicationContext#refresh()</code> 方法中，对 <code>ApplicationContext</code> 进行了初始化的刷新，整体步骤如下</p>
<ul>
<li>prepareRefresh：刷新准备工作，设置状态、加载属性配置、校验必填属性配置</li>
<li>obtainFreshBeanFactory：创建 BeanFactory，默认值是 DefaultListableBeanFactory</li>
<li>prepareBeanFactory：BeanFactory 的应用前的准备工作，为 BeanFactory 进行一些基础设置</li>
<li>postProcessBeanFactory：在 ApplicationContext 的子类中对 BeanFactory 进行后后置处理，例如 ApplicationContext 指定了扫描范围的情况下，对扫描范围内的 Bean 进行扫描，注册 BeanDefinition</li>
<li>invokeBeanFactoryPostProcessors：调用 BeanFactoryPostProcessor，对初始化的 BeanDefinition 进行自定义修改；注意这里也会扫描加载 xml 或者 @Configuration 中的 Bean 的 BeanDefinition</li>
<li>registerBeanPostProcessors：从 BeanFactory 的 BeanDefinition 缓存中获取 BeanPostProcessor 注册到 ApplicationContext 中去，注意这里将 ApplicationListenerDetector 放到了 BeanPostProcessor 的队尾</li>
<li>initMessageSource：初始化 MessageSource，用于参数替换和国际化</li>
<li>initApplicationEventMulticaster：创建事件广播器 ApplicationEventMulticaster，注册到 ApplicationContext 中去，用于向一组 ApplicationListener 广播事件</li>
<li>onRefresh：调用 ApplicationContext 子类的初始化特定类型的 Bean</li>
<li>registerListeners：从 BeanFactory 的 BeanDefinition 缓存中获取 ApplicationListener，交由 ApplicationEventMulticaster管理，并注册到 ApplicationContext 中去 </li>
<li>finishBeanFactoryInitialization：将所有非懒加载的 Bean 进行实例化、初始化；完成后锁定容器上下文，不再允许改动 Bean 实例</li>
<li>finishRefresh：结束刷新，通过 LifecycleProcessor 启动自动启动的 Bean</li>
</ul>
<p>上述流程的具体时序图如下：</p>
<p><img src="/assets/picture/bean.lifecycle.flow.svg" alt="Spring Bean 生命周期时序图" title="Spring Bean 生命周期时序图"></p>
<h3 id="ApplicationContext-初始化刷新过程中的重要组件"><a href="#ApplicationContext-初始化刷新过程中的重要组件" class="headerlink" title="ApplicationContext 初始化刷新过程中的重要组件"></a>ApplicationContext 初始化刷新过程中的重要组件</h3><ul>
<li>BeanFactoryPostProcessor: 在 BeanFactory 初始化之后进行一些自定义设置<ul>
<li>BeanDefinitionRegistryPostProcessor: 对 BeanFactoryPostProcessor 的扩展，支持修改 BeanFactory 中初始化的 BeanDefinition<ul>
<li>ConfigurationClassPostProcessor: BeanDefinitionRegistryPostProcessor 的实现之一，有 BeanDefinitionRegistryPostProcessor 功能的基础上，支持扫描 @Configuration 中的 @Bean</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Bean-从创建到销毁"><a href="#Bean-从创建到销毁" class="headerlink" title="Bean 从创建到销毁"></a>Bean 从创建到销毁</h2><p><img src="/assets/picture/spring_bean_instantiation_flow.png" alt="Spring Bean 从创建到销毁" title="Spring Bean 从创建到销毁"></p>
<h3 id="Bean-从创建到销毁过程中的重要组件"><a href="#Bean-从创建到销毁过程中的重要组件" class="headerlink" title="Bean 从创建到销毁过程中的重要组件"></a>Bean 从创建到销毁过程中的重要组件</h3><p>在 Bean 从创建到销毁的过程中也有很多重要组件的</p>
<ul>
<li>InstantiationAwareBeanPostProcessor<ul>
<li>postProcessBeforeInstantiation: 中断 Bean 的正常初始化流程，创建一个 Bean 的代理实现替代 Bean 的实例</li>
<li>postProcessAfterInitialization: Bean 的实例或者代理实现进一步初始化之后，进行进一步自定义处理，如果是创建 Bean 的代理实现，则Bean 的创建流程到此结束，初始化流程被中断</li>
</ul>
</li>
<li>SmartInstantiationAwareBeanPostProcessor<ul>
<li>determineCandidateConstructors: 查找确认 Bean 实例化的构造方法，注意：个别子类视线中有其他逻辑</li>
</ul>
</li>
<li>AutowiredAnnotationBeanPostProcessor<ul>
<li>determineCandidateConstructors: SmartInstantiationAwareBeanPostProcessor 的实现，除了查找构造方法之后，还会查找 @Lookup 修饰的方法存放到 BeanDefinition 中去</li>
</ul>
</li>
<li>CglibSubclassingInstantiationStrategy<ul>
<li>instantiateWithMethodInjection: 通过 CGLIB 创建 Bean 的代理实现，含callback</li>
</ul>
</li>
<li>BeanNameAware<ul>
<li>setBeanName: 为 Bean 实例设置名称</li>
</ul>
</li>
<li>BeanClassLoaderAware<ul>
<li>setBeanClassLoader​: 为 Bean 实例设置 ClassLoader</li>
</ul>
</li>
<li>BeanFactoryAware<ul>
<li>setBeanFactory​: 为 Bean 设置 BeanFactory</li>
</ul>
</li>
<li>BeanPostProcessor<ul>
<li>postProcessBeforeInitialization​: 在 Bean 进行初始化之前进行插入处理</li>
<li>postProcessAfterInitialization: 在 Bean 进行初始化之后进行插入处理</li>
</ul>
</li>
<li>InitializingBean<ul>
<li>afterPropertiesSet: 在 postProcessBeforeInitialization​ 之后，postProcessAfterInitialization 之前进行 Bean 的初始化</li>
</ul>
</li>
<li>DefaultSingletonBeanRegistry<ul>
<li>维护三个层级的缓存，用于处理 singleton Bean 的循环依赖<ul>
<li>singleFactories: 三级缓存，保存 Bean 名称和其 ObjectFactory 的映射关系</li>
<li>earlySingletonObjects: 二级缓存，保存有其他依赖，被实例化没有初始化的 Bean</li>
<li>singletonObjects: 一级缓存，保存最终完成实例化、初始化 Bean 的缓存</li>
</ul>
</li>
</ul>
</li>
<li>DestructionAwareBeanPostProcessor<ul>
<li>postProcessBeforeDestruction: 进行 Bean 实例销毁前的插入操作</li>
</ul>
</li>
<li>DisposableBean<ul>
<li>destroy​: 在 DisposableBean#destroy​ 之后的销毁前插入操作</li>
</ul>
</li>
</ul>
<h2 id="Bean-的生命周期流程图"><a href="#Bean-的生命周期流程图" class="headerlink" title="Bean 的生命周期流程图"></a>Bean 的生命周期流程图</h2><p>将上述流程总结如下图：</p>
<p><img src="/assets/picture/spring_bean_lifecycle_flow.png" alt="Spring Bean 生命周期流程图" title="Spring Bean 生命周期流程图"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat 日志配置说明</title>
    <url>/2018/09/28/%E6%8A%80%E6%9C%AF/tomcat/tomcat%E7%9A%84%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>日志应该是除了代码之外，程序员最好的朋友了，它可以帮助我们定位问题、修复bug，或者是确认服务是否正常运转；很多时候我们做一次部署只是为了加几行日志；</p>
<p>而 <code>Tomcat</code> 作为经久畅销的web 服务器，一直是web 开发者首选，而 <code>Tomcat</code> 的原生日志是我们判断这个服务器是否正常运转的重要数据。</p>
<h3 id="Java-日志组件"><a href="#Java-日志组件" class="headerlink" title="Java 日志组件"></a>Java 日志组件</h3><p>这里我们按照历史顺序简单介绍一下 <code>Java</code> 常用的日志组件，</p>
<p><code>JUL</code>(Java Util Logging): 是 <code>jdk</code> 自带的log 实现组件，虽然是官方出品但是它并没有被广泛使用，主要是下面几个原因</p>
<ol>
<li><code>JUL</code> 出现的太晚了，2002年它才被放到 <code>jdk1.4</code> 中，当时已经有很多第三方的日志组件被广泛使用了</li>
<li><code>JUL</code> 早期性能问题太明显，到 <code>JDK1.5</code> 才有所改善，但是它和其他第三方日志组件<code>logback</code>或<code>log4j2</code>相比也还是有差距</li>
<li><code>JUL</code> 提供的功能不如第三方组件<code>logback</code>或<code>log4j2</code>完善</li>
</ol>
<p><code>log4j</code> 是在 <code>logback</code> 之前被广泛使用的日志实现组件，<code>log4j</code> 在设计上十分优秀，对后期的<code>Java</code> 日志框架有深远的影响，但是它在性能上存在缺陷；<code>logback</code> 出现之后就取代了 <code>log4j</code></p>
<p><code>JCL</code>(Apache Commons Logging): apache 提出的 <code>Log Facade</code>，只提供日志api，不提供实现，通过不同的 Adapter 来使用 <code>JUL</code> 或者 <code>log4j</code>；在打印日志的时候调用的都是 <code>JCL</code> 指定的api ，具体实现是看当前的 <code>classpath</code> 中有什么实现，如果什么都没有</p>
<p><code>slf4j</code>(The Simple Logging Facade For Java): <code>slf4j</code> 是 <code>Ceki Gülcü</code> 开发的 <code>Log Facade</code>，主要是因为<code>Ceki Gülcü</code> 觉得作为日志统一接口的 <code>JCL</code> 设计的不合理：<br/></p>
<p>下面这种写法不管是否输出 <code>debug</code> 级别的时候都需要做一次字符串拼接，如果这种代码被反复调用就会产生很多无用的字符串拼接，影响性能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;log:&quot;</span> + log);</span><br></pre></td></tr></table></figure>

<p>而官方给出的最佳时间方式是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">  logger.debug(<span class="string">&quot;log:&quot;</span> + log);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>怎么看都是反人类的设计，所以在 <code>slf4j</code> 中，设计的api 是这样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;log:&#123;&#125;&quot;</span>, log);</span><br></pre></td></tr></table></figure>

<p><code>logback</code>: <code>logback</code> 也是<code>Ceki Gülcü</code> 开发的日志实现，在 <code>log4j</code> 的基础上进行了改进，提供了更好的性能实现，异步logger，Filter 等更能多的特性。</p>
<p><code>Ceki Gülcü</code> 给我们开发了很好用的日志组件，但是现在有了两个 <code>Log Facade</code> 和三个流行的 <code>Log Implementation</code>，事情变的复杂了；<code>Ceki Gülcü</code> 作为一个完美主义者，为了我们能在不同的log 之间自由切换，他又开发了各种 <code>Adapater</code> 和 <code>Bridge</code> 来连接，这里盗用一张 <code>slf4j</code> 官网的图片</p>
<p><img src="/assets/picture/slf4j_over.png" alt="图片" title="slf4j 桥接其他日志api关系图"></p>
<p><code>log4j2</code>: <code>log4j2</code> 的开发维护人员不想看着 <code>log4j</code> 被 <code>slf4j/logback</code> 所取代，在设计上很大程度的模仿了 <code>slf4j/logback</code>，完全脱离<code>log4j1.x</code>，在性能上实现了很大的提升，作为一个高仿品这里不多介绍。</p>
<h3 id="Tomcat-的日志实现方法"><a href="#Tomcat-的日志实现方法" class="headerlink" title="Tomcat 的日志实现方法"></a><code>Tomcat</code> 的日志实现方法</h3><p><code>Tomcat</code> 内部整合的日志模块是 <code>JULI</code>，<code>JULI</code>是从 <code>JCL</code> fork 过来的一个重命名分支，默认被硬编码使用 <code>JUL</code> 作为日志实现，从而保证 <code>Tomcat</code> 本身的日志和业务日志实现完美隔离。<br>而<code>Tomcat</code>的日志的配置文件默认位置是 <code>$&#123;catalina.base&#125;/conf/logging.properties</code>，如果无法读取或不存在的时候，就会去找<code>$&#123;java.home&#125;/lib/logging.properties</code>；在web应用的范围内也有一个日志配置文件 <code>WEB-INF/classes/logging.properties</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment"># contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment"># this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment"># The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment"># (the &quot;License&quot;); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment"># the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"># See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"># limitations under the License.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 全局申明，tomcat 可以使用的 Handler</span></span><br><span class="line"><span class="attr">handlers</span> = <span class="string">1catalina.org.apache.juli.FileHandler, 2localhost.org.apache.juli.FileHandler, 3manager.org.apache.juli.FileHandler, 4host-manager.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 在</span></span><br><span class="line"><span class="meta">.handlers</span> = <span class="string">1catalina.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"><span class="comment"># Handler specific properties.</span></span><br><span class="line"><span class="comment"># Describes specific configuration info for Handlers.</span></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## catalina.out catalina.yyyy-MM-dd.log 日志的级别、日志文件位置、日志文件名称前缀配置</span></span><br><span class="line"><span class="meta">1catalina.org.apache.juli.FileHandler.level</span> = <span class="string">FINE</span></span><br><span class="line"><span class="meta">1catalina.org.apache.juli.FileHandler.directory</span> = <span class="string">$&#123;catalina.base&#125;/logs</span></span><br><span class="line"><span class="meta">1catalina.org.apache.juli.FileHandler.prefix</span> = <span class="string">catalina.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## localhost.yyyy-MM-dd.log 日志的级别、日志文件位置、日志文件名称前缀配置</span></span><br><span class="line"><span class="meta">2localhost.org.apache.juli.FileHandler.level</span> = <span class="string">FINE</span></span><br><span class="line"><span class="meta">2localhost.org.apache.juli.FileHandler.directory</span> = <span class="string">$&#123;catalina.base&#125;/logs</span></span><br><span class="line"><span class="meta">2localhost.org.apache.juli.FileHandler.prefix</span> = <span class="string">localhost.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## manager.yyyy-MM-dd.log 日志的级别、日志文件位置、日志文件名称前缀配置</span></span><br><span class="line"><span class="meta">3manager.org.apache.juli.FileHandler.level</span> = <span class="string">FINE</span></span><br><span class="line"><span class="meta">3manager.org.apache.juli.FileHandler.directory</span> = <span class="string">$&#123;catalina.base&#125;/logs</span></span><br><span class="line"><span class="meta">3manager.org.apache.juli.FileHandler.prefix</span> = <span class="string">manager.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## host-manager.yyyy-MM-dd.log 日志的级别、日志文件位置、日志文件名称前缀配置</span></span><br><span class="line"><span class="meta">4host-manager.org.apache.juli.FileHandler.level</span> = <span class="string">FINE</span></span><br><span class="line"><span class="meta">4host-manager.org.apache.juli.FileHandler.directory</span> = <span class="string">$&#123;catalina.base&#125;/logs</span></span><br><span class="line"><span class="meta">4host-manager.org.apache.juli.FileHandler.prefix</span> = <span class="string">host-manager.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## console 日志级别及格式设置</span></span><br><span class="line"><span class="meta">java.util.logging.ConsoleHandler.level</span> = <span class="string">FINE</span></span><br><span class="line"><span class="meta">java.util.logging.ConsoleHandler.formatter</span> = <span class="string">java.util.logging.SimpleFormatter</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"><span class="comment"># Facility specific properties.</span></span><br><span class="line"><span class="comment"># Provides extra control for each logger.</span></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].level</span> = <span class="string">INFO</span></span><br><span class="line"><span class="meta">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].handlers</span> = <span class="string">2localhost.org.apache.juli.FileHandler</span></span><br><span class="line"></span><br><span class="line"><span class="meta">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/manager].level</span> = <span class="string">INFO</span></span><br><span class="line"><span class="meta">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/manager].handlers</span> = <span class="string">3manager.org.apache.juli.FileHandler</span></span><br><span class="line"></span><br><span class="line"><span class="meta">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/host-manager].level</span> = <span class="string">INFO</span></span><br><span class="line"><span class="meta">org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/host-manager].handlers</span> = <span class="string">4host-manager.org.apache.juli.FileHandler</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For example, set the org.apache.catalina.util.LifecycleBase logger to log</span></span><br><span class="line"><span class="comment"># each component that extends LifecycleBase changing state:</span></span><br><span class="line"><span class="comment">#org.apache.catalina.util.LifecycleBase.level = FINE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># To see debug messages in TldLocationsCache, uncomment the following line:</span></span><br><span class="line"><span class="comment">#org.apache.jasper.compiler.TldLocationsCache.level = FINE</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>Java Web</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot auto-configuraion 浅析</title>
    <url>/2020/04/20/%E6%8A%80%E6%9C%AF/spring/SpringBoot%20autoconfiguration%20%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Sprint-Boot-Auto-configuration-浅析"><a href="#Sprint-Boot-Auto-configuration-浅析" class="headerlink" title="Sprint Boot Auto-configuration 浅析"></a>Sprint Boot Auto-configuration 浅析</h1><p><code>Spring Boot</code> 的自动配置是结合各种 <code>starter</code> 一起使用的</p>
<h3 id="Conditional-注解"><a href="#Conditional-注解" class="headerlink" title="Conditional 注解"></a><code>Conditional</code> 注解</h3><h4 id="Class-相关的-Conditional-注解"><a href="#Class-相关的-Conditional-注解" class="headerlink" title="Class 相关的 Conditional 注解"></a>Class 相关的 <code>Conditional</code> 注解</h4><h5 id="ConditionalOnClass-classpath-中存在指定的-Class-的时候命中条件，可以指定多个-Class"><a href="#ConditionalOnClass-classpath-中存在指定的-Class-的时候命中条件，可以指定多个-Class" class="headerlink" title="@ConditionalOnClass: classpath 中存在指定的 Class 的时候命中条件，可以指定多个 Class"></a><code>@ConditionalOnClass</code>: <code>classpath</code> 中存在指定的 <code>Class</code> 的时候命中条件，可以指定多个 <code>Class</code></h5><pre><code>- org.springframework.boot.autoconfigure.condition.ConditionalOnClass#value 通过 Class&lt;?&gt; 指定条件相关的一个或多个 Class
- org.springframework.boot.autoconfigure.condition.ConditionalOnClass#name 通过类的全限定名指定条件相关的一个或多个 Class</code></pre>
<h6 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 示例：当 classpath 中存在全限定名为 com.test.OneService 的类的时候命中条件，一个名为 testService1 的 Bean 将会注册到 Spring上下文中去</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(name = &quot;com.test.OneService&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestService1 <span class="title">testService1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestService1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 示例：当 classpath 中存在类型为 com.test.OneService 的类的时候命中条件，一个名为 testService2 的 Bean 将会注册到 Spring上下文中去</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(value = com.test.OneService.class)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestService2 <span class="title">testService2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestService2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ConditionalOnMissingClass-classpath-中不存在指定的-Class-的时候命中条件，可以指定多个-Class，只支持通过类的全限定名指定-Class"><a href="#ConditionalOnMissingClass-classpath-中不存在指定的-Class-的时候命中条件，可以指定多个-Class，只支持通过类的全限定名指定-Class" class="headerlink" title="@ConditionalOnMissingClass: classpath 中不存在指定的 Class 的时候命中条件，可以指定多个 Class，只支持通过类的全限定名指定 Class"></a><code>@ConditionalOnMissingClass</code>: <code>classpath</code> 中不存在指定的 <code>Class</code> 的时候命中条件，可以指定多个 <code>Class</code>，只支持通过类的全限定名指定 <code>Class</code></h5><pre><code>- org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass#value 通过类的全限定名指定条件相关的一个或多个 `Class`</code></pre>
<h6 id="示例-1"><a href="#示例-1" class="headerlink" title="示例:"></a>示例:</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 示例：当 classpath 中不存在全限定名为 com.test.OneService 的类的时候命中条件，一个名为 testService1 的 Bean 将会注册到 Spring上下文中去</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingClass(value = &quot;com.test.OneService&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestService1 <span class="title">testService1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestService1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Bean-相关的-Conditional-注解"><a href="#Bean-相关的-Conditional-注解" class="headerlink" title="Bean 相关的 Conditional 注解"></a>Bean 相关的 <code>Conditional</code> 注解</h4><h5 id="ConditionalOnBean-Spring-上下文中存在指定的-Bean-的时候命中条件，可以是当前的-Spring-上下文，也可以是当前-Spring-上下文的祖先，或者两者兼具"><a href="#ConditionalOnBean-Spring-上下文中存在指定的-Bean-的时候命中条件，可以是当前的-Spring-上下文，也可以是当前-Spring-上下文的祖先，或者两者兼具" class="headerlink" title="@ConditionalOnBean: Spring 上下文中存在指定的 Bean 的时候命中条件，可以是当前的 Spring 上下文，也可以是当前 Spring 上下文的祖先，或者两者兼具"></a><code>@ConditionalOnBean</code>: Spring 上下文中存在指定的 Bean 的时候命中条件，可以是当前的 Spring 上下文，也可以是当前 Spring 上下文的祖先，或者两者兼具</h5><pre><code>- org.springframework.boot.autoconfigure.condition.ConditionalOnBean#value 指定命中条件的 bean 的 Class
- org.springframework.boot.autoconfigure.condition.ConditionalOnBean#type 指定命中条件的 bean 的类的全限定名
- org.springframework.boot.autoconfigure.condition.ConditionalOnBean#annotation 指定修饰命中条件的 bean 的 Class 的注解，只有上下文中存在被注解修饰的 bean 的时候才能命中条件
- org.springframework.boot.autoconfigure.condition.ConditionalOnBean#name 指定命中条件的 bean 的名称
- org.springframework.boot.autoconfigure.condition.ConditionalOnBean#search 查询命中条件的 bean 的策略，可以查询当前 Spring 上下文、当前 Spring 上下文的祖先，或者所有 Spring 上下文
- org.springframework.boot.autoconfigure.condition.ConditionalOnBean#parameterizedContainer 可能在泛型中包含命中条件中的 bean 的类型的其他类</code></pre>
<p><strong><em>如果 @ConditionalOnBean 没有指定 value 和 type 属性时，将使用方法的返回值作为 type</em></strong></p>
<h6 id="示例-2"><a href="#示例-2" class="headerlink" title="示例:"></a>示例:</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 示例：当所有的 Spring 上下文中存在名为 oneService, 而且类型为 &quot;com.test.OneService&quot; 的 bean 的时候命中条件，一个名为 testService 的 Bean 将会注册到 Spring上下文中去</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(name = &quot;oneService&quot;, value = com.test.OneService.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestService <span class="title">testService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 示例：当前的 Spring 上下文中存在名为 oneService, 而且类的全限定名为 com.test.OneService 的 bean 的时候命中条件，一个名为 testService1 的 Bean 将会注册到 Spring上下文中去</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(name = &quot;oneService&quot;, type = &quot;com.test.OneService&quot;, search = SearchStrategy.CURRENT)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestService <span class="title">testService1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 示例：当前的 Spring 上下文中存在名为 oneService, 类的全限定名为为 com.test.OneService，而且 OneService 被 OneAnnotation 修饰时命中条件，一个名为 testService2 的 Bean 将会注册到 Spring上下文中去</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(name = &quot;oneService&quot;, type = &quot;com.test.OneService&quot;, annotation = com.test.OneAnnotation.class, search = SearchStrategy.CURRENT)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestService <span class="title">testService2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 示例：当所有的 Spring 上下文中存在类型为 com.learning.spring.service.OneServiceContainer 的 bean，且 OneServiceContainer 类的定义的泛型中包含 TestService 时命中条件，一个名为 testService3 的 Bean 将会注册到 Spring上下文中去</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(type = &quot;com.learning.spring.service.OneServiceContainer&quot;, parameterizedContainer = OneServiceContainer.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestService <span class="title">testService3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ConditionalOnMissingBean-Spring-上下文中不存在指定的-Bean-的时候命中条件，可以是当前的-Spring-上下文，也可以是当前-Spring-上下文的祖先，或者两者兼具；和-ConditionalOnBean-不同的是它还能指定被忽略的类"><a href="#ConditionalOnMissingBean-Spring-上下文中不存在指定的-Bean-的时候命中条件，可以是当前的-Spring-上下文，也可以是当前-Spring-上下文的祖先，或者两者兼具；和-ConditionalOnBean-不同的是它还能指定被忽略的类" class="headerlink" title="@ConditionalOnMissingBean: Spring 上下文中不存在指定的 Bean 的时候命中条件，可以是当前的 Spring 上下文，也可以是当前 Spring 上下文的祖先，或者两者兼具；和 @ConditionalOnBean 不同的是它还能指定被忽略的类"></a><code>@ConditionalOnMissingBean</code>: Spring 上下文中不存在指定的 Bean 的时候命中条件，可以是当前的 Spring 上下文，也可以是当前 Spring 上下文的祖先，或者两者兼具；和 <code>@ConditionalOnBean</code> 不同的是它还能指定被忽略的类</h5><pre><code>- value: 指定命中条件的 bean 的一个或多个 Class
- type: 指定命中条件的 bean 的一个或多个类的全限定名
- ignored: 指定查询条件相关的 bean 的需要被忽略的 Class
- ignoredType: 指定查询条件相关的 bean 的需要被忽略的类的全限定名
- annotation: 指定修饰命中条件的 bean 的 Class 的注解，只有上下文中存在被注解修饰的 bean 的时候才能命中条件
- name: 指定命中条件的 bean 的名称
- search: 查询命中条件的 bean 的策略，可以查询当前 Spring 上下文、当前 Spring 上下文的祖先，或者所有 Spring 上下文
- parameterizedContainer: 可能在泛型中包含命中条件中的 bean 的类型的其他类</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 示例：当所有的 Spring 上下文中不存在类型为 TestService 的 bean 的时候，创建类型为 TestService，名称为 testService1 的 Bean </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(value = TestService.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestService <span class="title">testService1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 示例：当所有的 Spring 上下文中不存在类型为 TestService 的 bean 的时候，创建类型为 TestService，名称为 testService1 的 Bean </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(value = TestService.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestService <span class="title">testService1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink 探究之路 ———— State</title>
    <url>/2019/01/26/%E6%8A%80%E6%9C%AF/flink/flink%E4%B9%8Bstate/</url>
    <content><![CDATA[<h1 id="Flink-中的-state-状态"><a href="#Flink-中的-state-状态" class="headerlink" title="Flink 中的 state(状态)"></a>Flink 中的 <code>state</code>(状态)</h1><p><code>flink</code> 提供了完善的数据保存机制，那就是 <code>state</code>，flink 中的 <code>Function</code> 和 <code>Operator</code> 在处理输入的过程中，将计算结果或存储到 <code>state</code> 中</p>
<h2 id="state-的分类"><a href="#state-的分类" class="headerlink" title="state 的分类"></a><code>state</code> 的分类</h2><p><code>flink</code> 中的 <code>state</code> 分为两种类型： <code>Key State</code> 和 <code>Operater State</code>。</p>
<h2 id="Key-State"><a href="#Key-State" class="headerlink" title="Key State"></a><code>Key State</code></h2><p><code>Key State</code> 总是和 <code>key</code> 相关联，只有 <code>KeyedStream</code> 中的 <code>Funciton</code> 和 <code>Operator</code> 能使用它。</p>
<p>你可以将 <code>Key State</code> 看作是已经被分割的 <code>Operator State</code>，而且每个 state 分区将对应一个 <code>key</code>，每一个 <code>Key State</code> 在逻辑上绑定一个唯一的结构复杂的 <code>key</code>，这个 <code>key</code> 的组成是 <code>&lt;parallel-operator-instance, key&gt;</code>，这里的 <code>key</code> 可以在代码中自有指定生成方法；而且因为每一个 <code>key</code> 都“属于”一个 <code>keyed-operaotr</code> 的并行实例（也可称为 sub-task）；我们可以将这个 <code>key</code> 的机构简化成 <code>&lt;operator, key&gt;</code>。</p>
<p><code>Key State</code> 可以更进一步被组织成 <code>Key Groups</code>, <code>Key Group</code> 是 flink 重新分配 <code>Key State</code> 的最小单位；<code>Key Group</code> 的数量和定义的最大并行度的数量一致（PS: 这里的最大并行度是当前 Operator 的并行度吗？还是当前运行环境中的最大并行度？），在运行时的 <code>keyed-operator</code> 的每一个并行实例会和 <code>key</code> 一起为一个或多个 <code>Key Group</code> 工作。</p>
<p><strong>*对于任何一个支持并行的 <code>Operator</code>，key 相同的事件，将被同一个并行实例处理，也只会出现在同一个 <code>task slot</code> 中，<code>Flink</code> 将 <code>Key State</code> 组织成 <code>Key Groups</code>，每个 <code>Key</code> 及其对应的 <code>Key State</code> 永久和一个特定的 <code>Key group</code> 相绑定，并且，每一个 <code>task slot</code> 负责处理一个或者多个 <code>Key group</code> 中的 key。 当 <code>Flink job</code> 被重新调节时候，<code>Operator</code> 的并行度发生变化，需要对 <code>state</code> 进行重新分配，<code>Flink</code> 承诺 <code>state</code> 的重新分配，将按照 <code>Key group</code> 为最小单位进行重新分配 *</strong></p>
<h2 id="Operator-State"><a href="#Operator-State" class="headerlink" title="Operator State"></a><code>Operator State</code></h2><p>每一个 <code>Operator State</code> 都会和一个 <code>Operator</code> 的并行实例绑定，<code>Kafka Consumer</code> 就是一个很好的使用flink 的 <code>Operator State</code> 的示例，每一个 <code>Kafka Consumer</code> 的并行实例都维护了一个 Map 类型的 <code>Operator State</code>，Map 的构成是 Kafka 的 <code>Topic Partition</code> 对应的 <code>Offset</code>。</p>
<p><code>Operator State</code> 接口支持当并行度发生变化的时候，在并行示例之间进行重新分配，这里有多种不同的重新分配的方法。</p>
<pre><code>    疑问：`Key State` 和 `Operator State` 在多个并行实例中是共享的？还是各自维护</code></pre>
<h2 id="Raw-and-Managed-State（原生和托管的状态"><a href="#Raw-and-Managed-State（原生和托管的状态" class="headerlink" title="Raw and Managed State（原生和托管的状态)"></a>Raw and Managed State（原生和托管的状态)</h2><p><code>Key State</code> 和 <code>Operator State</code> 有两种存在方式 <code>Raw State</code>(原生状态) 和 <code>Managed State</code>(托管状态)。</p>
<p><code>Manager State</code>（托管状态）：托管状态有flink 运行时控制的数据结构表示，比如内部哈希表或者 <code>RocksDB</code>，举例说明，<code>ListState</code>(List 结构的状态)、<code>MapState</code>（Map 结构的状态），flink 运行是将对状态进行编码并写入到 <code>checkpoint</code> 中。</p>
<p><code>Raw State</code>(原生状态)：原生状态将被 <code>Operator</code> 保存在它本身的数据结构中，当 <code>checkpoint</code> 被触发的时候，原生状态将以字节队列的形式写入到 <code>checkpoint</code> 中，flink 不知道原生状态的数据结构，仅能看到原生的字节数组。</p>
<p>所有数据流函数都能使用托管状态，但是只有实现 <code>operators</code> 才能使用原生状态。推荐使用托管状态，因为当并行度发生变化的时候，flink 可以重新分配托管状态，同时还能更好的管理内存。</p>
<h2 id="使用托管的-Key-State"><a href="#使用托管的-Key-State" class="headerlink" title="使用托管的 Key State"></a>使用托管的 <code>Key State</code></h2><p>托管的 <code>Key State</code> 接口支持方位当前输入元素的 <code>Key</code> 范围内的不同类型的状态， 这意味着 <code>Key State</code> 只能在 <code>KeyedStream</code> 上使用，通过调用 <code>keyBy(...)</code> 方法获得 <code>KeyedStream</code>。</p>
<p>下面是各种类型的 <code>Key State</code> 的介绍，然后再看在程序中该如何使用它们。</p>
<ul>
<li><p><code>ValueState&lt;T&gt;</code>：这里维护了单个 <code>T</code> 类型的可更新、可查看的状态值（由于上述输入元素的 <code>key</code> 的限定，每个 <code>key</code> 对应一个值），使用 <code>update(T t)</code> 方法更新状态， 使用 <code>value()</code> 方法获取状态值。</p>
</li>
<li><p><code>ListState&lt;T&gt;</code>：这里维护一个 <code>T</code> 类型的状态数组，通过 <code>update(List&lt;T&gt; list)</code> 更新整个状态数组，通过 <code>add(T t)</code> 来追加状态，通过 <code>addAll(List&lt;T&gt; list)</code> 来追加多个状态，通过 <code>get()</code> 来获取整个状态数组。</p>
</li>
<li><p><code>ReduceState&lt;T&gt;</code>：维护一个 <code>T</code> 类型的聚合状态值，聚合通过 <code>add(T t)</code> 方法添加的所有状态值，状态值的聚合通过自定义 <code>ReduceFunction</code> 来实现，通过 <code>get()</code> 来获取聚合状态值</p>
<pre><code>  org.apache.flink.api.common.functions.ReduceFunction&lt;T&gt;
  T ReduceFunction#reduce(T value1, T value2): 将两个 value 值进行合并，返回合并结果</code></pre>
</li>
</ul>
<ul>
<li><p><code>AggregatingState&lt;IN, OUT&gt;</code>：通过 <code>add(IN in)</code> 方法添加状态输入值，通过 自定义的 <code>AggregateFunction&lt;IN, ACC, OUT&gt;</code> 对输入值进行合并之后返回 <code>OUT</code> 类型的状态值，<code>AggregatingState</code> 和 <code>ReduceState</code> 类似，区别在于 <code>AggregatingState</code> 合并操作的输入数据类型和查询结果的数据类型可以不一致。</p>
<pre><code>  org.apache.flink.api.common.functions.AggregateFunction&lt;IN, ACC, OUT&gt;
  &lt;IN&gt;：输入类型
  &lt;ACC&gt;：自定义累计计数器的类型
  &lt;OUT&gt;：累计结果的类型
  ACC createAccumulator()：创建一个累计计数器，开始合并数据
  ACC add(IN value, ACC accumulator)：将输入数据累加到累计计数器上
  OUT getResult(ACC accumulator)：查询累计计数结果
  ACC merge(ACC a, ACC b)：合并两个累计计数器的数据</code></pre>
</li>
<li><p><code>MapState&lt;UK, UV&gt;</code>：维护 map 类型的状态集合，支持 map 类型数据结构的基本操作，支持 <code>put(UK k, UV v)</code>，<code>putAll(Map&lt;UK, UV&gt;)</code>，<code>get(UK k)</code>，<code>entries()</code>，<code>keys()</code>，<code>values()</code> 等操作。</p>
</li>
</ul>
<p><strong><em>上述所有 State 都支持 通过 clear() 方法类清除已经保存的状态数据</em></strong></p>
<p>需要注意的是：</p>
<ol>
<li>上述数据对象都是用来和状态数据交互的，无论状态数据是在内存中还是在硬盘中，或者其他存储介质中。</li>
<li><code>Key State</code> 中，所有状态数据都和 <code>key</code> 关联，状态数据查询结果取决于输入数据的<code>key</code>，所以在用户自定义函数（UDF, User Defined Function）中查询状态数据的时候，如果输入数据的 <code>key</code> 不一致，查询的状态数据结果也会不一致。</li>
</ol>
<p>在创建上述类型的 <code>Key Stated</code> 的时候需要用到 <code>StateDescriptor</code>，<code>StateDescriptor</code> 包含了状态的 <code>名称</code>，<code>状态值数据类型</code>，有时候还会包含一个 <code>UDF</code>，例如 <code>ReduceFunction</code>。</p>
<p>我们可以在 <code>RichFunction</code> 中通过 <code>RuntimeContext</code> 访问状态数据。<code>RuntimeContext</code> 提供如下方法创建各种类型的状态数据。</p>
<ul>
<li>ValueState<T> getState(ValueStateDescriptor<T>)</li>
<li>ReducingState<T> getReducingState(ReducingStateDescriptor<T>)</li>
<li>ListState<T> getListState(ListStateDescriptor<T>)</li>
<li>AggregatingState&lt;IN, OUT&gt; getAggregatingState(AggregatingStateDescriptor&lt;IN, ACC, OUT&gt;)</li>
<li>MapState&lt;UK, UV&gt; getMapState(MapStateDescriptor&lt;UK, UV&gt;)</li>
</ul>
<h3 id="状态生存时间-State-Time-To-Live-TTL"><a href="#状态生存时间-State-Time-To-Live-TTL" class="headerlink" title="状态生存时间(State Time-To-Live, TTL)"></a>状态生存时间(State Time-To-Live, TTL)</h3><p>每一个 <code>Key State</code> 都可以设置一个生存时间，如果一个状态数据设置了生存时间，当状态数据过期的时候，转态数据将被清除。</p>
<p>所有类型的状态数据都支持 <code>生存时间(Time-To-Live)</code>，对于 <code>List</code> 和 <code>Map</code> 类型的状态数据，<code>生存时间</code> 的粒度为集合中的单个数据。</p>
<p>我们通过 <code>StateTtlConfig</code> 来配置 状态数据的生存时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.StateTtlConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.ValueStateDescriptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.time.Time;</span><br><span class="line"></span><br><span class="line">StateTtlConfig ttlConfig = StateTtlConfig</span><br><span class="line">    .newBuilder(Time.seconds(<span class="number">1</span>))</span><br><span class="line">    .setUpdateType(StateTtlConfig.UpdateType.OnCreateAndWrite)</span><br><span class="line">    .setStateVisibility(StateTtlConfig.StateVisibility.NeverReturnExpired)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">ValueStateDescriptor&lt;String&gt; stateDescriptor = <span class="keyword">new</span> ValueStateDescriptor&lt;&gt;(<span class="string">&quot;text state&quot;</span>, String.class);</span><br><span class="line">stateDescriptor.enableTimeToLive(ttlConfig);</span><br></pre></td></tr></table></figure>

<p><code>StateDescriptor</code> 默认是不支持设置状态生存时间的，通过 <code>enableTimeToLive(StateTtlConfig ttlConfig)</code> 方法来设置状态生存时间。</p>
<p><code>StateTtlConfig</code> 中提供如下属性</p>
<ul>
<li><p><code>StateTtlConfig.UpdateType</code>： 配置状态生存时间的 <code>上次访问时间</code> 的计算方式，<code>当前时间</code>和<code>上次访问时间</code>的时间间隔决定状态是否过期，取值如下：</p>
<ol>
<li><code>Disabled</code>：不设置状态生存时间</li>
<li><code>OnCreateAndWrite</code>：将创建或者写入时间作为 <code>上次访问时间</code>，默认使用该选项</li>
<li><code>OnReadAndWrite</code>：将读取或者写入时间作为 <code>上次访问时间</code></li>
</ol>
</li>
<li><p><code>StateTtlConfig.StateVisibility</code>：配置失效状态数据的可见性，决定当获取的状态数据已经失效时，返回什么？配置项取值如下：</p>
<ol>
<li><code>NeverReturnExpired</code> 不返回任何过期的状态数据，默认使用该选项</li>
<li><code>ReturnExpiredIfNotCleanedUp</code> 返回过期但是没有被清除的状态数据</li>
</ol>
</li>
<li><p><code>StateTtlConfig.TimeCharacteristic</code>：配置状态数据生存时间使用的时间类型，目前只支持 <code>ProcessingTime</code></p>
</li>
</ul>
<pre><code>    注意：
      1. `State backends` 将状态数据的最后修改时间戳和用户状态数据一起存储，这意味着`状态生存时间` 这一特性将增加状态存储的资源消耗。
      堆存储的 `State backends` 在内存中存储一个的额外的 java 对象，它包含一个long 类型的时间戳和一个用户状态数据对象。
      而 `RocksDB` 存储的`State backend` 则是为每一个状态数据（包含List或Map中的单个数据）额外存储 8 bytes 长度的时间戳数据
      2. 目前状态生存时间只支持 `ProcessingTime` 时间类型
      3. 当恢复状态的时候，如果状态数据之前没有设置状态生存时间，现在改为设置了状态生存时间；
      或者于此相反的情况下，将出现 `兼容性错误`，抛出 `StateMigrationException`
      4. 状态生存时间的配置数据，不是 `checkpoint` 和 `savepoint` 的一部分。但是它决定了当前运行任务如何对待 `checkpoint` 或者 `savepoint`。
      5. 声明生存时间的 map 类型的状态数据支持可序列话的null 类型的状态数据。如果 null 数据不支持序列化，可以使用 `NullableSerializer` 来包装数据，代价是在 `Serialized from` 增加额外的字节。</code></pre>
<h3 id="状态数据的清除"><a href="#状态数据的清除" class="headerlink" title="状态数据的清除"></a>状态数据的清除</h3><p>目前状态数据只有通过 <code>ValueState#value()</code> 方法被读取的状态数据会被删除，也就是说，如果状态数据一直没有被读取，就不会被删除！！！当然这个问题后期应该会被修复。目前的API 只支持在获取完成状态快照的时候清理状态数据的大小（也就是这时候清除过期的状态数据），具体配置方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.StateTtlConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.time.Time;</span><br><span class="line"></span><br><span class="line">StateTtlConfig ttlConfig = StateTtlConfig</span><br><span class="line">    .newBuilder(Time.seconds(<span class="number">1</span>))</span><br><span class="line">    .cleanupFullSnapshot()</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>但是需要注意的是，当我们使用增量型 checkpoint，不支持<code>cleanupFullSnapshot()</code>！</p>
<p><strong><em>问题：8 bytes 不够存储时间戳吧？？？</em></strong></p>
<h2 id="使用托管的-Operator-State"><a href="#使用托管的-Operator-State" class="headerlink" title="使用托管的 Operator State"></a>使用托管的 <code>Operator State</code></h2><p>想要使用托管的 <code>Operator State</code>，<code>Operator</code> 或者 <code>Function</code> 需要实现 <code>CheckpointedFunction</code> 接口，或者 <code>ListCheckPointed&lt;T extend Serializable&gt;</code> 接口。</p>
<h3 id="CheckpointedFunction"><a href="#CheckpointedFunction" class="headerlink" title="CheckpointedFunction"></a><code>CheckpointedFunction</code></h3><p><code>CheckpointedFunction</code> 提供以下两个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每次需要生成的时候调用该方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">snapshotState</span><span class="params">(FunctionSnapshotContext context)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当用户自定义函数(User-Defined-Function,UDF) 初始化的时候调用此方法</span></span><br><span class="line"><span class="comment"> * 分为两种被调用的场景</span></span><br><span class="line"><span class="comment"> * 1. 自定义函数第一次被初始化的时候被调用</span></span><br><span class="line"><span class="comment"> * 2. 从历史 checkpoint 中恢复数据的时候会被调用</span></span><br><span class="line"><span class="comment"> * 因此此方法被用于初始化状态数据或者从checkpoint中恢复状态数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initializeState</span><span class="params">(FunctionInitializationContext context)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>

<p>现在 <code>Operator State</code> 只支持 list 类型的状态数据，其中保存的都必须是可序列化的状态数据，而且list 中的数据相互独立，这意味着 <code>Operator State</code> 支持重新分配。不同的 <code>Operator State</code> 访问方法决定了不同的重新分配的方式：</p>
<ol>
<li><p>Even-split redistribution：每个算子返回一个状态数据的list集合。 当从 checkpoint 中恢复状态数据或者进行重新分配的时候，List 类型的状态数据将被切割成和并行示例数量一致的子链表，每个算子获得一个子链表，子链表可能为空，也可能包含一个或多个数据。例如，当一个并行度为1 算子，拥有一个 ListState，其中包含数据 e1、e2，当算子的并行改成 2 的时候，发生重新分配，ListState 被切分成两个子链，算子的并行实例1 获得包含 e1 的ListState, 并行实例2 获得包含 e2 的ListState。</p>
</li>
<li><p>Union redistribution：每个算子返回一个状态数据的 List 集合，包含所理由的状态数据。当发生重新分配或者从 checkpoint 中恢复状态数据的时候，每个算子都将获取到全部的状态数据。</p>
</li>
</ol>
<p><code>Operator State</code> 的使用方法和 <code>Key State</code> 类似，都是通过 <code>StateDescriptor</code> 来初始化状态数据，下面这个例子使用了 <code>Even-split redistribution</code> 类型的重新分配模式的 <code>Operator State</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferingSink</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">SinkFunction</span>&lt;<span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt;,</span></span><br><span class="line"><span class="class">                   <span class="title">CheckpointedFunction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ListState&lt;Tuple2&lt;String, Integer&gt;&gt; checkpointedState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Tuple2&lt;String, Integer&gt;&gt; bufferedElements;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferingSink</span><span class="params">(<span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">        <span class="keyword">this</span>.bufferedElements = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Tuple2&lt;String, Integer&gt; value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        bufferedElements.add(value);</span><br><span class="line">        <span class="keyword">if</span> (bufferedElements.size() == threshold) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Tuple2&lt;String, Integer&gt; element: bufferedElements) &#123;</span><br><span class="line">                <span class="comment">// send it to the sink</span></span><br><span class="line">            &#125;</span><br><span class="line">            bufferedElements.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">snapshotState</span><span class="params">(FunctionSnapshotContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        checkpointedState.clear();</span><br><span class="line">        <span class="keyword">for</span> (Tuple2&lt;String, Integer&gt; element : bufferedElements) &#123;</span><br><span class="line">            checkpointedState.add(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initializeState</span><span class="params">(FunctionInitializationContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ListStateDescriptor&lt;Tuple2&lt;String, Integer&gt;&gt; descriptor =</span><br><span class="line">            <span class="keyword">new</span> ListStateDescriptor&lt;&gt;(</span><br><span class="line">                <span class="string">&quot;buffered-elements&quot;</span>,</span><br><span class="line">                TypeInformation.of(<span class="keyword">new</span> TypeHint&lt;Tuple2&lt;String, Integer&gt;&gt;() &#123;&#125;));</span><br><span class="line"></span><br><span class="line">        checkpointedState = context.getOperatorStateStore().getListState(descriptor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 当从历史 checkpoint 中恢复状态数据的时候，需要读取保存历史状态数据</span></span><br><span class="line"><span class="comment">        * isRestored 方法可以查询当前是否缓存了历史状态数据</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (context.isRestored()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Tuple2&lt;String, Integer&gt; element : checkpointedState.get()) &#123;</span><br><span class="line">                bufferedElements.add(element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取 <code>Operator State</code> 的入口是 <code>OperatorStateStore</code> 提供的方法，这些方法的命名能够见名之意，如果要使用 <code>Union redistribution</code> 重新分配模式的 <code>Operator State</code>，我们将使用 <code>getUnionListState(StateDescriptor stateDescriptor)</code> 访问状态数据。如果只是使用 <code>Even-split redistribution</code> 重新分配模式的 <code>Operaotor State</code>，调用 <code>getListState(StateDescriptor stateDescriptor)</code> 方法。</p>
<p>顺便说一句，<code>Key State</code> 也可以在 <code>initializeState</code> 方法中被初始化。</p>
<h3 id="ListCheckpointed"><a href="#ListCheckpointed" class="headerlink" title="ListCheckpointed"></a><code>ListCheckpointed</code></h3><p>相对于 <code>CheckpointedFunction</code> 接口，<code>ListCheckPointed</code> 接口只支持 <code>Even-split redistribution</code>（偶切分重新分配模式）的 ListState。<code>ListCheckpointed</code> 接口包含如下两个接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个状态数据的 List 用于生成 checkpoint，</span></span><br><span class="line"><span class="comment">* 如果状态数据保证不会被重新分区，可以永远返回 `Collections.singletonList(MY_STATE)`</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">snapshotState</span><span class="params">(<span class="keyword">long</span> checkpointId, <span class="keyword">long</span> timestamp)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 重历史 checkpoint 恢复历史状态数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">restoreState</span><span class="params">(List&lt;T&gt; state)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>


<h2 id="CheckpointListener"><a href="#CheckpointListener" class="headerlink" title="CheckpointListener"></a><code>CheckpointListener</code></h2><p>如果生成 <code>checkpoint</code> 的时候需要周知其他服务，可以使用 <code>CheckpointListener</code>。</p>
<p><strong><em>待补充</em></strong></p>
<h2 id="广播状态-Broadcast-State"><a href="#广播状态-Broadcast-State" class="headerlink" title="广播状态(Broadcast State)"></a>广播状态(Broadcast State)</h2><p>关于广播状态，简而言之，就是一个输入数据对下游的所有处理流程都有影响，需要周知所有下游处理算子。例如一个低流速数据处理规则输入流是高流速的数据数据流，规则输入流需要广播给处理数据的所有算子。</p>
<p>广播状态与其他 <code>Operator State</code> 之间有三个主要区别。与其余的 operator state 相反，广播状态：</p>
<ul>
<li>Map 的格式</li>
<li>每个算子只能有一条广播的输入流和一个非广播输入流</li>
<li>算子可以有多个不同名字的广播状态</li>
</ul>
<h3 id="广播状态相关-API"><a href="#广播状态相关-API" class="headerlink" title="广播状态相关 API"></a>广播状态相关 <code>API</code></h3><p>对于广播状态的使用<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/stream/state/broadcast_state.html" title="广播状态">待补充</a>，这里重点突出如下注意事项。</p>
<h3 id="重要注意事项"><a href="#重要注意事项" class="headerlink" title="重要注意事项"></a>重要注意事项</h3><p>在使用广播状态时要记住以下4个重要事项：</p>
<ul>
<li><p>使用广播状态，<code>Operator Task</code> 之间不会相互通信<br/><br>这也是为什么只有状态广播方 <code>(Keyed)-BroadcastProcessFunction</code> 能修改广播状态数据的内容；此外，用户需要保证所有并发实例上对于广播状态的输入源的处理逻辑是幂等的，否则不同的并发实例将拥有不一致的广播状态，导致处理结果等数据不一致。</p>
</li>
<li><p>不同的 <code>Operator Task</code> 中的广播状态的顺序可能不一致<br/><br>虽然 <code>Flink</code>  保证广告状态都会下发给所有算子，不会丢失，但是并不保证广播状态的顺序一致性。因此对于广播状态不能依赖于输入数据的顺序。</p>
</li>
</ul>
<ul>
<li><p>所有并行实例都会快照一份广播状态数据<br/><br>虽然所有并行实例中的广播状态都是一致的（正常使用的情况下），但是每个并行实例都会快找一份自己的广播数据，而不是只快照一份。这种设计是为了避免多个并行示例在恢复期间从单个文件读取数据而造成热点问题。但是也导致了随着并行度的增大，<code>checkpoint</code> 数据大小也会膨胀。<code>Flink</code> 保证数据恢复/扩容的时候不会产生重复的数据，也不会丢失数据。在以相同或者更小的并行度恢复时，每个 <code>task</code> 读取对应的 <code>checkpoint</code>，在以更大的并行度恢复时，每个 <code>task</code> 读取自己的 <code>checkpoint</code>，剩余新增的 <code>task</code> 会循环读取 <code>checkpoint</code>。</p>
</li>
<li><p><code>RocksDB state backend</code> 不支持广播状态<br/><br>广播状态目前在运行时保存在内存中。因为当前，<code>RocksDB state backends</code>还不支持广播状态。</p>
</li>
</ul>
<p>这里谨期望广播状态能够进一步优化。</p>
<h6 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h6><p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/stream/state/">https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/stream/state/</a><br/><br><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/stream/state/state.html">https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/stream/state/state.html</a><br><a href="https://stackoverflow.com/questions/45738021/flink-state-backend-keys-atomicy-and-distribution">https://stackoverflow.com/questions/45738021/flink-state-backend-keys-atomicy-and-distribution</a><br/></p>
<p>本人 flink 小白一枚，如有错漏之处，敬请斧正！</p>
]]></content>
      <categories>
        <category>flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
        <tag>state</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink 安装和运行</title>
    <url>/2018/11/19/%E6%8A%80%E6%9C%AF/flink/flink%E5%AE%89%E8%A3%85%E5%92%8C%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="Flink-安装和运行"><a href="#Flink-安装和运行" class="headerlink" title="Flink 安装和运行"></a><code>Flink</code> 安装和运行</h1><h2 id="单点安装"><a href="#单点安装" class="headerlink" title="单点安装"></a>单点安装</h2><h3 id="下载-flink-安装包"><a href="#下载-flink-安装包" class="headerlink" title="下载 flink 安装包"></a>下载 flink 安装包</h3><p>在 <a href="https://flink.apache.org/downloads.html" title="官网下载地址">官网下载地址</a> 选择适当版本的flink 安装包，这里我选择 <code>Apache Flink 1.6.2 only</code>；下载安装包到 <code>/path/to/flink-1.6.2</code> 中</p>
<h3 id="解压运行-flink"><a href="#解压运行-flink" class="headerlink" title="解压运行 flink"></a>解压运行 flink</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/</span><br><span class="line">tar -xvf flink-1.6.2.tgz</span><br><span class="line"><span class="built_in">cd</span> flink-1.6.2</span><br><span class="line">sh ./bin/start-cluster.sh</span><br></pre></td></tr></table></figure>

<p>到这里我们就已经把 <code>单机版flink</code> 成功的运行起来了，我们可以访问 <code>localhost:8081</code> 看到 <code>flink</code> 管理页面</p>
<p><img src="/assets/picture/flink.single.png" alt="图片" title="单机版flink运行"></p>
<h2 id="flink-集群搭建准备工作"><a href="#flink-集群搭建准备工作" class="headerlink" title="flink 集群搭建准备工作"></a><code>flink</code> 集群搭建准备工作</h2><h3 id="JAVA-环境配置"><a href="#JAVA-环境配置" class="headerlink" title="JAVA 环境配置"></a>JAVA 环境配置</h3><p><strong><em>这里不赘述如何配置 JAVA 环境，只需要注意使用 JAVA 1.8+ 即可</em></strong></p>
<h3 id="集群机器互信"><a href="#集群机器互信" class="headerlink" title="集群机器互信"></a>集群机器互信</h3><p>不管是 <code>standalone</code> 部署模式还是依赖 <code>hadoop yarn</code> 搭建集群，都需要在集群机器之间设置互信，实现 <code>ssh</code> 相互免密登录</p>
<ol>
<li>生成<code>公钥/秘钥</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa  <span class="comment">#一直回车即可</span></span><br></pre></td></tr></table></figure>
<p>生成了 <code>~/.ssh/id_rsa.pub</code> 和 <code>~/.ssh/id_rsa</code></p>
<ol start="2">
<li>公钥认证</li>
</ol>
<p>将机器A 上面的 <code>~/.ssh/id_rsa.pub</code> 追加到机器B 的公钥认证文件 <code>~/.ssh/authorized_keys</code> 里面去；<br>再将机器B 上面的 <code>~/.ssh/id_rsa.pub</code> 追加到机器A 的公钥认证文件 <code>~/.ssh/authorized_keys</code> 里面去</p>
<p>这样我们就可以在机器A、B之间互相免密码登陆了</p>
<h2 id="flink-on-yarn-集群搭建"><a href="#flink-on-yarn-集群搭建" class="headerlink" title="flink on yarn 集群搭建"></a><code>flink on yarn</code> 集群搭建</h2><p>在 <code>10.0.0.1</code>，<code>10.0.0.2</code>，<code>10.0.0.3</code> 三台机器上尝试搭建 <code>flink</code> 集群</p>
<h3 id="hadoop-yarn-安装配置"><a href="#hadoop-yarn-安装配置" class="headerlink" title="hadoop yarn 安装配置"></a><code>hadoop yarn</code> 安装配置</h3><h4 id="下载解压-hadoop-安装包"><a href="#下载解压-hadoop-安装包" class="headerlink" title="下载解压 hadoop 安装包"></a>下载解压 <code>hadoop</code> 安装包</h4><p>这里我用的 <code>cdh</code> 版本的 <code>hadoop</code>，可以在<a href="http://archive-primary.cloudera.com/cdh5/cdh/5/" title="hadoop cdh">这里</a>下载，然后解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf hadoop-2.6.0-cdh5.11.0.tar.gz</span><br></pre></td></tr></table></figure>

<h4 id="配置-hadoop"><a href="#配置-hadoop" class="headerlink" title="配置 hadoop"></a>配置 <code>hadoop</code></h4><p>在 <code>/path/to/hadoop-2.6.0-cdh5.11.0/etc/hadoop/</code> 文件夹下配置如下七个文件 <code>hadoop-env.sh</code>，<code>yarn-env.sh</code>，<code>slaves</code>，<code>core-site.xml</code>，<code>hdfs-site.xml</code>，<code>mapred-site.xml</code>，<code>yarn-site.xml</code></p>
<h5 id="在-hadoop-env-sh"><a href="#在-hadoop-env-sh" class="headerlink" title="在 hadoop-env.sh"></a>在 <code>hadoop-env.sh</code></h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/path/to/java/home</span><br></pre></td></tr></table></figure>

<h5 id="在-yarn-env-sh-中配置-JAVA-HOME"><a href="#在-yarn-env-sh-中配置-JAVA-HOME" class="headerlink" title="在 yarn-env.sh 中配置 JAVA_HOME"></a>在 <code>yarn-env.sh</code> 中配置 <code>JAVA_HOME</code></h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/path/to/java/home</span><br></pre></td></tr></table></figure>

<h5 id="在-slaves-中配置-slave-节点的ip-或者host"><a href="#在-slaves-中配置-slave-节点的ip-或者host" class="headerlink" title="在 slaves 中配置 slave 节点的ip 或者host"></a>在 <code>slaves</code> 中配置 slave 节点的ip 或者host</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">10.0.0.2</span><br><span class="line">10.0.0.3</span><br></pre></td></tr></table></figure>

<h5 id="修改-core-site-xml"><a href="#修改-core-site-xml" class="headerlink" title="修改 core-site.xml"></a>修改 <code>core-site.xml</code></h5><p>配置 <code>hadoop</code> 集群文件系统主机和端口、<code>hadoop</code> 临时目录</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- hadoop文件系统主机和端口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://10.0.0.1:9000/<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置 hadoop 临时目录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/path/to/hadoop-2.6.0-cdh5.11.0/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="修改-hdfs-site-xml"><a href="#修改-hdfs-site-xml" class="headerlink" title="修改 hdfs-site.xml"></a>修改 <code>hdfs-site.xml</code></h5><p>配置 <code>hadoop</code> 集群文件系统主机和端口、<code>hadoop</code> 临时目录</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- hadoop文件系统主机和端口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://10.0.0.1:9000/<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置 hadoop 临时目录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/path/to/hadoop-2.6.0-cdh5.11.0/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="standalone-部署模式集群搭建"><a href="#standalone-部署模式集群搭建" class="headerlink" title="standalone 部署模式集群搭建"></a><code>standalone</code> 部署模式集群搭建</h2><p>举例说明，搭建</p>
<h3 id="下载、解压安装包"><a href="#下载、解压安装包" class="headerlink" title="下载、解压安装包"></a>下载、解压安装包</h3><h3 id="修改-flink-conf-yaml-文件配置"><a href="#修改-flink-conf-yaml-文件配置" class="headerlink" title="修改 flink-conf.yaml 文件配置"></a>修改 <code>flink-conf.yaml</code> 文件配置</h3><p>修改 <code>/path/to/flink-1.6.2/conf</code> 文件中的 <code>flink-conf.yaml</code> 文件，参数说明如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># java安装路径，如果没有指定则默认使用系统的$JAVA_HOME环境变量。建议设置此值，因为之前我曾经在standalone模式中启动flink集群，报找不到JAVA_HOME的错误。config.sh中（Please specify JAVA_HOME. Either in Flink config ./conf/flink-conf.yaml or as system-wide JAVA_HOME.）</span></span><br><span class="line"><span class="attr">env.java.home:</span> <span class="string">/path/to/java/home</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定制JVM选项，在Flink启动脚本中执行。需要单独执行JobManager和TaskManager的选项。</span></span><br><span class="line"><span class="attr">env.java.opts:</span> <span class="string">-DXms=1024MB</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行jobManager的JVM选项。在Yarn Client环境下此参数无效。</span></span><br><span class="line"><span class="attr">env.java.opts.jobmanager:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行taskManager的JVM选项。在Yarn Client环境下此参数无效。</span></span><br><span class="line"><span class="attr">env.java.opts.taskmanager:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Jobmanager的IP地址，即master地址。默认是localhost，此参数在HA环境下或者Yarn下无效，仅在local和无HA的standalone集群中有效。</span></span><br><span class="line"><span class="attr">jobmanager.rpc.address:</span> <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JobMamanger的端口，默认是6123。</span></span><br><span class="line"><span class="attr">jobmanager.rpc.port:</span> <span class="number">6123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JobManager的堆大小（单位是MB）。当长时间运行operator非常多的程序时，需要增加此值。具体设置多少只能通过测试不断调整。</span></span><br><span class="line"><span class="attr">jobmanager.heap.mb:</span> <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每一个TaskManager的堆大小（单位是MB），由于每个taskmanager要运行operator的各种函数（Map、Reduce、CoGroup等，包含sorting、hashing、caching），因此这个值应该尽可能的大。如果集群仅仅跑Flink的程序，建议此值等于机器的内存大小减去1、2G，剩余的1、2GB用于操作系统。如果是Yarn模式，这个值通过指定tm参数来分配给container，同样要减去操作系统可以容忍的大小（1、2GB）。</span></span><br><span class="line"><span class="attr">taskmanager.heap.mb:</span> <span class="number">8196</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个TaskManager的并行度。一个slot对应一个core，默认值是1.一个并行度对应一个线程。总的内存大小要且分给不同的线程使用。</span></span><br><span class="line"><span class="attr">taskmanager.numberOfTaskSlots:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个operator的默认并行度。默认是1.如果程序中对operator设置了setParallelism，或者提交程序时指定了-p参数，则会覆盖此参数。如果只有一个Job运行时，此值可以设置为taskManager的数量 * 每个taskManager的slots数量。即NumTaskManagers  * NumSlotsPerTaskManager 。</span></span><br><span class="line"><span class="attr">parallelism.default:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认的文件系统模式。默认值是file:///即本地文件系统根目录。如果指定了hdfs://localhost:9000/，则程序中指定的文件/user/USERNAME/in.txt，即指向了hdfs://localhost:9000/user/USERNAME/in.txt。这个值仅仅当没有其他schema被指定时生效。一般hadoop中core-site.xml中都会配置fs.default.name。</span></span><br><span class="line"><span class="attr">fs.default-scheme:</span> <span class="string">hdfs://localhost:9000/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HDFS的配置路径。例如：/home/flink/hadoop/hadoop-2.6.0/etc/hadoop。如果配置了这个值，用户程序中就可以简写hdfs路径如：hdfs:///path/to/files。而不用写成：hdfs://address:port/path/to/files这种格式。配置此参数后，Flink就可以找到此路径下的core-site.xml和hdfs-site.xml了。建议配置此参数。</span></span><br><span class="line"><span class="attr">fs.hdfs.hadoopconf:</span> <span class="string">/home/flink/hadoop/hadoop-2.6.0/etc/hadoop</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># flink 服务的 http 端口</span></span><br><span class="line"><span class="attr">rest.port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>

<h2 id="flink-on-Yarn"><a href="#flink-on-Yarn" class="headerlink" title="flink on Yarn"></a>flink on Yarn</h2><h3 id="启动-yarn-session-运行-flink-job"><a href="#启动-yarn-session-运行-flink-job" class="headerlink" title="启动 yarn session 运行 flink job"></a>启动 yarn session 运行 flink job</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/yarn-session.sh -n 4 -jm 1024 -tm 4096 -s 32</span><br></pre></td></tr></table></figure>

<h4 id="yarn-session-sh-使用说明"><a href="#yarn-session-sh-使用说明" class="headerlink" title="yarn-session.sh 使用说明"></a><code>yarn-session.sh</code> 使用说明</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Usage:</span><br><span class="line">   Required</span><br><span class="line">     -n,--container &lt;arg&gt;   Number of YARN container to allocate (=Number of Task Managers)</span><br><span class="line">   Optional</span><br><span class="line">     -D &lt;property=value&gt;             use value for given property</span><br><span class="line">     -d,--detached                   If present, runs the job in detached mode</span><br><span class="line">     -h,--help                       Help for the Yarn session CLI.</span><br><span class="line">     -id,--applicationId &lt;arg&gt;       Attach to running YARN session</span><br><span class="line">     -j,--jar &lt;arg&gt;                  Path to Flink jar file</span><br><span class="line">     -jm,--jobManagerMemory &lt;arg&gt;    Memory for JobManager Container with optional unit (default: MB)</span><br><span class="line">     -m,--jobmanager &lt;arg&gt;           Address of the JobManager (master) to which to connect. Use this flag to connect to a different JobManager than the one specified in the configuration.</span><br><span class="line">     -n,--container &lt;arg&gt;            Number of YARN container to allocate (=Number of Task Managers)</span><br><span class="line">     -nl,--nodeLabel &lt;arg&gt;           Specify YARN node label for the YARN application</span><br><span class="line">     -nm,--name &lt;arg&gt;                Set a custom name for the application on YARN</span><br><span class="line">     -q,--query                      Display available YARN resources (memory, cores)</span><br><span class="line">     -qu,--queue &lt;arg&gt;               Specify YARN queue.</span><br><span class="line">     -s,--slots &lt;arg&gt;                Number of slots per TaskManager</span><br><span class="line">     -sae,--shutdownOnAttachedExit   If the job is submitted in attached mode, perform a best-effort cluster shutdown when the CLI is terminated abruptly, e.g., in response to a user interrupt, such</span><br><span class="line">                                     as typing Ctrl + C.</span><br><span class="line">     -st,--streaming                 Start Flink in streaming mode</span><br><span class="line">     -t,--ship &lt;arg&gt;                 Ship files in the specified directory (t for transfer)</span><br><span class="line">     -tm,--taskManagerMemory &lt;arg&gt;   Memory per TaskManager Container with optional unit (default: MB)</span><br><span class="line">     -yd,--yarndetached              If present, runs the job in detached mode (deprecated; use non-YARN specific option instead)</span><br><span class="line">     -z,--zookeeperNamespace &lt;arg&gt;   Namespace to create the Zookeeper sub-paths for high availability mode</span><br></pre></td></tr></table></figure>

<h4 id="yarn-会话管理"><a href="#yarn-会话管理" class="headerlink" title="yarn 会话管理"></a><code>yarn</code> 会话管理</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$yarn</span> application --<span class="built_in">help</span></span><br><span class="line">usage: application</span><br><span class="line"> -appStates &lt;States&gt;             Works with -list to filter applications</span><br><span class="line">                                 based on input comma-separated list of</span><br><span class="line">                                 application states. The valid application</span><br><span class="line">                                 state can be one of the following:</span><br><span class="line">                                 ALL,NEW,NEW_SAVING,SUBMITTED,ACCEPTED,RUN</span><br><span class="line">                                 NING,FINISHED,FAILED,KILLED</span><br><span class="line"> -appTypes &lt;Types&gt;               Works with -list to filter applications</span><br><span class="line">                                 based on input comma-separated list of</span><br><span class="line">                                 application types.</span><br><span class="line"> -<span class="built_in">help</span>                           Displays <span class="built_in">help</span> <span class="keyword">for</span> all commands.</span><br><span class="line"> -<span class="built_in">kill</span> &lt;Application ID&gt;          Kills the application.</span><br><span class="line"> -list                           List applications. Supports optional use</span><br><span class="line">                                 of -appTypes to filter applications based</span><br><span class="line">                                 on application <span class="built_in">type</span>, and -appStates to</span><br><span class="line">                                 filter applications based on application</span><br><span class="line">                                 state.</span><br><span class="line"> -movetoqueue &lt;Application ID&gt;   Moves the application to a different</span><br><span class="line">                                 queue.</span><br><span class="line"> -queue &lt;Queue Name&gt;             Works with the movetoqueue <span class="built_in">command</span> to</span><br><span class="line">                                 specify <span class="built_in">which</span> queue to move an</span><br><span class="line">                                 application to.</span><br><span class="line"> -status &lt;Application ID&gt;        Prints the status of the application.</span><br></pre></td></tr></table></figure>

<h3 id="直接提交-flink-job-到-yarn-集群"><a href="#直接提交-flink-job-到-yarn-集群" class="headerlink" title="直接提交 flink job 到 yarn 集群"></a>直接提交 flink job 到 yarn 集群</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/flink run -m yarn-cluster -yn 2 -yjm 1024 -ytm 1024 ./examples/batch/WordCount.jar</span><br></pre></td></tr></table></figure>

<h4 id="yarn-日常维护"><a href="#yarn-日常维护" class="headerlink" title="yarn 日常维护"></a><code>yarn</code> 日常维护</h4><h5 id="查看-yarn-session-中的-flink-job"><a href="#查看-yarn-session-中的-flink-job" class="headerlink" title="查看 yarn session 中的 flink job"></a>查看 <code>yarn session</code> 中的 flink job</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;flink list -m yarn-cluster -yid &lt;Yarn Application Id&gt; -r  </span><br></pre></td></tr></table></figure>

<h5 id="yarn-日志查看"><a href="#yarn-日志查看" class="headerlink" title="yarn 日志查看"></a><code>yarn</code> 日志查看</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn logs -applicationId &lt;applicationId&gt;</span><br></pre></td></tr></table></figure>

<h5 id="yarn-application-下线"><a href="#yarn-application-下线" class="headerlink" title="yarn application 下线"></a><code>yarn application</code> 下线</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn application -<span class="built_in">kill</span> &lt;applicationId&gt;</span><br></pre></td></tr></table></figure>

<h5 id="触发-savepoints-取消-flink-job"><a href="#触发-savepoints-取消-flink-job" class="headerlink" title="触发 savepoints 取消 flink job"></a>触发 <code>savepoints</code> 取消 flink job</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/flink cancel -s [savepointDirectory] &lt;jobID&gt;</span><br></pre></td></tr></table></figure>

<p>执行上述指令将得到如下提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cancelling job &lt;jobID&gt; with savepoint to &lt;savepointDirectory&gt;.</span><br><span class="line">Cancelled job &lt;jobID&gt;. Savepoint stored in &lt;savepointDirectory&gt;&#x2F;&lt;savepointID&gt;.</span><br></pre></td></tr></table></figure>

<h5 id="从-savepoints-恢复启动-flink-job"><a href="#从-savepoints-恢复启动-flink-job" class="headerlink" title="从 savepoints 恢复启动 flink job"></a>从 <code>savepoints</code> 恢复启动 flink job</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/flink run -s &lt;savepointDirectory&gt;/&lt;savepointID&gt; -m yarn-cluster -yn 2 -yjm 1024 -ytm 1024 ./examples/batch/WordCount.jar</span><br></pre></td></tr></table></figure>
<p><strong><em>这里 <code>-s</code> 参数值是执行<code>cancel</code> 指令的时候得到的 savepoint 保存地址&lt;savepointDirectory&gt;/&lt;savepointID&gt;</em></strong></p>
<h4 id="flink-run-指令"><a href="#flink-run-指令" class="headerlink" title="flink run 指令"></a><code>flink run</code> 指令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$./bin/flink run --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Action <span class="string">&quot;run&quot;</span> compiles and runs a program.</span><br><span class="line"></span><br><span class="line">  Syntax: run [OPTIONS] &lt;jar-file&gt; &lt;arguments&gt;</span><br><span class="line">  <span class="string">&quot;run&quot;</span> action options:</span><br><span class="line">     -c,--class &lt;classname&gt;               当 flink job 的 jar包中没有指定 mainfest 时，通过这个                                   </span><br><span class="line">                                          参数来指定包含 main() 方法，或者 getPlan() 方法的主类。</span><br><span class="line">     -C,--classpath &lt;url&gt;                 新增 flink 类加载器的</span><br><span class="line">                                          Adds a URL to each user code</span><br><span class="line">                                          classloader  on all nodes <span class="keyword">in</span> the</span><br><span class="line">                                          cluster. The paths must specify a</span><br><span class="line">                                          protocol (e.g. file://) and be</span><br><span class="line">                                          accessible on all nodes (e.g. by means</span><br><span class="line">                                          of a NFS share). You can use this</span><br><span class="line">                                          option multiple <span class="built_in">times</span> <span class="keyword">for</span> specifying</span><br><span class="line">                                          more than one URL. The protocol must</span><br><span class="line">                                          be supported by the &#123;@link</span><br><span class="line">                                          java.net.URLClassLoader&#125;.</span><br><span class="line">     -d,--detached                        以后台模式运行 flink job</span><br><span class="line">     -n,--allowNonRestoredState           Allow to skip savepoint state that</span><br><span class="line">                                          cannot be restored. You need to allow</span><br><span class="line">                                          this <span class="keyword">if</span> you removed an operator from</span><br><span class="line">                                          your program that was part of the</span><br><span class="line">                                          program when the savepoint was</span><br><span class="line">                                          triggered.</span><br><span class="line">     -p,--parallelism &lt;parallelism&gt;       The parallelism with <span class="built_in">which</span> to run the</span><br><span class="line">                                          program. Optional flag to override the</span><br><span class="line">                                          default value specified <span class="keyword">in</span> the</span><br><span class="line">                                          configuration.</span><br><span class="line">     -q,--sysoutLogging                   If present, suppress logging output to</span><br><span class="line">                                          standard out.</span><br><span class="line">     -s,--fromSavepoint &lt;savepointPath&gt;   Path to a savepoint to restore the job</span><br><span class="line">                                          from (<span class="keyword">for</span> example</span><br><span class="line">                                          hdfs:///flink/savepoint-1537).</span><br><span class="line">     -sae,--shutdownOnAttachedExit        If the job is submitted <span class="keyword">in</span> attached</span><br><span class="line">                                          mode, perform a best-effort cluster</span><br><span class="line">                                          shutdown when the CLI is terminated</span><br><span class="line">                                          abruptly, e.g., <span class="keyword">in</span> response to a user</span><br><span class="line">                                          interrupt, such as typing Ctrl + C.</span><br><span class="line">  Options <span class="keyword">for</span> yarn-cluster mode:</span><br><span class="line">     -d,--detached                        If present, runs the job <span class="keyword">in</span> detached</span><br><span class="line">                                          mode</span><br><span class="line">     -m,--jobmanager &lt;arg&gt;                Address of the JobManager (master) to</span><br><span class="line">                                          <span class="built_in">which</span> to connect. Use this flag to</span><br><span class="line">                                          connect to a different JobManager than</span><br><span class="line">                                          the one specified <span class="keyword">in</span> the</span><br><span class="line">                                          configuration.</span><br><span class="line">     -sae,--shutdownOnAttachedExit        If the job is submitted <span class="keyword">in</span> attached</span><br><span class="line">                                          mode, perform a best-effort cluster</span><br><span class="line">                                          shutdown when the CLI is terminated</span><br><span class="line">                                          abruptly, e.g., <span class="keyword">in</span> response to a user</span><br><span class="line">                                          interrupt, such as typing Ctrl + C.</span><br><span class="line">     -yD &lt;property=value&gt;                 use value <span class="keyword">for</span> given property</span><br><span class="line">     -yd,--yarndetached                   If present, runs the job <span class="keyword">in</span> detached</span><br><span class="line">                                          mode (deprecated; use non-YARN</span><br><span class="line">                                          specific option instead)</span><br><span class="line">     -yh,--yarnhelp                       Help <span class="keyword">for</span> the Yarn session CLI.</span><br><span class="line">     -yid,--yarnapplicationId &lt;arg&gt;       Attach to running YARN session</span><br><span class="line">     -yj,--yarnjar &lt;arg&gt;                  Path to Flink jar file</span><br><span class="line">     -yjm,--yarnjobManagerMemory &lt;arg&gt;    JobManager Container 的内存大小，默认单位是 MB</span><br><span class="line">     -yn,--yarncontainer &lt;arg&gt;            指定分配的 yarn container 的数量，等同于 flink Task Managers 的数量</span><br><span class="line">     -ynl,--yarnnodeLabel &lt;arg&gt;           Specify YARN node label <span class="keyword">for</span> the YARN</span><br><span class="line">                                          application</span><br><span class="line">     -ynm,--yarnname &lt;arg&gt;                Set a custom name <span class="keyword">for</span> the application</span><br><span class="line">                                          on YARN</span><br><span class="line">     -yq,--yarnquery                      Display available YARN resources</span><br><span class="line">                                          (memory, cores)</span><br><span class="line">     -yqu,--yarnqueue &lt;arg&gt;               Specify YARN queue.</span><br><span class="line">     -ys,--yarnslots &lt;arg&gt;                Number of slots per TaskManager</span><br><span class="line">     -yst,--yarnstreaming                 Start Flink <span class="keyword">in</span> streaming mode</span><br><span class="line">     -yt,--yarnship &lt;arg&gt;                 Ship files <span class="keyword">in</span> the specified directory</span><br><span class="line">                                          (t <span class="keyword">for</span> transfer)</span><br><span class="line">     -ytm,--yarntaskManagerMemory &lt;arg&gt;   单个 taskManager 的内存大小，默认单位是 MB</span><br><span class="line">     -yz,--yarnzookeeperNamespace &lt;arg&gt;   Namespace to create the Zookeeper</span><br><span class="line">                                          sub-paths <span class="keyword">for</span> high availability mode</span><br><span class="line">     -z,--zookeeperNamespace &lt;arg&gt;        Namespace to create the Zookeeper</span><br><span class="line">                                          sub-paths <span class="keyword">for</span> high availability mode</span><br><span class="line"></span><br><span class="line">  Options <span class="keyword">for</span> default mode:</span><br><span class="line">     -m,--jobmanager &lt;arg&gt;           Address of the JobManager (master) to <span class="built_in">which</span></span><br><span class="line">                                     to connect. Use this flag to connect to a</span><br><span class="line">                                     different JobManager than the one specified</span><br><span class="line">                                     <span class="keyword">in</span> the configuration.</span><br><span class="line">     -z,--zookeeperNamespace &lt;arg&gt;   Namespace to create the Zookeeper sub-paths</span><br><span class="line">                                     <span class="keyword">for</span> high availability mode</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink 探究之路 ———— 容错机制，Checkpoint 和 Savepoint</title>
    <url>/2019/01/26/%E6%8A%80%E6%9C%AF/flink/flink%E4%B9%8Bsavepoints%E5%92%8Ccheckpoints/</url>
    <content><![CDATA[<h1 id="Flink-数据流容错机制译文"><a href="#Flink-数据流容错机制译文" class="headerlink" title="Flink 数据流容错机制译文"></a>Flink 数据流容错机制译文</h1><p><code>Flink</code> 最吸引使用者的地方就是它提供的容错机制保证可以持续性的恢复数据流应用程序的<code>状态</code>。<code>Flink</code> 保证即使在失败的情况下，数据流中的每一条数据最终也能确保只会对状态数据响应一次（<code>exactly once</code>）。<code>响应一次</code> 的机制可以手动降级到 <code>至少响应一次</code>(<code>at least once</code>)。</p>
<p><code>容错机制</code> 对分布式流式数据持续性的产生<code>快照</code>(<code>snapshot</code>)并存储。对于持有小型数据状态的数据流应用来说，产生 <code>快照</code> 的过程是很轻量级的，对于数据流的正常处理过程的影响微乎其微。数据流应用的 <code>状态</code> 数据可以存储到一个可配置的环境(<code>Master</code>节点中，或者 <code>HDFS</code> 中）。</p>
<p>当程序失败（机器、网络或者软件故障）的时候，<code>Flink</code> 将停止分布式数据流应用。然后再从最后一次成功的 <code>checkpoint</code> 中保存的 <code>状态</code>(<code>state</code>) 数据中恢复应用的所有 <code>算子</code>（<code>Operator</code>）。输入数据也被重置到最后一次成功的<code>快照</code>数据中保存的位置 。 <code>Flink</code> 保证并行数据流在重启之后处理的所有数据都不会是最近一次成功的 <code>checkpoint</code> 之前的数据。</p>
<pre><code>注意：
1. `checkpointing` 功能默认是关闭的，需要手动配置，指定开启 `checkpointing`，具体操作说明详见：[Checkpointing 说明文档](https://ci.apache.org/projects/flink/flink-docs-master/dev/stream/state/checkpointing.html)
2. 在 `Flink` 完成保证的基础上，数据流输入源 (`streaming source`)需要保障能回退到指定的最近一个位置。在 `Apache Kafka ` 提供这个能力的基础上，Flink 适配 Kafka 的 connector 利用这个能力实现容错机制。Flink
连接器(Connectors)对容错机制的支持详见：[数据输入源和输出流的容错机制](https://ci.apache.org/projects/flink/flink-docs-master/dev/connectors/guarantees.html)</code></pre>
<h1 id="Checkpointing"><a href="#Checkpointing" class="headerlink" title="Checkpointing"></a><code>Checkpointing</code></h1><p><code>Flink</code> 的 <code>容错机制</code> 简而言之就是持续不断的对 <code>分布式数据流</code> 和 <code>算子状态(Operator state)</code> 产生 <code>一致性</code> 的 <code>快照</code> 数据。这些 <code>快照</code> 数据系统遇到故障时，用于从错误状态中恢复的 <code>检查点</code> (<code>checkpoints</code>)。 <code>Flink</code> 产生 <code>快照</code> 数据的机制的详细描述如下： <a href="http://arxiv.org/abs/1506.08603" title="Lightweight Asynchronous Snapshots for Distributed Dataflows">Lightweight Asynchronous Snapshots for Distributed Dataflows</a>，该算法是在参考 <a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/chandy.pdf" title="Chandy-Lamport algorithm">Chandy-Lamport algorithm</a> 算法的基础上进行改进的，并针对 <code>Flink 执行模型</code> 进行量身定做。</p>
<h2 id="Barriers-栅栏"><a href="#Barriers-栅栏" class="headerlink" title="Barriers (栅栏)"></a><code>Barriers</code> (<code>栅栏</code>)</h2><p><code>Flink</code> 的分布式快照的核心组成部分就是 <code>Barriers(栅栏)</code>，这些 <code>Barriers(栅栏)</code> 被插入到数据流中，和数据一起往下流。<code>Barriers(栅栏)</code> 不会影响数据流中数据的顺序，数据流保证严格有序。<code>Barriers(栅栏)</code> 将数据切分成两部分，前一部分的数据进入当前的快照数据(<code>snapshot</code>)中，后一部分的数据进入下一快照数据。每个 <code>Barriers(栅栏)</code> 都有一个 <code>ID</code>，这个 <code>ID</code> 就是 <code>Barriers(栅栏)</code> 前一个 <code>snapshot</code> 的 <code>ID</code>。<code>Barriers(栅栏)</code> 不会影响数据流的处理，所以非常轻量级。多个不同 <code>快照</code> 的多个 <code>Barriers(栅栏)</code> 可以在数据流中同时存在，即多个 <code>快照</code> 可以同时创建。</p>
<p><strong><em>问题：数据流中的数据也会进入 <code>快照</code> ？？？不应该是只包含状态数据吗？</em></strong></p>
<p><img src="https://segmentfault.com/img/remote/1460000008129555" alt="Barriers" title="Barriers"></p>
<p><code>Barriers(栅栏)</code> 被插入到 <code>数据源</code>的并行数据流中。为快照 <code>n</code> 产生的 <code>Barriers</code> 注入的位置 S<sub>n</sub> 就是在源数据中包含这些快照数据的位置。例如，在 <code>Apache Kafka</code> 中这个位置就是在分区(<code>partition</code>) 中最后一条已消费数据的偏移位置。 这个位置 S<sub>n</sub> 将被上报给检查点协调器(<code>checkpoint coordinator</code>)，也就是 Flink 的 <code>Job Manager</code>。</p>
<p>然后 <code>Barriers(栅栏)</code> 流向下游数据流，当中间的<code>算子(Operator)</code> 从所有的上游输入流都接收到了 <code>快照 n</code> 的 <code>栅栏</code> 之后，向所有下游算子下发 <code>快照 n</code> 的 <code>栅栏</code>。当 <code>输出算子(sink operator)</code> （flink 有向无环图[DAG] 的尾节点）从它的所有上游输入流都接收到了 <code>快照 n</code> 的 <code>栅栏</code> 之后会检查点协调器发起 ACK 确认已接收到 <code>快照 n</code>。当所有的 <code>输出算子(sink operator)</code> 都发出了ACK 确认之后，<code>快照 n</code> 的数据被认为已经被处理完成了。</p>
<p>当 <code>快照 n</code> 已经被确认处理完成了，当前任务不会再向输入流请求获取 <code>快照 n</code> 之前的数据，因此这些数据将已经完成通过真个拓扑数据流。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.7/fig/stream_aligning.svg" title="stream barriers aligning"></p>
<p>接收多个输入流的算子需要在快照的栅栏上对齐输入流，上图描述了如下特性：</p>
<ul>
<li><p>当算子接收到其中一个上游输入流的 <code>快照 n</code> 的栅栏的时候，算子不会处理这个栅栏之后的任何数据，直到它从剩下的所有输入流都接收到 <code>快照 n</code> 的栅栏。否则  <code>快照 n</code> 和  <code>快照 n+1</code> 的数据将被混合在一起。</p>
</li>
<li><p>数据流向检查点协调器报告栅栏的时候会被缓存并搁置，这个数据流的数据不会被处理，而是放置到输入缓存中。</p>
</li>
<li><p>一旦从最后一个流收到了<code>barrier n</code>，这个算子会发送所有积压的记录（个人注：将barrier之前的数据都发送出去），然后发送快照n的barrier。</p>
</li>
<li><p>然后，它继续处理从所有输入流中的数据，先处理输入缓存中的数据，然后处理流中的数据。</p>
</li>
</ul>
<h2 id="状态-State"><a href="#状态-State" class="headerlink" title="状态 State"></a>状态 <code>State</code></h2><p>如果一个算子包含<code>状态</code>，那这个<code>状态</code>数据一定是 <code>快照</code> 的一部分，算子状态有不停的形式：</p>
<ul>
<li><p><code>自定义状态</code>：通过转化函数（如 <code>map()</code> 或 <code>filter()</code>）来创建和修改状态数据，详见 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/stream/state/index.html" title="State in Streaming Applications">State in Streaming Applications</a></p>
</li>
<li><p><code>系统状态</code>：这种状态时指的是算子计算过程中的一部分缓存数据。典型的例子就是 <code>窗口缓存</code>，系统收集窗口对应的数据到缓存，直到窗口计算或者发射。</p>
</li>
</ul>
<p>算子在接收到所有上游输入流的栅栏之后，在向所有输出流发射栅栏之前对状态数据进行快照。此时栅栏之前的数据对状态的更改已经生效，并且栅栏之后的数据对状态的修改不会发生。由于快照的状态的数据可能会比较大，它可以存储到一个可配置的状态后端存储系统中。默认状态下，状态数据存储在 <code>JobManager</code> 的内存中，但是在生产环境还是需要配置成一个 <code>可靠</code> 的分布式存储系统（例如 <code>HDFS</code>）. 状态被存储之后，算子会确认其检查点完成，将 <code>快照</code> 的 <code>栅栏</code> 的数据发送给下游。</p>
<p>现在我们可以看一下 <code>快照</code> 中包含的数据。</p>
<ul>
<li>对于并行的输入数据源，快照建立时数据流的偏移位置。</li>
<li>对于算子，快照包含了一个指向装填实际存储位置的指针。</li>
</ul>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.7/fig/checkpointing.svg" title="checkpointing"></p>
<h2 id="Exactly-Once-vs-At-Least-Once-只响应一次还是还是至少响应一次"><a href="#Exactly-Once-vs-At-Least-Once-只响应一次还是还是至少响应一次" class="headerlink" title="Exactly Once vs. At Least Once 只响应一次还是还是至少响应一次"></a>Exactly Once vs. At Least Once 只响应一次还是还是至少响应一次</h2><p>对齐操作可能会增大数据流应用的延时，一般来说，对齐产生的额外延时只有几毫秒的数量级，但是我们也发现过延迟显著增加的异常情况。对于要求延时非常低（几毫秒）的数据流应用，flink 提供在产生检查点的时候关闭对齐的开关。如果关闭对齐步骤，算子会在接收到一个上游的栅栏的时候就会产生一个快照，而不是等到其他上游的栅栏都到齐了再来生成快照。</p>
<p>当对齐被关闭的时候，算子在收到栅栏的时候也会持续的处理输入数据。也就是说：算子在会在产生 <code>检查点 n</code> 的时候，会处理属于 <code>检查点 n+1</code> 的数据。所以当故障恢复的时候，这部分数据会被重复处理，因为这些数据都属于 <code>检查点 n</code> 的快照数据，同时在 <code>检查点 n</code> 之后也会被回放而被再次处理。</p>
<pre><code>            注意：
            对齐操作只会发生在多输入运算（join）或者多输出的算子（例如重分区，分流）的场景下。
            因此，对于普通的并行数据流操作（`map()`, `flatMap()`, fliter() 等），
            及时在 `至少响应一次（at least once）` 的模式下，也会保证 `只响应一次（exactly once）`</code></pre>
<h2 id="Asynchronous-State-Snapshots-异步状态快照"><a href="#Asynchronous-State-Snapshots-异步状态快照" class="headerlink" title="Asynchronous State Snapshots 异步状态快照"></a>Asynchronous State Snapshots 异步状态快照</h2><p>上面所述的机制表明算子在存储快照数据到后端存储系统的时候会停止处理输入数据，这种同步产生状态快照的模式每次产生的快照的时候都会引入额外的延时。</p>
<p>我们完全可以让算子在快照数据的同时继续处理输入数据，让快照的存储在后台异步进行。为了做到异步状态快照，算子必须能保证产生一个状态数据对象被存储之后，后续对状态的修改不会影响这个状态数据对象。例如 <code>RocksDB</code> 中使用的 <code>写时复制（ copy-on-write ）</code> 类型的数据结构。</p>
<p>接收到输入数据的栅栏的时候，算子开始异步的快照复制出它的状态。算子立即向输出发射栅栏，并继续处理输入数据。当后台异步快照完成时，算子会向 <code>检查点协调器</code>（<code>checkpoints coordinator</code>, 也就是 <code>Job Manager</code>）确认检查点完成，现在检查点完成的充分条件是：所有的 <code>输出算子（sink）</code> 都接收到了栅栏，而且所有有状态的算子确认完成了状态数据的备份（这个确认操作可能会晚于栅栏到达 <code>输出算子（sink）</code>）。</p>
<p>详细的状态快照见： <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/ops/state/state_backends.html" title="State Backends">State Backends</a></p>
<h2 id="故障恢复-Recovery"><a href="#故障恢复-Recovery" class="headerlink" title="故障恢复(Recovery)"></a><code>故障恢复(Recovery)</code></h2><p>这种机制下的故障恢复就很简单：当发生故障的时候，<code>Flink</code> 选择最新完成的<code>检查点 k</code>。然后系统重新部署整个分布式数据流，给所有的算子提供快照在检查点中的状态数据用于恢复。输入流的读取位置被设置到从 S<sub>k</sub> 开始读取，对于 <code>Apache Kafka</code> 来说就是通知 <code>consumer</code> 从偏移位置 S<sub>k</sub> 开始消费消息。</p>
<h2 id="算子快照的实现"><a href="#算子快照的实现" class="headerlink" title="算子快照的实现"></a>算子快照的实现</h2><p>算子产生快照的过程分为两个部分：<code>同步部分</code> 和 <code>异步部分</code>。</p>
<p>算子和状态后端存储系统(<code>State Backends</code>) 提供 <code>Java FutureTask</code> 用于快照。这个任务包含同步部分已经完成，异步部分还在等待的状态，检查点的异步部分在后台线程中被执行。</p>
<p>完成同步的算子仅仅返回一个已经完成的 <code>FutureTask</code>。如果需要异步执行，<code>FutureTask</code> 中的 <code>run()</code> 方法将被会调用。</p>
<p>这些 <code>FutureTask</code> 是可以取消的，这样就可以释放流和其他资源的消耗。</p>
<h1 id="比较一下-Checkpoint-和-Savepoint"><a href="#比较一下-Checkpoint-和-Savepoint" class="headerlink" title="比较一下 Checkpoint 和 Savepoint"></a>比较一下 <code>Checkpoint</code> 和 <code>Savepoint</code></h1><p><code>Checkpoint</code> 和 <code>Savepoint</code> 都是 flink 提供的容错恢复机制，两个不管是命名还是使用方式都很类似，这里分别对两个进行一个简单的介绍并且对二者进行对比。</p>
<h2 id="保存点-Savepoint"><a href="#保存点-Savepoint" class="headerlink" title="保存点(Savepoint)"></a><code>保存点(Savepoint)</code></h2><p>保存点是通过 <code>Flink</code> 的 <code>检查点机制(checkpointing mechanism)</code> 创建的，包含数据流任务的运行状态的一个一致性的快照数据。你可以用保存点去停止并重启任务、复制任务或者更新任务。</p>
<p>保存点由两个部分组成</p>
<ol>
<li>存储在一个稳定的存储介质（<code>HDFS</code>、<code>S3</code>等）上的，一般来说比较大的包含二进制文件的文件夹。这些二进制文件纯粹的保存任务的运行状态的快照数据。</li>
<li>一个元数据文件（一般来说比较小），文件中保存了指向存储在稳定存储介质上的保存点的所有文件的指针（文件路径）。</li>
</ol>
<h2 id="算子命名的重要性"><a href="#算子命名的重要性" class="headerlink" title="算子命名的重要性"></a>算子命名的重要性</h2><p>保存点中维护了一个 map 格式的数据</p>
<pre><code>            Operator ID | State
            ------------+------------------------
            source-id   | State of StatefulSource
            mapper-id   | State of StatefulMapper</code></pre>
<p>通过算子的ID 能够获取到起对应的状态数据，在新增、删除算子或者修改算子的顺序的时候如果没有自定义命名，而是使用 flink 的默认命名方式，算子的数量和顺序的改变会影响重新启动的算子的ID，可能会导致算子ID 的状态数据匹配错误。强烈建议给每个算子设置一个  <code>ID</code>。</p>
<h2 id="从保存点重启任务的时候算子修改会有什么结果"><a href="#从保存点重启任务的时候算子修改会有什么结果" class="headerlink" title="从保存点重启任务的时候算子修改会有什么结果?"></a>从保存点重启任务的时候算子修改会有什么结果?</h2><h3 id="新增一个有状态的节点"><a href="#新增一个有状态的节点" class="headerlink" title="新增一个有状态的节点"></a>新增一个有状态的节点</h3><p>When you add a new operator to your job it will be initialized without any state. Savepoints contain the state of each stateful operator. Stateless operators are simply not part of the savepoint. The new operator behaves similar to a stateless operator.</p>
<p>新增的有状态的算子在重启的时候变现的和无状态的算子一样，因为保存点中没有这个算子对应的装填数据。</p>
<h3 id="删除一个有状态的节点"><a href="#删除一个有状态的节点" class="headerlink" title="删除一个有状态的节点"></a>删除一个有状态的节点</h3><p>默认情况下删除一个有状态的节点会导致重启失败，因为这个过程默认需要确保所有状态数据都要对应一个算子。如果你真的需要删除一个状态的节点，你需要在启动参数中加上参数 <code>--allowNonRestoredState (short: -n)</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bin/flink run -s :savepointPath -n [:runArgs]</span><br></pre></td></tr></table></figure>

<h3 id="重新排序有状态的节点-amp-amp-删除或者重新排序无状态的节点"><a href="#重新排序有状态的节点-amp-amp-删除或者重新排序无状态的节点" class="headerlink" title="重新排序有状态的节点 &amp;&amp; 删除或者重新排序无状态的节点"></a>重新排序有状态的节点 &amp;&amp; 删除或者重新排序无状态的节点</h3><p>算子指定ID 的情况下没问题，否则可能会导致状态数据匹配错误而重启失败</p>
<h3 id="修改算子的并行度"><a href="#修改算子的并行度" class="headerlink" title="修改算子的并行度"></a>修改算子的并行度</h3><p><code>flink 1.2</code> 以上版本并且没有使用任何 <code>State</code> 相关的 <code>过时API</code> 没有问题。<br>如果保存点是在 <code>flink 1.2</code> 以下版本或者使用了 <code>State</code> 相关的 <code>过时API</code> 的代码中生成的，你需要升级 flink 版本并且替换 <code>State</code> 相关的 <code>过时API</code>，详见 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/ops/upgrading.html" title="upgrading jobs and Flink versions guide.">upgrading jobs and Flink versions guide</a></p>
<h2 id="保存点-Savepoint-和-检查点-Checkpoint-的区别"><a href="#保存点-Savepoint-和-检查点-Checkpoint-的区别" class="headerlink" title="保存点(Savepoint) 和 检查点(Checkpoint) 的区别"></a><code>保存点(Savepoint)</code> 和 <code>检查点(Checkpoint)</code> 的区别</h2><p>从在概念上说，<code>保存点(Savepoint)</code> 和 <code>检查点(Checkpoint)</code> 的不同比较像备份不同于传统数据库从日志恢复。</p>
<p>下面是他们的不同点：</p>
<table>
<thead>
<tr>
<th></th>
<th>检查点</th>
<th>保存点</th>
</tr>
</thead>
<tbody><tr>
<td>目的</td>
<td>为出现异常情况 Flink 任务提供一个恢复机制确保任务能从部分故障中恢复</td>
<td>用户手动维护任务的时候触发应用重启等操作</td>
</tr>
<tr>
<td>设计要求</td>
<td>作为一个用于恢复的，被周期调用的方法，它的实现要求:<br/> 1. 创建过程很轻量级 <br/> 2. 可以快速的从检查点恢复故障</td>
<td>保存点的设计要求更着重于备份数据的便携性，而不是很关注创建过程的轻量级和快速恢复。</td>
</tr>
<tr>
<td>生命周期</td>
<td>flink 直接管理检查点的生命周期，从创建到释放都不需要维护人用手动触发</td>
<td>维护人员手动触发保存点的创建和删除，所有者是维护人员。</td>
</tr>
<tr>
<td>删除</td>
<td>用户停止任务之后被删除（除非编码或配置声明保留）</td>
<td>维护人员手动删除</td>
</tr>
<tr>
<td>具体实现</td>
<td>虽然目前保存点和检查点的代码实现和产生的文件格式都是一样的，但是使用 RocksDB 的检查点使用的保存格式不是flink 定义的，而是 RocksDB 自定义的格式，而且 RocksDB 的检查点支持增量检查点<br/><span style='color:red'>不支持 rescaling </span></td>
<td>不支持增量，支持 rescaling</td>
</tr>
</tbody></table>
<p><strong>* rescaling 的翻译存疑，猜测是改变并行度*</strong></p>
<h6 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h6><p>本人对文档的翻译过程中，对Flink 相关名词翻译如下：</p>
<table>
<thead>
<tr>
<th>英文名词</th>
<th>译者翻译</th>
</tr>
</thead>
<tbody><tr>
<td>Connector</td>
<td>连接器</td>
</tr>
<tr>
<td>Data Sources</td>
<td>数据输入源</td>
</tr>
<tr>
<td>Data Sinks</td>
<td>数据输出流</td>
</tr>
<tr>
<td>rescaling</td>
<td>-</td>
</tr>
</tbody></table>
<h6 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h6><p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/internals/stream_checkpointing.html">https://ci.apache.org/projects/flink/flink-docs-release-1.7/internals/stream_checkpointing.html</a><br/><br><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/ops/state/checkpoints.html">https://ci.apache.org/projects/flink/flink-docs-release-1.7/ops/state/checkpoints.html</a><br/><br><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/ops/state/savepoints.html">https://ci.apache.org/projects/flink/flink-docs-release-1.7/ops/state/savepoints.html</a><br/></p>
<p>本人 flink 小白萌新一枚，如有错漏之处，敬请斧正！</p>
]]></content>
      <categories>
        <category>flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 基础学习笔记（-）———— 基本语法</title>
    <url>/2018/03/01/%E6%8A%80%E6%9C%AF/golang/2018-03-01-golang%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Go-基础语法"><a href="#Go-基础语法" class="headerlink" title="Go 基础语法"></a>Go 基础语法</h2><h3 id="Go-程序的基本构成"><a href="#Go-程序的基本构成" class="headerlink" title="Go 程序的基本构成"></a>Go 程序的基本构成</h3><h4 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 程序的基本构成，每个程序都有自己所在的 <code>package</code>,  <code>包</code>这个概念类似于其他编程语言的<code>命名空间</code> 或者 <code>库名</code>, 一般用一个简单的单词，与其他功能区分开即可, 命名规范要求全小写，或者<code>&#39;_&#39;</code>连接的多个单词</p>
<p>Go 程序是通过 <code>import</code> 关键字将一组包链接在一起。<br><code>import &quot;fmt&quot;</code> 表示该程序需要使用 <code>package fmt</code>（函数或者其他元素），其中 “fmt” 是一个包名</p>
<p>格式是</p>
<ul>
<li>import “package_name”</li>
<li>import<br>(<br><br>  “package_name”<br><br>)</li>
</ul>
<h4 id="function"><a href="#function" class="headerlink" title="function"></a>function</h4><p>Go 程序的重要组成部分是函数，格式是 <code>func 函数名(参数列表) (返回值列表) &#123;&#125;</code></p>
<h4 id="main-main"><a href="#main-main" class="headerlink" title="main.main"></a>main.main</h4><p>Go 程序的入口是 <code>main.main</code> 方法, 第一个<code>main</code>是该程序的 <code>package</code>; 第二个 <code>main</code> 是该程序的 <code>main</code> 函数，<code>main</code> 函数要求没有参数列表和返回值列表。</p>
<h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><h4 id="int"><a href="#int" class="headerlink" title="int"></a>int</h4><p>包含int8, int16, int32, int64，分别8bit, 16bit, 32bit, 64bit的有符号整数，而int类型占的bit数决定于编译环境所在平台的位数，如果是32位环境则是32bit，如果是64位环境则是64bit。<br>除了有符号数之外还要无符号数，Go 语言中，无符号型整数有 uint8, uint16, uint32, unit64， int8 的取值范围是 [-128<del>127], 而uint8的取值范围是 [0</del>255], 其他有符号型和无符号型整数的取值范围和这个类型类似。</p>
<h4 id="byte"><a href="#byte" class="headerlink" title="byte"></a>byte</h4><pre><code>            byte is an alias for uint8 and is equivalent to uint8 in all ways. It is used, by convention, to distinguish byte values from 8-bit unsigned integer values.</code></pre>
<p>byte 是 <code>uint8</code> 的别名（alias）， 或者说完全等同于 <code>uint8</code>。按照惯例用于区分8bit无符号数和byte 类型数据</p>
<h4 id="rune"><a href="#rune" class="headerlink" title="rune"></a>rune</h4><pre><code>            rune is an alias for int32 and is equivalent to int32 in all ways. It is used, by convention, to distinguish character values from integer values.
            rune 是 `int32` 类型的别名, 或者说完全等同于 `int32`. 按照惯例用于区分字符类型和整数类型</code></pre>
<p><code>rune</code> 用数字表示字符的 <code>ASCII</code>编码</p>
<h4 id="float"><a href="#float" class="headerlink" title="float"></a>float</h4><p>浮点类数据类型包含<code>float32</code>和<code>float64</code>, Go 语言基于 <code>IEEE 754标准</code>实现的浮点类型数据，具体参见另一篇文章<a href="http://baidu.com/">浮点数</a></p>
<h4 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h4><p>布尔类型数据，取值有 true 和 false</p>
<h4 id="complex"><a href="#complex" class="headerlink" title="complex"></a>complex</h4><p>复数，有对应<code>float32</code> 和 <code>float64</code> 两个精度的数据类型 <code>complex64</code> 和 <code>complex128</code>,<br><code>complex(1, 2)`` 等同于  </code>1 + 2i`</p>
<h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>字符串类型，底层实现是byte 类型的 slice，不可变（immutable）</p>
<h4 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="literal">iota</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><code>iota</code> 是无类型的int 类型的常量计数器，在const关键字出现时配置为0，从0开始，const 中每增加一行iota 自增一次（+1）</p>
<p><code>iota</code> 的使用示例如下, 在 <code>const</code> 关键字修饰的括号中， <code>iota</code> 首先被重置成0， 然后 a = 0, b = 1, c = 2</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">  b        <span class="comment">// 1</span></span><br><span class="line">    c        <span class="comment">// 2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>从上面的特性来看，我们可以使用 <code>iota</code> 来定义一个简单的<code>枚举</code>，来个小例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type chargeType int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    CPC  chargeType &#x3D; iota &#x2F;&#x2F; 0</span><br><span class="line">    CPM                    &#x2F;&#x2F; 1</span><br><span class="line">    CPT                    &#x2F;&#x2F; 2</span><br><span class="line">    CPD                    &#x2F;&#x2F; 3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>设想你在处理消费者的音频输出。音频可能无论什么都没有任何输出，或者它可能是单声道，立体声，或是环绕立体声的。<br>这可能有些潜在的逻辑定义没有任何输出为 0，单声道为 1，立体声为 2，值是由通道的数量提供。<br>所以你给 Dolby 5.1 环绕立体声什么值。<br>一方面，它有6个通道输出，但是另一方面，仅仅 5 个通道是全带宽通道（因此 5.1 称号 - 其中 .1 表示的是低频效果通道）。<br>不管怎样，我们不想简单的增加到 3。<br>我们可以使用下划线跳过不想要的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type AudioOutput int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    none  AudioOutput &#x3D; iota &#x2F;&#x2F; 0</span><br><span class="line">    mone                    &#x2F;&#x2F; 1</span><br><span class="line">    stereo                  &#x2F;&#x2F; 2</span><br><span class="line">    _</span><br><span class="line">    _</span><br><span class="line">    Dolby                   &#x2F;&#x2F; 5</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><h4 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h4><p>基础用法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> condition &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> condition1 &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition2 &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>关键字 if 和 else 之后的左大括号 { 必须和关键字在同一行，如果你使用了 else-if 结构，则前段代码块的右大括号 } 必须和 else-if 关键字在同一行。这两条规则都是被编译器强制规定的。</em></p>
<p>除了上述情况之外还有如下使用方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> initialization; condition &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Example:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> i := getValue(); i &gt; <span class="number">10</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><ol>
<li>常见用法</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count; i++ &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>go 中没有while 循环，用for 循环代替</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i &lt; <span class="number">100</span> &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>无限循环，没有 condition</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> index := <span class="number">0</span>; ; index ++ &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>for range</code></li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> idx, element := <span class="keyword">range</span> intArr &#123; <span class="comment">// idx 是数组下表，element 是数组下标所在元素</span></span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> idx := <span class="keyword">range</span> intArr &#123; <span class="comment">// idx 是数组下表</span></span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>注意：<code>for a := range arr</code> 这种遍历的时候 a 是数组下标</em></p>
<p>或</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> map1 &#123; <span class="comment">// Key map 中的key value 是map 中的值</span></span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="5">
<li><code>break</code> 和 <code>continue</code></li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> idx := <span class="number">0</span> ;; idx ++ &#123;</span><br><span class="line">    <span class="keyword">if</span> idx &gt; <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 退出当前for 循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> idx := <span class="number">0</span> ;; idx ++ &#123;</span><br><span class="line">    <span class="keyword">if</span> (idx % <span class="number">2</span>) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// 进入下一个循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h4><p>相比其他语言来说go 语言的 <code>switch case</code> 更强大，它支持各种形式的表达式，而且匹配上一个 <code>case</code> 执行完分支代码后，程序会自动switch代码块，不需要使用 <code>break</code> 标明结束</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line"><span class="keyword">case</span> val1:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line"><span class="keyword">case</span> val2:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line"><span class="keyword">default</span>:  <span class="comment">// 不符合之前所有已给出条件的时候走到这里，建议写到最后</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子中<code>var1</code> 可以是<code>任何类型</code>， 而 <code>val1</code> 和 <code>val2</code> 是同类型的任意值</p>
<p>多个case 合并</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>:</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fallthrough</code></p>
<p>当执行完一个 <code>case</code> 分支后还想继续执行下一个 <code>case</code> 分支，可以使用关键字 <code>fallthrough</code></p>
<p>example：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">2</span></span><br><span class="line">    <span class="keyword">switch</span> i &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Value 1 or 0, val:%v \n&quot;</span>, i)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Value 2, val:%v \n&quot;</span>, i)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Value 3, val:%v \n&quot;</span>, i)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Value default, val:%v \n&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">``</span></span><br><span class="line">上面程序的输出结果是：</span><br><span class="line"></span><br><span class="line">                Value <span class="number">2</span>, val:<span class="number">2</span></span><br><span class="line">                Value <span class="number">3</span>, val:<span class="number">2</span></span><br><span class="line"></span><br><span class="line">                Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br><span class="line">#### array 数组</span><br><span class="line">数组是固定长度的同一类型元素组成的序列，可以通过数组下标访问来访问元素，下标从<span class="number">0</span>开始</span><br><span class="line"></span><br><span class="line">数组的长度是数组类型的一个组成部分，因此[<span class="number">3</span>]<span class="keyword">int</span>和[<span class="number">4</span>]<span class="keyword">int</span>是两种不同的数组类型，数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">golang 提供内建函数 <span class="string">`append(arr []Type, element... Type)`</span> 用于往数组中添加元素，也可用于 <span class="string">`slice`</span></span><br><span class="line">数组相关的<span class="string">`内建函数`</span> 还有 <span class="string">`len()`</span> 和 <span class="string">`cap()`</span>, 对于数组而言 <span class="string">`len()`</span> 和 <span class="string">`cap()`</span> 是一样的</span><br><span class="line"></span><br><span class="line"><span class="string">`len()`</span> 函数的参数也可以是 <span class="literal">nil</span>, _len(<span class="literal">nil</span>) == <span class="number">0</span>_</span><br><span class="line"></span><br><span class="line">数组的声明格式是</span><br><span class="line"><span class="string">``</span><span class="string">`go</span></span><br><span class="line"><span class="string">var arr [length]Type</span></span><br></pre></td></tr></table></figure>
<p>刚声明的数组长度是 length，每个元素都是零值（数字是0， 字符串是’’，引用类型是nil）<br>也可以使用 <code>make</code> 定义一个数组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">make</span>([]Type, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure>

<p>还可以在定义的是时候设定初始值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>]<span class="keyword">int64</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>或者设定指定下标的元素</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>]<span class="keyword">int64</span>&#123;<span class="number">2</span>:<span class="number">1000</span>&#125;  <span class="comment">// arr := []int64&#123;0, 0, 1000&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果数组元素本身可以比较的，那么数组也是可以用 <code>==</code> 比较的，反则会编译失败</p>
<h4 id="slice（切片）"><a href="#slice（切片）" class="headerlink" title="slice（切片）"></a>slice（切片）</h4><p><code>slice(切片)</code> 是对数组的一个连续片段的使用</p>
<p>切片也是可索引的，也可以使用 <code>len()</code> 函数的来获取长度<br>切片除了长度之外，还有一个属性是容量， 通过内建函数 <code>cap()</code> 函数来获取容量，容量的含义是切片开始位置到底层数组结束位置的数组长度<br>例如切片 s 是数组 a 的一部分，s = a[3:], 那么 <em>cap[s] = len(a) - 3</em><br>对于切片来说，始终需要保证 <code>0 &lt;= len(s) &lt;= cap(s)</code>， 如果 <em>len(s) &gt; cap(s)</em> 就会出现<code>越界异常</code></p>
<p>从上面这段文字总结出 <code>slice</code> 的组成元素是：</p>
<ol>
<li>指针（指向底层数组中切片的第一个元素）</li>
<li>长度</li>
<li>容量</li>
</ol>
<p>下图描述了切片的构成<br><img src="/assets/picture/slice.png" alt="图片" title="slice 构成"></p>
<p>slice 的初始化方式是</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 [...]Type    <span class="comment">// 不需要指明长度，编译器会自动构建一个长度合适的底层数组</span></span><br><span class="line"><span class="keyword">var</span> slice2 []Type       <span class="comment">// _..._可以不写</span></span><br><span class="line"><span class="keyword">var</span> arr [length]Type    <span class="comment">// 声明一个数组</span></span><br><span class="line">slice3 := arr[start:end] <span class="comment">// 声明一个由数组中 [start, end) 元素组成的切片</span></span><br><span class="line">slice4 := arr[start:]    <span class="comment">// end 可以省略不写，表示 end = len(arr)声明一个由数组中 [start, len(arr)) 元素组成的切片</span></span><br><span class="line">slice5 := arr[:end]      <span class="comment">// start 可以省略不写，表示 start = 0 声明一个由数组中 [0, end) 元素组成的切片</span></span><br><span class="line">slice6 := <span class="built_in">make</span>([]Type, <span class="built_in">len</span>, <span class="built_in">cap</span>)  <span class="comment">// 声明一个具体类型，长度是len，容量是cap 的切片， make 关键字适用于 array, slice, map, channel 的内存分配</span></span><br><span class="line">slice7 := <span class="built_in">new</span>([]Type)  <span class="comment">// 也可以用 new 关键词定义一个 len == cap == 0 的slice，但是返回一个指向类型为 T，值为 0 的地址的指针，它适用于值类型如数组和结构体；它相当于 &amp;T&#123;&#125;。强烈建议不要使用 new 关键字声明 slice</span></span><br></pre></td></tr></table></figure>

<p>由于<code>slice</code> 是共享的底层数组，当一个slice 改变了底层数组的时候，和它共享底层数组的其他<code>slice</code> 也会受影响</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> arr [<span class="number">6</span>]<span class="keyword">int64</span></span><br><span class="line">    <span class="keyword">for</span> idx := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        arr[idx] = <span class="keyword">int64</span>(idx + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;The underlying array:%v \n&quot;</span>, arr)</span><br><span class="line"></span><br><span class="line">    s := arr[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">    fmt.Printf(<span class="string">&quot;The slice:%v, length:%v, capacity:%v \n&quot;</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line"></span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;The underlying array after set value for slice :%v \n&quot;</span>, arr)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;The slice after set value:%v \n&quot;</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<pre><code>            The underlying array:[1 2 3 4 5 6 7 8 9 10]
            The slice 1:[4 5 6 7 8 9 10], length:7, capacity:7
            The slice 2:[5 6 7 8 9 10], length:6, capacity:6
            The underlying array after set value for slice :[1 2 3 4 5 1000 7 8 9 10]
            The slice 1 after set value:[4 5 1000 7 8 9 10]
            The slice 2 after set value:[5 1000 7 8 9 10]</code></pre>
<p>如果不想共享底层数据，可以使用内建的 <code>copy(resourceSlice, targetSlice)</code>函数 从原数组或者切片中拷贝一个新的切片，然后对新的切片的操作就不会因为共享底层数组影响其他切片了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个集合中排除掉第二个集合后的结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Subtract</span><span class="params">(c1 []<span class="keyword">interface</span>&#123;&#125;, c2 []<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(subtraction []<span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">    subtraction = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(c1))</span><br><span class="line">    <span class="built_in">copy</span>(subtraction, c1) <span class="comment">// copy c1 to subtraction</span></span><br><span class="line">    subtraction = c1[:]</span><br><span class="line">    <span class="keyword">for</span> _, elem2 := <span class="keyword">range</span> c2 &#123;</span><br><span class="line">        <span class="keyword">for</span> idx, elem1 := <span class="keyword">range</span> subtraction &#123;</span><br><span class="line">            <span class="keyword">if</span> elem2 == elem1 &#123;</span><br><span class="line">                subtraction = <span class="built_in">append</span>(subtraction[:idx], subtraction[idx+<span class="number">1</span>:]...)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在从数组或切片中生成新的切片的时候还可以指定新切片的容量<br>语法是</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">newSlice := arr[start:end:<span class="built_in">cap</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSliceCap</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="keyword">int32</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">    s1 := a[<span class="number">2</span>:]</span><br><span class="line">    fmt.Printf(<span class="string">&quot;a: %v, s1: %v\n&quot;</span>, a, s1)</span><br><span class="line"></span><br><span class="line">    s2 := a[<span class="number">0</span>:<span class="number">2</span>:<span class="number">2</span>]</span><br><span class="line">    fmt.Printf(<span class="string">&quot;a: %v, s2: %v\n&quot;</span>, a, s2)</span><br><span class="line">    s2 = <span class="built_in">append</span>(s2, <span class="number">100</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;a: %v, s1: %v, s2: %v\n&quot;</span>, a, s1, s2)</span><br><span class="line"></span><br><span class="line">    s3 := a[:<span class="number">2</span>:<span class="number">2</span>]</span><br><span class="line">    s3 = <span class="built_in">append</span>(s3, <span class="number">101</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;a: %v, s1: %v, s2: %v, s3:%v\n&quot;</span>, a, s1, s2, s3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<pre><code>            a: [1 2 3 4], s1: [3 4]
            a: [1 2 3 4], s2: [1 2]
            a: [1 2 3 4], s1: [3 4], s2: [1 2 100]
            a: [1 2 3 4], s1: [3 4], s2: [1 2 100], s3:[1 2 101]</code></pre>
<p>从上面的例子可以看到，限定了切片的容量之后，从同一数据产生的切片的</p>
<p><code>slice</code> 的基本操作和数组一致<br><code>slice</code> 不可以用 <code>==</code> 比较的， bytes 提供了 []byte 的比较方法, strings 提供了 []string 的比较方法</p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>一个<code>无序</code>的K/V集合，其中所有的key 都是唯一的，在 <code>go</code> 中<code>map</code> 中的 <code>key</code> 必须是可比较的（支持 <code>==</code> 比较运算符）的数据类型, 所以 <code>key</code> 不能是 <code>map</code>、<code>slice</code> 或者 <code>func</code>, 而对于value 值没有任何要求</p>
<p>map 的定义和初始化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mapDemo <span class="keyword">map</span>[Key]Value</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[Key]Value, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure>

<p><code>map</code> 的 <code>key</code> 是完全无序的， 使用 <code>for</code> 循环遍历map 的时候每次的顺序都是随机的</p>
<p>判断 <code>map</code> m1 中是否包含 k1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m1 = <span class="built_in">make</span>(<span class="keyword">map</span>[Key][Value])</span><br><span class="line">val1, contains := m1[k1]</span><br><span class="line"><span class="keyword">if</span> contains &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;the map m1 contains k1!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>注意：对于 <code>slice</code> 可以直接往为 <code>nil</code> 的 <code>slice</code> 中存放数据，但是map 必须先使用 <code>make</code> 分配内存</em></p>
<h4 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体(struct)"></a>结构体(struct)</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个结构体</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    id <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体的 String 函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;name: %v, Id: %v&quot;</span>, s.Name, s.id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个结构体</span></span><br><span class="line"><span class="keyword">var</span> s Student</span><br><span class="line"><span class="comment">// 访问结构体的数据</span></span><br><span class="line">s.Name = <span class="string">&quot;test&quot;</span></span><br></pre></td></tr></table></figure>

<p>结构体还可以组合, 下面我们尝试定义两个结构体，<code>Circle</code> 和 <code>Rectangle</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    x, y, r <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    x, y, <span class="built_in">len</span>, width <span class="keyword">int64</span> <span class="comment">// x,y 是左下角的点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>Rectangle</code> 和 <code>Circle</code> 都具有点的属性，可以提取出一个结构体 <code>Point</code><br>下面的代码中我们定义了三个结构体，分别是 <code>Point</code>、<code>Circle</code>、<code>Rectangle</code>， 其中<code>Circle</code> 和 <code>Rectangle</code> 中都组合了一个 <code>Point</code>, 这是访问属性的时候就需要先访问被组合的结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    x, y <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    c Point <span class="comment">// 原点</span></span><br><span class="line">    r <span class="keyword">int64</span> <span class="comment">// 半径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    p          Point <span class="comment">// 左下角的点</span></span><br><span class="line">    <span class="built_in">len</span>, width <span class="keyword">int64</span> <span class="comment">// 长和宽</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c1 := Circle&#123;c: Point&#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;, r: <span class="number">2</span>&#125;</span><br><span class="line">    fmt.Println(c1)</span><br><span class="line"></span><br><span class="line">    c2 := Circle&#123;&#125;</span><br><span class="line">    c2.c.x = <span class="number">0</span></span><br><span class="line">    c2.c.y = <span class="number">0</span></span><br><span class="line">    c2.r = <span class="number">3</span></span><br><span class="line">    fmt.Println(c2)</span><br><span class="line"></span><br><span class="line">    r1 := Rectangle&#123;p: Point&#123;x:<span class="number">0</span>, y:<span class="number">0</span>&#125;, <span class="built_in">len</span>:<span class="number">4</span>, width:<span class="number">3</span>&#125;</span><br><span class="line">    fmt.Println(r1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>go还支持在结构体中只声明属性的数据类型，而不只限定属性的名称, 这就是匿名成员，从下面的 代码中也能看到，匿名成员也不是没有名字，而是直接把数据类型作为了成员的名字</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    x <span class="keyword">int64</span></span><br><span class="line">    y <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    Point   <span class="comment">// 原点</span></span><br><span class="line">    r <span class="keyword">int64</span> <span class="comment">// 半径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    Point            <span class="comment">// 左下角的点</span></span><br><span class="line">    <span class="built_in">len</span>, width <span class="keyword">int64</span> <span class="comment">// 长和宽</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c1 := Circle&#123;Point: Point&#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;, r: <span class="number">2</span>&#125;</span><br><span class="line">    fmt.Println(c1)</span><br><span class="line"></span><br><span class="line">    c2 := Circle&#123;&#125;</span><br><span class="line">    c2.Point.x = <span class="number">0</span></span><br><span class="line">    c2.Point.y = <span class="number">0</span></span><br><span class="line">    c2.r = <span class="number">3</span></span><br><span class="line">    fmt.Println(c2)</span><br><span class="line"></span><br><span class="line">    r1 := Rectangle&#123;Point: Point&#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;, <span class="built_in">len</span>: <span class="number">4</span>, width: <span class="number">3</span>&#125;</span><br><span class="line">    fmt.Println(r1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>结构体是多个类型数据聚合的数据类型， 可以包含任何类型的属性，结构体的访问权限通过大小写来控制，只有大写开头的属性和结构体具有包外可见性，使用json序列化和反序列化数组的时候，小写开头的属性会被忽略。</p>
<p>结构体的比较取决于结构体的属性，当结构体的所有属性都是可比较的时候，结构体就是可比较的，当使用 <code>==</code> 比较两个结构体的示例的时候，这就是。针对包含不可比较的结构体，也可以使用<code>反射</code>的 <code>reflect.DeepEqual()</code></p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(param1 Type, param2 Type)</span> <span class="params">(result1 Type, result2 Type)</span></span> &#123;</span><br><span class="line">    <span class="comment">// method body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的例子中，我们可以看到go 函数的一个显著特点：<code>多返回值</code>，<br>有时候一个方法的结果除了正常的结果外，还有不可预期的异常，这个时候就可以返回多个返回值，比如 <code>encode/json</code> 中的序列化的方法，正常情况下返回序列化的结果，而如果输入的参数无法序列化的时候则返回nil 和异常</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">    e := &amp;encodeState&#123;&#125;</span><br><span class="line">    err := e.marshal(v, encOpts&#123;escapeHTML: <span class="literal">true</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e.Bytes(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们在返回值列表中写明变量名，就可以在return 语句中省略操作数， 上面的方法就可以改写成下面这种</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(res []<span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line">    e := &amp;encodeState&#123;&#125;</span><br><span class="line">    err = e.marshal(v, encOpts&#123;escapeHTML: <span class="literal">true</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment">// 等同于 return nil, err</span></span><br><span class="line">    &#125;</span><br><span class="line">    res = e.Bytes()</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// 等同于 return e.Bytes(), nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="method-is-first-class-value"><a href="#method-is-first-class-value" class="headerlink" title="method is first-class value"></a>method is <code>first-class value</code></h5><p>在 go 语言中函数也是 <code>first-class value</code>， <code>first-class value</code> 的定义如下：</p>
<ul>
<li>可以作为变量或者数据结构存储</li>
<li>可以作为参数传递给方法/函数</li>
<li>可以作为返回值从函数/方法返回</li>
<li>可以在运行期创建</li>
<li>有固有身份；“固有身份”是指实体有内部表示，而不是根据名字来识别，比如匿名函数，还可以通过赋值叫任何名字。大部分语言的基本类型的数值(int, float)等都是第一类对象；但是数组不一定，比如C中的数组，作为函数参数时，传递的是第一个元素的地址，同时还丢失了数组长度信息。对于大多数的动态语言，函数/方法都是第一类对象，比如Python，但是Ruby不是，因为不能返回一个方法。第一类函数对函数式编程语言来说是必须的。</li>
</ul>
<p>也就是说在 go语言中函数拥有类型，可以被赋值，可以作为函数的参数或返回值，还可以有匿名函数</p>
<h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(args ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, a := <span class="keyword">range</span> args &#123;</span><br><span class="line">        total += a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(sum()) <span class="comment">// 0</span></span><br><span class="line">fmt.Println(sum(<span class="number">1</span>)) <span class="comment">// 1</span></span><br><span class="line">fmt.Println(sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(sum(arr...)) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h5 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h5><p>有时候我们需要在函数执行结束之前释放资源（如数据库链接）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseFromFile</span><span class="params">(fileName <span class="keyword">string</span>)</span> <span class="params">(res []<span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">    inputFile, err := os.Open(fileName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;An error occurred on opening the inputfile\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;Does the file exist?\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;Have you got acces to it?\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inputReader := bufio.NewReader(inputFile)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        inputString, err := inputReader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                fmt.Printf(<span class="string">&quot;The input was: %s&quot;</span>, inputString)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        inputFile.Close()</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">if</span> (err = checkLine(inputString)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    inputFile.Close()</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">append</span>(res, inputString)     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在每个 <code>return</code> 语句之前，我们都需要调用 <code>inputFile.Close()</code>, 这样做是在太麻烦，go 为我们提供了 <code>refer</code> 关键字</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseFromFile</span><span class="params">(fileName <span class="keyword">string</span>)</span> <span class="params">(res []<span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">    inputFile, err := os.Open(fileName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;An error occurred on opening the inputfile\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;Does the file exist?\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;Have you got acces to it?\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">        refer inputFile.Close() <span class="comment">// 在函数执行到return 之前被调用</span></span><br><span class="line"></span><br><span class="line">    inputReader := bufio.NewReader(inputFile)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        inputString, err := inputReader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                fmt.Printf(<span class="string">&quot;The input was: %s&quot;</span>, inputString)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">if</span> (err = checkLine(inputString)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">append</span>(res, inputString)     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="refer-执行顺序"><a href="#refer-执行顺序" class="headerlink" title="refer 执行顺序"></a>refer 执行顺序</h6><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;this is func 1\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;this is func 2\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;this is func 3\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func4</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;this is func 4\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;begin\n&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> func1()</span><br><span class="line">    <span class="keyword">defer</span> func2()</span><br><span class="line">    <span class="keyword">defer</span> func3()</span><br><span class="line">    <span class="keyword">defer</span> func4()</span><br><span class="line">    log.Printf(<span class="string">&quot;finished\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序的数据输出结果是：</p>
<pre><code>            2018/04/17 08:11:41 begin
            2018/04/17 08:11:41 finished
            2018/04/17 08:11:41 this is func 4
            2018/04/17 08:11:41 this is func 3
            2018/04/17 08:11:41 this is func 2
            2018/04/17 08:11:41 this is func 1</code></pre>
<p>可以看出来：<code>defer</code> 的执行顺序和定义顺序正好是相反的</p>
<h5 id="循环中的-defer"><a href="#循环中的-defer" class="headerlink" title="循环中的 defer"></a>循环中的 defer</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// before process file</span></span><br><span class="line"><span class="keyword">for</span> _, filename := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">        f, err := os.Open(filename)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close() <span class="comment">// <span class="doctag">NOTE:</span> risky; could run out of file</span></span><br><span class="line"><span class="comment">// ...process f</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// after process file</span></span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>在上面的程序中我们遍历文件名称数组，一个个的处理文件，并在处理完之后希望去关闭文件； 但是 <code>defer</code> 是在函数执行完最后一步才触发，如果文件比较多可能会耗光系统的文件描述符</p>
<p>这里的解决方案是把 for 循环的循环体抽取成函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, filename := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">        <span class="keyword">if</span> err := doFile(filename); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doFile</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        f, err := os.Open(filename)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> f.Close()</span><br><span class="line">        <span class="comment">// ...process f…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="init-函数"><a href="#init-函数" class="headerlink" title="init 函数"></a>init 函数</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// init something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>前面讲结构体的时候, 讲过可以给结构体定义方法, 事实上除了结构体我们还可以们可以给数值、字符串、map、数组定义一些自定义行为</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义int 数组</span></span><br><span class="line"><span class="keyword">type</span> array []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给数组定义 sum 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a array)</span> <span class="title">sum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, i := <span class="keyword">range</span> a &#123;</span><br><span class="line">        total += i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> arr1 = array&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    arrSum := arr1.sum()</span><br><span class="line">    fmt.Println(arrSum)  <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line">    arrSum2 := array.sum(arr1) <span class="comment">// 常规调动函数的方法</span></span><br><span class="line">    fmt.Println(arrSum2)  <span class="comment">// 输出 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。</p>
<ol start="2">
<li>内嵌结构体的函数</li>
<li>垃圾回收</li>
<li>协程池</li>
<li>并发</li>
<li>etcd</li>
</ol>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Jackson 中的 Features</title>
    <url>/2016/07/10/%E6%8A%80%E6%9C%AF/java/2016-07-10-jackson%E4%B8%AD%E7%9A%84Feature/</url>
    <content><![CDATA[<h2 id="Jackson-中的各种-Features"><a href="#Jackson-中的各种-Features" class="headerlink" title="Jackson 中的各种 Features"></a>Jackson 中的各种 Features</h2><p>先来看看 jackson 中的各种feature<br><img src="/assets/picture/jacksonFeature.png" alt="图片" title="Feature 类图"></p>
<p>首先是 序列化时候的Feature ——</p>
<h3 id="SerializaitonFeature"><a href="#SerializaitonFeature" class="headerlink" title="SerializaitonFeature"></a>SerializaitonFeature</h3><hr>
<h4 id="WRAP-ROOT-VALUE-false-序列化的json是否显示根节点"><a href="#WRAP-ROOT-VALUE-false-序列化的json是否显示根节点" class="headerlink" title="WRAP_ROOT_VALUE(false) : 序列化的json是否显示根节点"></a><code>WRAP_ROOT_VALUE(false)</code> : 序列化的json是否显示根节点</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWrapRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       SimpleBean simpleBean = <span class="keyword">new</span> SimpleBean();</span><br><span class="line">       simpleBean.setCode(<span class="number">1</span>);</span><br><span class="line">       simpleBean.setName(<span class="string">&quot;TEST_WRAP_ROOT_VALUE&quot;</span>);</span><br><span class="line">       simpleBean.setDesc(Lists.newArrayList(<span class="string">&quot;test1&quot;</span>, <span class="string">&quot;test2&quot;</span>, <span class="string">&quot;test3&quot;</span>));</span><br><span class="line"></span><br><span class="line">       ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//        objectMapper.enable(SerializationFeature.WRAP_ROOT_VALUE);</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           String s = objectMapper.writeValueAsString(simpleBean);</span><br><span class="line">           System.out.println(s);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<pre><code>&#123;&quot;name&quot;:&quot;TEST_WRAP_ROOT_VALUE&quot;,&quot;code&quot;:1,&quot;desc&quot;:[&quot;test1&quot;,&quot;test2&quot;,&quot;test3&quot;]&#125;</code></pre>
<p>去掉注释的运行结果：</p>
<pre><code>&#123;&quot;SimpleBean&quot;:&#123;&quot;name&quot;:&quot;TEST_WRAP_ROOT_VALUE&quot;,&quot;code&quot;:1,&quot;desc&quot;:[&quot;test1&quot;,&quot;test2&quot;,&quot;test3&quot;]&#125;&#125;</code></pre>
<p>从结果可以看出 jackson 会把类名作为根节点展示</p>
<hr>
<h4 id="INDENT-OUTPUT-false-允许或禁止是否以缩进的方式展示json"><a href="#INDENT-OUTPUT-false-允许或禁止是否以缩进的方式展示json" class="headerlink" title="INDENT_OUTPUT(false): 允许或禁止是否以缩进的方式展示json"></a><code>INDENT_OUTPUT(false)</code>: 允许或禁止是否以缩进的方式展示json</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testIdentOutput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SimpleBean simpleBean = <span class="keyword">new</span> SimpleBean();</span><br><span class="line">    simpleBean.setCode(<span class="number">1</span>);</span><br><span class="line">    simpleBean.setName(<span class="string">&quot;TEST_WRAP_ROOT_VALUE&quot;</span>);</span><br><span class="line">    simpleBean.setDesc(Lists.newArrayList(<span class="string">&quot;test1&quot;</span>, <span class="string">&quot;test2&quot;</span>, <span class="string">&quot;test3&quot;</span>));</span><br><span class="line"></span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    objectMapper.enable(SerializationFeature.INDENT_OUTPUT);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String s = objectMapper.writeValueAsString(simpleBean);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的结果：</p>
<pre><code>&#123;
    &quot;name&quot; : &quot;TEST_WRAP_ROOT_VALUE&quot;,
    &quot;code&quot; : 1,
    &quot;desc&quot; : [ &quot;test1&quot;, &quot;test2&quot;, &quot;test3&quot; ]
&#125;</code></pre>
<hr>
<h4 id="FAIL-ON-EMPTY-BEANS-true-当类的一个属性外部无法访问-如：没有getter-setter-的私有属性-，且没有annotation-标明需要序列化时，如果FAIL-ON-EMPTY-BEANS-是true-将会跑出异常，如果是false-则不会跑出异常"><a href="#FAIL-ON-EMPTY-BEANS-true-当类的一个属性外部无法访问-如：没有getter-setter-的私有属性-，且没有annotation-标明需要序列化时，如果FAIL-ON-EMPTY-BEANS-是true-将会跑出异常，如果是false-则不会跑出异常" class="headerlink" title="FAIL_ON_EMPTY_BEANS(true): 当类的一个属性外部无法访问(如：没有getter setter 的私有属性)，且没有annotation 标明需要序列化时，如果FAIL_ON_EMPTY_BEANS 是true 将会跑出异常，如果是false 则不会跑出异常"></a><code>FAIL_ON_EMPTY_BEANS</code>(true): 当类的一个属性外部无法访问(如：没有getter setter 的私有属性)，且没有annotation 标明需要序列化时，如果FAIL_ON_EMPTY_BEANS 是true 将会跑出异常，如果是false 则不会跑出异常</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testFailOnEmptyField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TestBean simpleBean = <span class="keyword">new</span> TestBean();</span><br><span class="line"></span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//        objectMapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String s = objectMapper.writeValueAsString(simpleBean);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码运行结果</p>
<pre><code>    com.fasterxml.jackson.databind.JsonMappingException: No serializer found for class com.liam.learning.Main$TestBean and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS)
      at com.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:275)
      at com.fasterxml.jackson.databind.SerializerProvider.mappingException(SerializerProvider.java:1109)
      at com.fasterxml.jackson.databind.SerializerProvider.reportMappingProblem(SerializerProvider.java:1134)
      at com.fasterxml.jackson.databind.ser.impl.UnknownSerializer.failForEmpty(UnknownSerializer.java:69)
      at com.fasterxml.jackson.databind.ser.impl.UnknownSerializer.serialize(UnknownSerializer.java:32)
      at com.fasterxml.jackson.databind.ser.DefaultSerializerProvider.serializeValue(DefaultSerializerProvider.java:292)
      at com.fasterxml.jackson.databind.ObjectMapper._configAndWriteValue(ObjectMapper.java:3672)
      at com.fasterxml.jackson.databind.ObjectMapper.writeValueAsString(ObjectMapper.java:3048)
      at com.liam.learning.Main.testFailOnEmptyField(Main.java:56)
      at com.liam.learning.Main.main(Main.java:15)
      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
      at java.lang.reflect.Method.invoke(Method.java:606)
      at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)</code></pre>
<p>取消注释的运行结果：</p>
<pre><code>&#123;&#125;</code></pre>
<hr>
<h4 id="FAIL-ON-SELF-REFERENCES-true"><a href="#FAIL-ON-SELF-REFERENCES-true" class="headerlink" title="FAIL_ON_SELF_REFERENCES(true)"></a>FAIL_ON_SELF_REFERENCES(true)</h4><p>如果POJO 中有一个直接自我引用，在序列化的时候会抛出 <code>com.fasterxml.jackson.databind.JsonMappingException</code></p>
<hr>
<h4 id="WRAP-EXCEPTIONS-true"><a href="#WRAP-EXCEPTIONS-true" class="headerlink" title="WRAP_EXCEPTIONS(true)"></a>WRAP_EXCEPTIONS(true)</h4><p>如果序列化过程中，如果抛出 Exception 将会被包装，添加额外的上下文信息</p>
<hr>
<h4 id="FAIL-ON-UNWRAPPED-TYPE-IDENTIFIERS-true"><a href="#FAIL-ON-UNWRAPPED-TYPE-IDENTIFIERS-true" class="headerlink" title="FAIL_ON_UNWRAPPED_TYPE_IDENTIFIERS(true)"></a>FAIL_ON_UNWRAPPED_TYPE_IDENTIFIERS(true)</h4><p>该特性决定了，用 <code>com.fasterxml.jackson.annotation.JsonUnwrapped</code> 注解修饰的属性，且该属性的类型还有类型信息（被 <code>com.fasterxml.jackson.annotation.JsonTypeInfo</code> 注解修饰）的时候，是否抛出异常；默认情况下会抛出异常，除非禁止该特性</p>
<p>使用示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testFailOnUnwrappedTypeIdentifiers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    objectMapper.enable(SerializationFeature.INDENT_OUTPUT);</span><br><span class="line">    <span class="comment">// 禁止特性 FAIL_ON_UNWRAPPED_TYPE_IDENTIFIERS</span></span><br><span class="line">    objectMapper.disable(SerializationFeature.FAIL_ON_UNWRAPPED_TYPE_IDENTIFIERS);</span><br><span class="line"></span><br><span class="line">    TestJsonPojo.TestInputInnerJsonPojo testInputInnerJsonPojo = <span class="keyword">new</span> TestJsonPojo.TestInputInnerJsonPojo();</span><br><span class="line">    testInputInnerJsonPojo.setDesc(<span class="string">&quot;desc1&quot;</span>);</span><br><span class="line">    testInputInnerJsonPojo.setTip(<span class="string">&quot;tip1&quot;</span>);</span><br><span class="line">    testInputInnerJsonPojo.setInput(<span class="string">&quot;input information&quot;</span>);</span><br><span class="line"></span><br><span class="line">    TestJsonPojo testJsonPojo = <span class="keyword">new</span> TestJsonPojo();</span><br><span class="line">    testJsonPojo.setName(<span class="string">&quot;the test name&quot;</span>);</span><br><span class="line">    testJsonPojo.setDescription(testInputInnerJsonPojo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(objectMapper.writeValueAsString(testJsonPojo));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        TestJsonPojo.TestSelectInnerJsonPojo testSelectInnerJsonPojo = <span class="keyword">new</span> TestJsonPojo.TestSelectInnerJsonPojo();</span><br><span class="line">        testSelectInnerJsonPojo.setDesc(<span class="string">&quot;desc1&quot;</span>);</span><br><span class="line">        testSelectInnerJsonPojo.setTip(<span class="string">&quot;tip1&quot;</span>);</span><br><span class="line">        testSelectInnerJsonPojo.setSelect(<span class="string">&quot;select information&quot;</span>);</span><br><span class="line">        testJsonPojo.setDescription(testSelectInnerJsonPojo);</span><br><span class="line">        System.out.println(objectMapper.writeValueAsString(testJsonPojo));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJsonPojo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonUnwrapped</span></span><br><span class="line">    <span class="keyword">private</span> TestInnerJsonPojo description;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestInnerJsonPojo <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(TestInnerJsonPojo description)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = &quot;type&quot;, visible = true)</span></span><br><span class="line">    <span class="meta">@JsonSubTypes(value = &#123;</span></span><br><span class="line"><span class="meta">            @JsonSubTypes.Type(value = TestInputInnerJsonPojo.class, name = &quot;input&quot;),</span></span><br><span class="line"><span class="meta">            @JsonSubTypes.Type(value = TestInputInnerJsonPojo.class, name = &quot;select&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInnerJsonPojo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String tip;</span><br><span class="line">        <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getTip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> tip;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTip</span><span class="params">(String tip)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.tip = tip;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> desc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.desc = desc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInputInnerJsonPojo</span> <span class="keyword">extends</span> <span class="title">TestInnerJsonPojo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String input;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getInput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> input;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInput</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.input = input;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSelectInnerJsonPojo</span> <span class="keyword">extends</span> <span class="title">TestInnerJsonPojo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String select;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getSelect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> select;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSelect</span><span class="params">(String select)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.select = select;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码可以执行成功，输出如下：</p>
<pre><code>            &#123;
            &quot;name&quot; : &quot;the test name&quot;,
            &quot;tip&quot; : &quot;tip1&quot;,
            &quot;desc&quot; : &quot;desc1&quot;,
            &quot;input&quot; : &quot;input information&quot;
            &#125;
            ===================================================
            &#123;
            &quot;name&quot; : &quot;the test name&quot;,
            &quot;tip&quot; : &quot;tip1&quot;,
            &quot;desc&quot; : &quot;desc1&quot;,
            &quot;select&quot; : &quot;select information&quot;
            &#125;

            Process finished with exit code 0</code></pre>
<p>而当我们不禁止该特性的时候</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">objectMapper.enable(SerializationFeature.FAIL_ON_UNWRAPPED_TYPE_IDENTIFIERS);</span><br></pre></td></tr></table></figure>

<p>则会抛出异常</p>
<pre><code>            com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Unwrapped property requires use of type information: cannot serialize without disabling `SerializationFeature.FAIL_ON_UNWRAPPED_TYPE_IDENTIFIERS` (through reference chain: com.liam.learning.jackson.features.SerializationFeatureDemo$TestJsonPojo[&quot;description&quot;])
            at com.fasterxml.jackson.databind.exc.InvalidDefinitionException.from(InvalidDefinitionException.java:77)
            at com.fasterxml.jackson.databind.SerializerProvider.reportBadDefinition(SerializerProvider.java:1277)
            at com.fasterxml.jackson.databind.DatabindContext.reportBadDefinition(DatabindContext.java:400)
            at com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanSerializer.serializeWithType(UnwrappingBeanSerializer.java:143)
            at com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanPropertyWriter.serializeAsField(UnwrappingBeanPropertyWriter.java:129)
            at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:755)
            at com.fasterxml.jackson.databind.ser.BeanSerializer.serialize(BeanSerializer.java:178)
            at com.fasterxml.jackson.databind.ser.DefaultSerializerProvider._serialize(DefaultSerializerProvider.java:480)
            at com.fasterxml.jackson.databind.ser.DefaultSerializerProvider.serializeValue(DefaultSerializerProvider.java:319)
            at com.fasterxml.jackson.databind.ObjectMapper._writeValueAndClose(ObjectMapper.java:4407)
            at com.fasterxml.jackson.databind.ObjectMapper.writeValueAsString(ObjectMapper.java:3661)
            at com.liam.learning.jackson.features.SerializationFeatureDemo.testFailOnUnwrappedTypeIdentifiers(SerializationFeatureDemo.java:141)
            at com.liam.learning.jackson.features.SerializationFeatureDemo.main(SerializationFeatureDemo.java:25)

            Process finished with exit code 0</code></pre>
<hr>
<h4 id="CLOSE-CLOSEABLE-false"><a href="#CLOSE-CLOSEABLE-false" class="headerlink" title="CLOSE_CLOSEABLE(false)"></a>CLOSE_CLOSEABLE(false)</h4><p>对于 <code>java.io.Closeable</code> 接口的实现类，控制在序列化的时候是否调用 <code>java.io.Closeable#close</code> 方法</p>
<hr>
<h4 id="FLUSH-AFTER-WRITE-VALUE-true"><a href="#FLUSH-AFTER-WRITE-VALUE-true" class="headerlink" title="FLUSH_AFTER_WRITE_VALUE(true)"></a>FLUSH_AFTER_WRITE_VALUE(true)</h4><p>控制是否在调用的 <code>com.fasterxml.jackson.databind.ObjectMapper#writeValue(com.fasterxml.jackson.core.JsonGenerator, java.lang.Object)</code> 方法的时候是否调用 <code>com.fasterxml.jackson.core.JsonGenerator#flush</code> 方法将缓存内容刷新到输出流中；<br>禁止这个功能的主要原因是处于性能原因；对于网络连接，刷新可能会在最佳状态之前发送消息，并且在某些压缩流中会通过 flush() 方法去完成压缩块</p>
<hr>
<h4 id="WRITE-DATES-AS-TIMESTAMPS-true"><a href="#WRITE-DATES-AS-TIMESTAMPS-true" class="headerlink" title="WRITE_DATES_AS_TIMESTAMPS(true)"></a>WRITE_DATES_AS_TIMESTAMPS(true)</h4><p>序列化过程中，将 <code>java.util.Date</code> 类型或者 <code>java.time</code> 包中的数据类型的数据序列化成 long 类型的时间戳</p>
<p><strong><em>注意：使用该特性序列化 <code>java.time</code> 包中的类的时候需要向 ObjectMapper 注册 JavaTimeModule 才能生效</em></strong></p>
<ol>
<li><p>第一步引入依赖 <code>jackson-datatype-jsr310</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.datatype<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-datatype-jsr310<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注册模块 <code>com.fasterxml.jackson.datatype.jsr310.JavaTimeModule</code></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">objectMapper.registerModule(<span class="keyword">new</span> JavaTimeModule());</span><br><span class="line">objectMapper.enable(SerializationFeature.WRITE_DURATIONS_AS_TIMESTAMPS);</span><br><span class="line">objectMapper.enable(SerializationFeature.INDENT_OUTPUT);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="WRITE-DATE-KEYS-AS-TIMESTAMPS-false"><a href="#WRITE-DATE-KEYS-AS-TIMESTAMPS-false" class="headerlink" title="WRITE_DATE_KEYS_AS_TIMESTAMPS(false),"></a>WRITE_DATE_KEYS_AS_TIMESTAMPS(false),</h4><p>控制是否在序列化过程中，将 <code>Map</code> 中 <code>java.util.Date</code> 类型的 key 序列化成 long 类型的时间戳</p>
<hr>
<h4 id="WRITE-DATES-WITH-ZONE-ID-false"><a href="#WRITE-DATES-WITH-ZONE-ID-false" class="headerlink" title="WRITE_DATES_WITH_ZONE_ID(false)"></a>WRITE_DATES_WITH_ZONE_ID(false)</h4><p>控制是否在序列化 <code>java.time.ZonedDateTime</code> 类型数据点时候打印时区信息</p>
<p><strong><em>注意：使用该特性的时候需要向 ObjectMapper 注册 JavaTimeModule</em></strong></p>
<ol>
<li><p>第一步引入依赖 <code>jackson-datatype-jsr310</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.datatype<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-datatype-jsr310<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注册模块 <code>com.fasterxml.jackson.datatype.jsr310.JavaTimeModule</code></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">objectMapper.registerModule(<span class="keyword">new</span> JavaTimeModule());</span><br><span class="line">objectMapper.enable(SerializationFeature.WRITE_DATES_WITH_ZONE_ID);</span><br><span class="line">objectMapper.enable(SerializationFeature.INDENT_OUTPUT);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="WRITE-DURATIONS-AS-TIMESTAMPS-true"><a href="#WRITE-DURATIONS-AS-TIMESTAMPS-true" class="headerlink" title="WRITE_DURATIONS_AS_TIMESTAMPS(true)"></a>WRITE_DURATIONS_AS_TIMESTAMPS(true)</h4><p>控制是否在序列化 <code>java.time.Duration</code> 类型数据是序列成数字还是字符串，ture 则使用数字，false 则使用字符串</p>
<p><strong><em>注意：使用该特性的时候需要向 ObjectMapper 注册 JavaTimeModule</em></strong></p>
<ol>
<li><p>第一步引入依赖 <code>jackson-datatype-jsr310</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.datatype<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-datatype-jsr310<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注册模块 <code>com.fasterxml.jackson.datatype.jsr310.JavaTimeModule</code></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">objectMapper.registerModule(<span class="keyword">new</span> JavaTimeModule());</span><br><span class="line">objectMapper.enable(SerializationFeature.WRITE_DURATIONS_AS_TIMESTAMPS);</span><br><span class="line">objectMapper.enable(SerializationFeature.INDENT_OUTPUT);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="WRITE-CHAR-ARRAYS-AS-JSON-ARRAYS-false-序列化json-的时候对于-char-为true-则解析成数组形式；-为false-则解析成一个字符串-String"><a href="#WRITE-CHAR-ARRAYS-AS-JSON-ARRAYS-false-序列化json-的时候对于-char-为true-则解析成数组形式；-为false-则解析成一个字符串-String" class="headerlink" title="WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS(false): 序列化json 的时候对于 char[] 为true 则解析成数组形式； 为false 则解析成一个字符串(String)"></a>WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS(false): 序列化json 的时候对于 <code>char[]</code> 为true 则解析成数组形式； 为false 则解析成一个字符串(String)</h4><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWriteCharArraysAsJsonArrays</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       String t = <span class="string">&quot;tester&quot;</span>;</span><br><span class="line">       <span class="keyword">char</span>[] arr = t.toCharArray();</span><br><span class="line"></span><br><span class="line">       ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//        objectMapper.enable(SerializationFeature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS);</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           String s = objectMapper.writeValueAsString(arr);</span><br><span class="line">           System.out.println(s);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<pre><code>&quot;tester&quot;</code></pre>
<p>去掉注释后，运行结果如下</p>
<pre><code>[&quot;t&quot;,&quot;e&quot;,&quot;s&quot;,&quot;t&quot;,&quot;e&quot;,&quot;r&quot;]</code></pre>
<hr>
<h4 id="WRITE-ENUMS-USING-TO-STRING-false-序列化时，-enable-用枚举的-enum-toString-表示枚举值-disable-用枚举的-enum-name-表示枚举值"><a href="#WRITE-ENUMS-USING-TO-STRING-false-序列化时，-enable-用枚举的-enum-toString-表示枚举值-disable-用枚举的-enum-name-表示枚举值" class="headerlink" title="WRITE_ENUMS_USING_TO_STRING(false): 序列化时， enable: 用枚举的 enum.toString() 表示枚举值 disable: 用枚举的 enum.name() 表示枚举值"></a>WRITE_ENUMS_USING_TO_STRING(false): 序列化时， enable: 用枚举的 enum.toString() 表示枚举值 disable: 用枚举的 enum.name() 表示枚举值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWriteEnumsUsingString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//        objectMapper.enable(SerializationFeature.WRITE_ENUMS_USING_TO_STRING);</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String s = objectMapper.writeValueAsString(CHILD.BOY);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">enum</span> CHILD &#123;</span><br><span class="line">    BOY, GIRL;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;+&quot;</span> + <span class="keyword">this</span>.name() + <span class="string">&quot;+&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码运行结果：</p>
<pre><code>&quot;BOY&quot;</code></pre>
<p>去掉注释后的代码运行结果：</p>
<pre><code>&quot;+BOY+&quot;</code></pre>
<hr>
<h4 id="WRITE-ENUMS-USING-INDEX-false-序列化时，用枚举的-enum-index-表示枚举值"><a href="#WRITE-ENUMS-USING-INDEX-false-序列化时，用枚举的-enum-index-表示枚举值" class="headerlink" title="WRITE_ENUMS_USING_INDEX(false): 序列化时，用枚举的 enum.index() 表示枚举值"></a>WRITE_ENUMS_USING_INDEX(false): 序列化时，用枚举的 enum.index() 表示枚举值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWriteEnumsUsingIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//        objectMapper.enable(SerializationFeature.WRITE_ENUMS_USING_INDEX);</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String s = objectMapper.writeValueAsString(CHILD.BOY);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">enum</span> CHILD &#123;</span><br><span class="line">    BOY, GIRL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码运行结果：</p>
<pre><code>&quot;BOY&quot;</code></pre>
<p>取消注释后代码运行结果：</p>
<pre><code>0</code></pre>
<hr>
<h4 id="WRITE-NULL-MAP-VALUES-true-对于-Map-中的-null-值-是否序列化"><a href="#WRITE-NULL-MAP-VALUES-true-对于-Map-中的-null-值-是否序列化" class="headerlink" title="WRITE_NULL_MAP_VALUES(true): 对于 Map 中的 null 值 是否序列化"></a>WRITE_NULL_MAP_VALUES(true): 对于 Map 中的 null 值 是否序列化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWriteNullMapValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, Object&gt; extMap = Maps.newHashMap();</span><br><span class="line">    extMap.put(<span class="string">&quot;test1&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">    extMap.put(<span class="string">&quot;test2&quot;</span>, <span class="string">&quot;not null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//        objectMapper.disable(SerializationFeature.WRITE_NULL_MAP_VALUES);</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String s = objectMapper.writeValueAsString(extMap);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码运行结果：</p>
<pre><code>&#123;&quot;test1&quot;:null,&quot;test2&quot;:&quot;not null&quot;&#125;</code></pre>
<p>去除注释后的运行结果：</p>
<pre><code>&#123;&quot;test2&quot;:&quot;not null&quot;&#125;</code></pre>
<hr>
<h4 id="WRITE-EMPTY-JSON-ARRAYS-true-对于空的-Collection、-数组-为-true-则序列化，-为-false-则跳过，-默认为-true"><a href="#WRITE-EMPTY-JSON-ARRAYS-true-对于空的-Collection、-数组-为-true-则序列化，-为-false-则跳过，-默认为-true" class="headerlink" title="WRITE_EMPTY_JSON_ARRAYS(true): 对于空的 Collection、 数组 ; 为 true 则序列化， 为 false 则跳过， 默认为 true"></a>WRITE_EMPTY_JSON_ARRAYS(true): 对于空的 <code>Collection</code>、 <code>数组</code> ; 为 <code>true</code> 则序列化， 为 <code>false</code> 则跳过， 默认为 <code>true</code></h4><p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWriteEmptyJsonArrays</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SimpleBean simpleBean = <span class="keyword">new</span> SimpleBean();</span><br><span class="line">    simpleBean.setCode(<span class="number">1</span>);</span><br><span class="line">    simpleBean.setName(<span class="string">&quot;WRITE_EMPTY_JSON_ARRAYS&quot;</span>);</span><br><span class="line">    simpleBean.setDesc(Collections.&lt;String&gt;emptyList());</span><br><span class="line"></span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//        objectMapper.disable(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS);</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String s = objectMapper.writeValueAsString(simpleBean);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<pre><code>&#123;&quot;name&quot;:&quot;WRITE_EMPTY_JSON_ARRAYS&quot;,&quot;code&quot;:1,&quot;desc&quot;:[],&quot;ext&quot;:null&#125;</code></pre>
<p>取消注释后，运行结果如下：</p>
<pre><code>&#123;&quot;name&quot;:&quot;WRITE_EMPTY_JSON_ARRAYS&quot;,&quot;code&quot;:1,&quot;ext&quot;:null&#125;</code></pre>
<hr>
<h4 id="WRITE-SINGLE-ELEM-ARRAYS-UNWRAPPED-false-序列化json时，对于只有单个元素的数组，不用中括号-‘-’-括起来"><a href="#WRITE-SINGLE-ELEM-ARRAYS-UNWRAPPED-false-序列化json时，对于只有单个元素的数组，不用中括号-‘-’-括起来" class="headerlink" title="WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED(false): 序列化json时，对于只有单个元素的数组，不用中括号(‘[]’)括起来"></a>WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED(false): 序列化json时，对于只有单个元素的数组，不用中括号(‘[]’)括起来</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWrietSingleElemArraysUnwrapped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SimpleBean simpleBean = <span class="keyword">new</span> SimpleBean();</span><br><span class="line">    simpleBean.setCode(<span class="number">1</span>);</span><br><span class="line">    simpleBean.setName(<span class="string">&quot;TEST_WRAP_ROOT_VALUE&quot;</span>);</span><br><span class="line">    simpleBean.setDesc(Lists.newArrayList(<span class="string">&quot;test1&quot;</span>));</span><br><span class="line"></span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//        objectMapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED);</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String s = objectMapper.writeValueAsString(simpleBean);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码运行结果：</p>
<pre><code>&#123;&quot;name&quot;:&quot;TEST_WRAP_ROOT_VALUE&quot;,&quot;code&quot;:1,&quot;desc&quot;:[&quot;test1&quot;]&#125;</code></pre>
<p>去掉注释之后的，运行结果</p>
<pre><code>&#123;&quot;name&quot;:&quot;TEST_WRAP_ROOT_VALUE&quot;,&quot;code&quot;:1,&quot;desc&quot;:&quot;test1&quot;&#125;</code></pre>
<p>效果一目了然！</p>
<hr>
<h4 id="WRITE-BIGDECIMAL-AS-PLAIN-false-deprecated"><a href="#WRITE-BIGDECIMAL-AS-PLAIN-false-deprecated" class="headerlink" title="WRITE_BIGDECIMAL_AS_PLAIN(false): @deprecated"></a>WRITE_BIGDECIMAL_AS_PLAIN(false): <code>@deprecated</code></h4><p><code>@see</code><br><code>com.fasterxml.jackson.core.JsonGenerator.Feature#WRITE_BIGDECIMAL_AS_PLAIN</code></p>
<hr>
<h4 id="WRITE-DATE-TIMESTAMPS-AS-NANOSECONDS-true-序列化json的时候把时间类型值序列化成纳秒的形式"><a href="#WRITE-DATE-TIMESTAMPS-AS-NANOSECONDS-true-序列化json的时候把时间类型值序列化成纳秒的形式" class="headerlink" title="WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS(true): 序列化json的时候把时间类型值序列化成纳秒的形式"></a>WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS(true): 序列化json的时候把时间类型值序列化成纳秒的形式</h4><pre><code>`注意` 只有最新版本(`jdk8` 中的 `Date/Time` )的时间类型支持本特性, `jdk8` 之前的 `java.util.Date`  和`joda-time` 都不支持！</code></pre>
<hr>
<h4 id="ORDER-MAP-ENTRIES-BY-KEYS-false-序列化-Map-的时候，-为-true-则按照-Map-的-key-进行排序，否则不排序"><a href="#ORDER-MAP-ENTRIES-BY-KEYS-false-序列化-Map-的时候，-为-true-则按照-Map-的-key-进行排序，否则不排序" class="headerlink" title="ORDER_MAP_ENTRIES_BY_KEYS(false): 序列化 Map 的时候， 为 true 则按照 Map 的 key 进行排序，否则不排序"></a>ORDER_MAP_ENTRIES_BY_KEYS(false): 序列化 <code>Map</code> 的时候， 为 <code>true</code> 则按照 <code>Map</code> 的 <code>key</code> 进行排序，否则不排序</h4><p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testOrderMapEntriesByKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//        objectMapper.enable(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS);</span></span><br><span class="line">    Map&lt;String, String&gt; data = ImmutableMap.of(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;test1&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;test2&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;test3&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;test4&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String dateStr = objectMapper.writeValueAsString(data);</span><br><span class="line">        System.out.println(dateStr);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<pre><code>&#123;&quot;1&quot;:&quot;test1&quot;,&quot;3&quot;:&quot;test2&quot;,&quot;2&quot;:&quot;test3&quot;,&quot;0&quot;:&quot;test4&quot;&#125;</code></pre>
<p>取消注释的运行结果：</p>
<pre><code>&#123;&quot;0&quot;:&quot;test4&quot;,&quot;1&quot;:&quot;test1&quot;,&quot;2&quot;:&quot;test3&quot;,&quot;3&quot;:&quot;test2&quot;&#125;</code></pre>
<hr>
<h4 id="EAGER-SERIALIZER-FETCH-true-序列化是是否应当预先抓取必要的-JsonSerializer-，-绝大多数情况下不应该关闭此特性"><a href="#EAGER-SERIALIZER-FETCH-true-序列化是是否应当预先抓取必要的-JsonSerializer-，-绝大多数情况下不应该关闭此特性" class="headerlink" title="EAGER_SERIALIZER_FETCH(true): 序列化是是否应当预先抓取必要的 JsonSerializer ， 绝大多数情况下不应该关闭此特性"></a>EAGER_SERIALIZER_FETCH(true): 序列化是是否应当预先抓取必要的 <code>JsonSerializer</code> ， 绝大多数情况下不应该关闭此特性</h4><hr>
<h4 id="USE-EQUALITY-FOR-OBJECT-ID-false"><a href="#USE-EQUALITY-FOR-OBJECT-ID-false" class="headerlink" title="USE_EQUALITY_FOR_OBJECT_ID(false);"></a>USE_EQUALITY_FOR_OBJECT_ID(false);</h4><hr>
<p>接下来是 反序列化时候的Feature ——</p>
<h3 id="DeserializationFeature"><a href="#DeserializationFeature" class="headerlink" title="DeserializationFeature"></a>DeserializationFeature</h3><p>先来个最常用的：</p>
<h4 id="FAIL-ON-UNKNOWN-PROPERTIES-：-反序列化遇到未知的字段的时候是否失败，-默认是-true-会失败"><a href="#FAIL-ON-UNKNOWN-PROPERTIES-：-反序列化遇到未知的字段的时候是否失败，-默认是-true-会失败" class="headerlink" title="FAIL_ON_UNKNOWN_PROPERTIES ： 反序列化遇到未知的字段的时候是否失败， 默认是 true 会失败"></a><code>FAIL_ON_UNKNOWN_PROPERTIES</code> ： 反序列化遇到未知的字段的时候是否失败， 默认是 true 会失败</h4>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title>几种分布式锁的实现方式</title>
    <url>/2016/10/26/%E6%8A%80%E6%9C%AF/java/2016-10-26-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>分布式是现在大多数程序必要的运行环境：单机服务如果服务器宕机了，向外提供的服务马上崩溃，整个系统陷入瘫痪；而如果存在多个服务器向外提供服务，<br>只要还存在提供服务的服务器，系统就能正常运行</p>
<p>分布式系统向外提供服务时，很多情况下都会出现多个服务器共享某一资源的情况，存在自愿竞争；</p>
<p>如：<br>商品系统提供了rpc 接口，功能是创建商品信息，这个rpc 接口的提供服务器有 A,B,C；<br>这个创建商品信息的接口，在创建新的商品之前，会检测现在是否已经存在该商品，如果存在则返回已存在该商品，否则将新建商品<br>rpc接口的消费者是E， 假设 E 第一次调用的时候调用的是A，在短时间内再次请求，创建相同的商品，这时候A 服务器还没处理完,假设请求分发到了B<br>这时候 A 服务器还没有将商品信息持久化， B 服务器已经运行到了检查是否已经存在该商品， B 服务器没有查询到商品已存在，又创建了一个商品，此时商品的唯一性时效！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在持久化商品信息之前需要进行的操作</span></span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">// 检测商品信息是否存在</span></span><br><span class="line">  <span class="keyword">if</span> (商品信息已存在) &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail().withErrMsg(<span class="string">&quot;该商品已存在！&quot;</span>);</span><br><span class="line">  &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 保存商品信息</span></span><br><span class="line">    saveProductInfo();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...... 商品保存后的逻辑操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>面对上述问题，在单机服务器上，我们很容易想到给 <code>createProduct</code> 加锁，使该方法实现线程安全； 将这个思路扩展到分布式系统，我们能否提供一个适用于分布式系统的锁？<br>要实现分布式锁，我们需要借助工具</p>
<ol>
<li>数据库</li>
<li>redis</li>
<li>zookeeper</li>
</ol>
<h3 id="1-依赖数据库实现分布式锁"><a href="#1-依赖数据库实现分布式锁" class="headerlink" title="1. 依赖数据库实现分布式锁"></a>1. 依赖数据库实现分布式锁</h3><p>各种版本的数据库都实现了锁，这里以 <code>mysql</code> 的 <code>InnoDB</code> 存储引擎为例；</p>
<p><code>InnoDB</code> 的特性是：支持事务、支持行级锁、支持外键；</p>
<p><code>InnoDB</code> 提供了两种类型的行级锁：</p>
<p>1.<code>共享锁(S)</code>: 允许一个事务去读一行数据，阻止其他事务获取相同数据集的排他写锁<br>2.<code>排他锁(X)</code>: 允许获得排他锁的事务修改一行数据，阻止其他事务获取相同数据集的共享读锁和排他写锁</p>
<p>对于 <code>DELETE</code>、<code>UPDATE</code>、<code>INSERT</code>语句，<code>InnoDB</code>会自动给涉及到的数据集加上排他锁；<br>对于普通的 <code>SELECT</code> 语句，<code>InnoDB</code> 不会加上任务锁；<br>而 <code>事务</code> 可以通过以下语句显式的给涉及到的数据集加上共享锁或者排他锁：</p>
<ol>
<li>显式添加共享锁</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>显式添加排他锁</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p><code>FOR UPDATE</code> 添加排他锁，后一个想要获取锁的事务，会等待前一个事务的完成之后才能获取排他锁</p>
<p>回到正题，我们上面所说的分布式锁，需要具备排他性；<code>事务</code> 通过 <code>FOR UPDATE</code> 添加排他锁正好满足我们的需求</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">def <span class="keyword">lock</span>:</span><br><span class="line">  <span class="keyword">set</span> autocommit <span class="number">0</span>; // 取消事务的自动提交特性</span><br><span class="line">  <span class="keyword">select</span> * <span class="keyword">from</span> lock_table <span class="keyword">where</span> lock_key = ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line">def <span class="keyword">unlock</span>:</span><br><span class="line">  <span class="keyword">set</span> autocommit <span class="number">1</span>;  // 提交事务，解除行级锁</span><br></pre></td></tr></table></figure>

<p>这里使用的 <code>事务</code> + <code>FOR UPDATE</code> 添加排他锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liam.distribute.lock.db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.liam.distribute.lock.DistributeLock;</span><br><span class="line"><span class="keyword">import</span> com.liam.distribute.lock.LockException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by chaochun.chen on 16-10-27.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForUpdateSimpleLock</span> <span class="keyword">implements</span> <span class="title">DistributeLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Connection&gt; localConnection = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FOR_UPDATE_SQL = <span class="string">&quot;select * from lock_table where lock_key = ? for update&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(String lockKey)</span> </span>&#123;</span><br><span class="line">        Connection connection = localConnection.get();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            PreparedStatement statement = connection.prepareStatement(FOR_UPDATE_SQL);</span><br><span class="line">            statement.setString(<span class="number">1</span>, lockKey);</span><br><span class="line">            ResultSet resultSet = statement.executeQuery();</span><br><span class="line">            <span class="keyword">if</span> (resultSet.next()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// 忽略异常，默认为尝试加锁失败！</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String lockKey)</span> </span>&#123;</span><br><span class="line">        Connection connection = localConnection.get();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    PreparedStatement statement = connection.prepareStatement(FOR_UPDATE_SQL);</span><br><span class="line">                    statement.setString(<span class="number">1</span>, lockKey);</span><br><span class="line">                    ResultSet resultSet = statement.executeQuery();</span><br><span class="line">                    <span class="keyword">if</span> (resultSet.next()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// 此时如果抛出异常则重试！</span></span><br><span class="line">                &#125;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// 忽略异常，默认为尝试加锁失败！</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">(String lockKey)</span> </span>&#123;</span><br><span class="line">        Connection connection = localConnection.get();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConnection</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        localConnection.set(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这种实现分布式锁的方法存在一些问题：</p>
<ol>
<li>性能不是很高</li>
<li>这里加锁解锁依赖sql，必须面对sql超时问题，如果底层 jdbc 和 数据库之前的socket 超时了，此时connection 基本不可用，需要关闭；<br>因此，在使用 <code>Connection</code> 的时候，推荐的使用方式是，将  <code>Connection</code> 的生命周期控制在一个方法内；</li>
<li>如果调用分布式锁的消费者宕机了，没有人去解锁，其他消费者将无法获取锁</li>
<li>没有可重入性</li>
</ol>
<p>除了上面说的 依赖 <code>事务</code> 通过 <code>FOR UPDATE</code> 实现分布式锁； 我们还能通过 <code>唯一索引</code> 实现分布式锁</p>
<p>先看看建表语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> uniq_lock_table (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">INT</span> (<span class="number">10</span>) <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">&#x27;自增主键&#x27;</span>,</span><br><span class="line">  <span class="string">`lock_key`</span> <span class="built_in">VARCHAR</span> (<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;获取锁的key值&#x27;</span>,</span><br><span class="line">  <span class="string">`expire_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;1970-01-01 00:00:00&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;失效时间&#x27;</span>,</span><br><span class="line">  <span class="string">`create_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;1970-01-01 00:00:00&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uniq_lock_key`</span>(<span class="string">`lock_key`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span> <span class="keyword">CHARSET</span> = <span class="string">&#x27;utf8mb4&#x27;</span> <span class="keyword">COMMENT</span> = <span class="string">&#x27;使用唯一索引实现分布式锁的表&#x27;</span></span><br></pre></td></tr></table></figure>

<p>简单定义一个dao 层接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liam.distribute.lock.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by chaochun.chen on 16-10-28.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UniqLockTableMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(String lockKey, Date createTime, Date expireTime)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">del</span><span class="params">(String lockKey)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteExpired</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>分布式锁简单定义如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">def <span class="keyword">lock</span>:</span><br><span class="line">    exec <span class="keyword">sql</span>: <span class="keyword">insert</span> <span class="keyword">into</span> uniq_lock_table(lock_key, create_time, expire_time) <span class="keyword">values</span>(?, ?, ?);</span><br><span class="line">    if result == 1:</span><br><span class="line">      return ture;</span><br><span class="line">    else :</span><br><span class="line">      return false;</span><br><span class="line"></span><br><span class="line">def <span class="keyword">unlock</span>:</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">from</span> uniq_lock_table <span class="keyword">where</span> lock_key = ?;</span><br></pre></td></tr></table></figure>

<p>用java 实现的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liam.distribute.lock.db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.liam.distribute.lock.DistributeLock;</span><br><span class="line"><span class="keyword">import</span> com.liam.distribute.lock.mapper.UniqLockTableMapper;</span><br><span class="line"><span class="keyword">import</span> com.liam.distribute.lock.mapper.UniqLockTableMapperImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.OperationNotSupportedException;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by chaochun.chen on 16-10-27.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniqIndexLock</span> <span class="keyword">implements</span> <span class="title">DistributeLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(String lockKey)</span> </span>&#123;</span><br><span class="line">        UniqLockTableMapper uniqLockTableMapper = UniqLockTableMapperImpl.newInstance();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> insert = uniqLockTableMapper.insert(lockKey, <span class="keyword">new</span> Date(), <span class="keyword">new</span> Date());</span><br><span class="line">            <span class="keyword">if</span> (insert) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 忽略此异常，视为加锁失败！</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String lockKey)</span> </span>&#123;</span><br><span class="line">        UniqLockTableMapper uniqLockTableMapper = UniqLockTableMapperImpl.newInstance();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> insert = uniqLockTableMapper.insert(lockKey, <span class="keyword">new</span> Date(), <span class="keyword">new</span> Date());</span><br><span class="line">                    <span class="keyword">if</span> (insert) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// 忽略此异常，视为加锁失败！</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(String lockKey, TimeUnit timeUnit, <span class="keyword">long</span> expireTime)</span> <span class="keyword">throws</span> OperationNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String lockKey, TimeUnit timeUnit, <span class="keyword">long</span> expireTime)</span> <span class="keyword">throws</span> OperationNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">(String lockKey)</span> </span>&#123;</span><br><span class="line">        UniqLockTableMapper uniqLockTableMapper = UniqLockTableMapperImpl.newInstance();</span><br><span class="line">        uniqLockTableMapper.del(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这种方法的缺点很明显：</p>
<ol>
<li>分布式锁不具备可重入性</li>
<li>如果某一消费者在获取锁之后宕机了，其他消费者无法获取锁</li>
</ol>
<p>为了解决 上面反复提到的 失效的锁的问题，我们在获取锁的时候新增时效时间！</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">def <span class="keyword">lock</span>:</span><br><span class="line">    exec clear_expire_time;</span><br><span class="line">    exec sql: <span class="keyword">insert</span> <span class="keyword">into</span> uniq_lock_table(lock_key, create_time, expire_time) <span class="keyword">values</span>(?, ?, ?);</span><br><span class="line">    if result == 1:</span><br><span class="line">      return ture;</span><br><span class="line">    else :</span><br><span class="line">      return false;</span><br><span class="line"></span><br><span class="line">def clear_expire_time:</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">from</span> uniq_lock_table <span class="keyword">where</span> <span class="keyword">now</span>() &gt; expire_time;</span><br><span class="line"></span><br><span class="line">def <span class="keyword">unlock</span>:</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">from</span> uniq_lock_table <span class="keyword">where</span> lock_key = ?;</span><br></pre></td></tr></table></figure>

<p>java 实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liam.distribute.lock.db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.base.Function;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.FluentIterable;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.ImmutableList;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Iterables;</span><br><span class="line"><span class="keyword">import</span> com.liam.distribute.lock.DistributeLock;</span><br><span class="line"><span class="keyword">import</span> com.liam.distribute.lock.mapper.UniqLockTableMapper;</span><br><span class="line"><span class="keyword">import</span> com.liam.distribute.lock.mapper.UniqLockTableMapperImpl;</span><br><span class="line"><span class="keyword">import</span> com.liam.distribute.lock.model.UniqLockTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.OperationNotSupportedException;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by chaochun.chen on 16-10-28.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniqIndexTimeLock</span> <span class="keyword">implements</span> <span class="title">DistributeLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_EXPIRE_TIMES = <span class="number">2</span> * <span class="number">1000</span>; <span class="comment">// 默认锁时效时间是两秒！</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(String lockKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> tryLock(lockKey, TimeUnit.MILLISECONDS, DEFAULT_EXPIRE_TIMES);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OperationNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String lockKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lock(lockKey, TimeUnit.MILLISECONDS, DEFAULT_EXPIRE_TIMES);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OperationNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(String lockKey, TimeUnit timeUnit, <span class="keyword">long</span> expireTime)</span> <span class="keyword">throws</span> OperationNotSupportedException </span>&#123;</span><br><span class="line">        UniqLockTableMapper uniqLockTableMapper = UniqLockTableMapperImpl.newInstance();</span><br><span class="line">        <span class="keyword">long</span> expireMillis = timeUnit.toMillis(expireTime);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clearExpiredLock();</span><br><span class="line">            <span class="keyword">long</span> cur = System.currentTimeMillis();</span><br><span class="line">            Date now = <span class="keyword">new</span> Date(cur);</span><br><span class="line">            Date expired = <span class="keyword">new</span> Date(cur + expireMillis);</span><br><span class="line">            <span class="keyword">boolean</span> insert = uniqLockTableMapper.insert(lockKey, now, expired);</span><br><span class="line">            <span class="keyword">if</span> (insert) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 忽略此异常，视为加锁失败！</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String lockKey, TimeUnit timeUnit, <span class="keyword">long</span> expireTime)</span> <span class="keyword">throws</span> OperationNotSupportedException </span>&#123;</span><br><span class="line">        UniqLockTableMapper uniqLockTableMapper = UniqLockTableMapperImpl.newInstance();</span><br><span class="line">        <span class="keyword">long</span> expireMillis = timeUnit.toMillis(expireTime);</span><br><span class="line">        <span class="keyword">long</span> currentTimeMillis = System.currentTimeMillis();</span><br><span class="line">        Date now = <span class="keyword">new</span> Date(currentTimeMillis);</span><br><span class="line">        Date expired = <span class="keyword">new</span> Date(currentTimeMillis + expireMillis);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clearExpiredLock();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> insert = uniqLockTableMapper.insert(lockKey, now, expired);</span><br><span class="line">                    <span class="keyword">if</span> (insert) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// 忽略此异常，视为加锁失败！</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">(String lockKey)</span> </span>&#123;</span><br><span class="line">        UniqLockTableMapper uniqLockTableMapper = UniqLockTableMapperImpl.newInstance();</span><br><span class="line">        uniqLockTableMapper.del(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearExpiredLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UniqLockTableMapper uniqLockTableMapper = UniqLockTableMapperImpl.newInstance();</span><br><span class="line">        uniqLockTableMapper.deleteExpired();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这些方法都没能实现分布式锁的可重入性，这里需要新增一个字段，标明分布式锁是谁加的, 再来看看新增分布式锁调用方标识之后的分布式锁定义</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">def <span class="keyword">lock</span>:</span><br><span class="line">  clear_expire_time;</span><br><span class="line">  exec sql: <span class="keyword">insert</span> <span class="keyword">into</span> uniq_lock_table(lock_key, create_time, expire_time, biz_uniq_code) <span class="keyword">values</span>(?, ?, ?, ?);</span><br><span class="line">  if result == 1 :</span><br><span class="line">    return true;</span><br><span class="line">  else :</span><br><span class="line">    exec sql : <span class="keyword">select</span> * <span class="keyword">from</span> uniq_lock_table <span class="keyword">where</span> lock_key = ? <span class="keyword">and</span> biz_uniq_code = ?;</span><br><span class="line">    if query_result &gt; 0 :</span><br><span class="line">      return true;</span><br><span class="line">    else :</span><br><span class="line">      return false;</span><br></pre></td></tr></table></figure>

<p>在使用上面这种方式实现可重入性的时候，需要将表中的唯一索引修改一下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">add</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> <span class="string">`uniq_lock_key_biz_uniq_code`</span>(<span class="string">`lock_key`</span>, <span class="string">`biz_uniq_code`</span>);</span><br></pre></td></tr></table></figure>

<h5 id="注意：-上面说的这些依赖数据库实现分布式锁，都要避免单数据库示例的问题，如果只有一个数据库示例，而数据库宕机了，分布式锁将不能提供服务；因此，分布式锁依赖的数据库必须配置多数据库实例，利用数据库的主从复制逻辑，保证数据同步！"><a href="#注意：-上面说的这些依赖数据库实现分布式锁，都要避免单数据库示例的问题，如果只有一个数据库示例，而数据库宕机了，分布式锁将不能提供服务；因此，分布式锁依赖的数据库必须配置多数据库实例，利用数据库的主从复制逻辑，保证数据同步！" class="headerlink" title="注意： 上面说的这些依赖数据库实现分布式锁，都要避免单数据库示例的问题，如果只有一个数据库示例，而数据库宕机了，分布式锁将不能提供服务；因此，分布式锁依赖的数据库必须配置多数据库实例，利用数据库的主从复制逻辑，保证数据同步！"></a>注意： 上面说的这些依赖数据库实现分布式锁，都要避免单数据库示例的问题，如果只有一个数据库示例，而数据库宕机了，分布式锁将不能提供服务；因此，分布式锁依赖的数据库必须配置多数据库实例，利用数据库的主从复制逻辑，保证数据同步！</h5><h3 id="2-依赖redis实现分布式锁"><a href="#2-依赖redis实现分布式锁" class="headerlink" title="2. 依赖redis实现分布式锁"></a>2. 依赖redis实现分布式锁</h3><p><code>redis</code> 作为内存数据存储系统，相比数据库具有更好的高可用性<br>先来看看一个 <code>redis</code> 命令, <code>setnx</code></p>
<pre><code>    \&gt; help setnx
    SETNX key value

    TIME COMPLEXITY: O(1)



    RETURN VALUE: Integer reply, specifically:

    1 if the key was set
    0 if the key was not set</code></pre>
<p>从帮助信息能看明白， <code>setnx</code> 功能和 <code>set</code>指令类似， 不同在于 <code>setnx</code> 只有插入的key 不存在的时候才能插入成功，成功之后返回 1， 失败返回 0<br>我们依赖 <code>setnx</code> 实现分布式锁，定义如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def lock:</span><br><span class="line">  exec cmd: setnx lock_key lock_value;</span><br><span class="line">  if result == 1 :</span><br><span class="line">    return true;</span><br><span class="line">  else result = 0 :</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">def unlock:</span><br><span class="line">  del lock_key;</span><br></pre></td></tr></table></figure>

<p>上面的定义存在的问题有:</p>
<ol>
<li>调用分布式锁的消费者如果在获取锁之后宕机了，这个失效锁将导致其他消费者无法获取锁</li>
<li>分布式锁不具备可重入性</li>
</ol>
<p>为了提供更好用的分布式锁，我们必须给分布式锁加上时效性<br>下面来看看 <code>redis</code> 的 <code>set</code> 指令</p>
<pre><code>    &gt; help set
    SET key value

    TIME COMPLEXITY: O(1)



    Options

    EX seconds -- Set the specified expire time, in seconds.
    PX milliseconds -- Set the specified expire time, in milliseconds.
    NX -- Only set the key if it does not already exist.
    XX -- Only set the key if it already exist.
    RETURN VALUE: Status code reply: OK if SET was executed correctly. Null multi-bulk reply: a Null Bulk Reply is returned if the SET operation was not performed becase the user specified the NX or XX option but the condition was not met.</code></pre>
<p>从这个可以看出来，<code>set</code> 指令可以做到 <code>setnx</code> 指令的目的，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set key value NX</span><br></pre></td></tr></table></figure>

<p>再看看下面的指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set key value EX 10 NX; &#x2F;&#x2F;插入一个 k-v 数据，只有key不存在的时候才能插入成功，插入成功好，10s 内数据有效，10s 后数据失效将被删除</span><br><span class="line">set key value PX 100 NX; &#x2F;&#x2F;插入一个 k-v 数据，只有key不存在的时候才能插入成功，插入成功好，10 毫秒内数据有效，10 毫秒后数据失效将被删除</span><br></pre></td></tr></table></figure>

<p>加入有效时间后，分布式锁不需要在每次加锁之前清除无效锁, 得到优化的分布式锁如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">def <span class="keyword">lock</span>:</span><br><span class="line">  exec: <span class="keyword">set</span> lock_key lock_value PX expire_time NX; // 这里选择时效时间单位为毫秒，增加锁有效时间的精确性</span><br><span class="line">  if result == OK :</span><br><span class="line">    return true;</span><br><span class="line">  else :</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">def <span class="keyword">unlock</span>:</span><br><span class="line">  del lock_key;</span><br></pre></td></tr></table></figure>

<p>上面的分布式锁还是没有实现可重入性， 改进如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">def <span class="keyword">lock</span>:</span><br><span class="line">  exec: <span class="keyword">set</span> lock_key biz_uniq_code PX expire_time NX; // 插入的value 是 biz_uniq_code, 可以唯一表示加锁的调用方</span><br><span class="line">  if result == OK :</span><br><span class="line">    return true;</span><br><span class="line">  else :</span><br><span class="line">    exec: get lock_key</span><br><span class="line">    if value == biz_uniq_code :</span><br><span class="line">      return true;</span><br><span class="line">    else :</span><br><span class="line">      return false;</span><br></pre></td></tr></table></figure>

<p>依赖 <code>redis</code> 实现 <code>分布式锁</code> 存在一个难以解决的问题，<code>redis</code> 不能保证数据的 <code>强一致性</code>， 因为；</p>
<h6 id="redis-集群使用异步复制"><a href="#redis-集群使用异步复制" class="headerlink" title="redis 集群使用异步复制"></a>redis 集群使用异步复制</h6><p>如果在加锁的时候 <code>redis</code> 的 <code>master</code> 宕机了，异步复制到 <code>slave</code> 失败了，加锁就失败了！</p>
<p>为了解决这个问题，<code>redis</code> 的作者提出了 <code>redLock</code></p>
<h4 id="RedLock"><a href="#RedLock" class="headerlink" title="RedLock"></a>RedLock</h4><p>这里不对 <code>RedLock</code> 进行介绍，详情见 <code>并发编程网</code> 翻译<br><a href="http://ifeve.com/redis-lock/">http://ifeve.com/redis-lock/</a></p>
<h3 id="3-依赖zookeeper-实现分布式锁"><a href="#3-依赖zookeeper-实现分布式锁" class="headerlink" title="3. 依赖zookeeper 实现分布式锁"></a>3. 依赖zookeeper 实现分布式锁</h3><p><code>ZooKeeper</code> 能被用来实现分布式锁的原因取决于他的以下几个特性：</p>
<ol>
<li><code>ZooKeeper</code> 的视图结构和 unix 系统的文件系统类似，都是采用树结构，不同的是 <code>ZooKeeper</code> 的树结构上是新定义的 <code>数据节点</code> —— <code>ZNode</code>，<code>ZNode</code> 是 <code>ZooKeeper</code> 中数据的最小单元，可以保存数据，也可以挂靠子节点；</li>
<li><code>ZooKeeper</code> 中的 <code>ZNode</code> 的类型分为 <code>持久节点</code>、 <code>临时节点</code>、 <code>顺序节点</code> 三大类型；通过组合使用可以生成四种节点：</li>
</ol>
<ol>
<li><code>持久节点</code>：是指该数据节点被创建之后，就一直存在于 <code>ZooKeeper</code> 服务器上，直到有删除操作来主动清除这个节点；</li>
<li><code>持久有序节点</code>：和 <code>持久节点</code> 的基本特性一致，不同的特性在于顺序性上；在 <code>ZooKeeper</code> 中父节点会为它的第一级节点维护一份顺序，用于记录下每个子节点创建的先后顺序。</li>
<li><code>临时节点</code>：和 <code>持久节点</code> 不同的是，临时节点的生命周期和客户端的会话相关，如果客户端会话失效了，<code>临时节点</code> 将被自动清除。</li>
<li><code>临时有序节点</code>：和 <code>临时节点</code> 的基本特性一致，不同的特性也在于顺序性上；</li>
<li><code>ZooKeeper</code> 机制规定：同一个目录下只能有一个唯一的文件名。例如：我们在 <code>Zookeeper</code> 目录一个目录下创建，两个客户端创建一个名为 <code>new_node</code> 节点，只有一个能够成功。</li>
<li><code>ZooKeeper</code> 提供 <code>Watcher</code> 机制，客户端可以在服务端注册一个 <code>Watcher</code> 监听，当服务端的一些指定事件触动了这个 <code>Watcher</code>，就会向客户端发送通知</li>
</ol>
<h4 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h4><p>依赖上述特性，我们可以在 <code>ZooKeeper</code> 的树结构上，创建一个临时节点 <code>/distribute_lock/lock</code>, 只要有一个客户端创建了节点，表示该客户端获取到了锁；<br>而其他没有获取到锁的客户端，需要到 <code>ZooKeeper</code> 的 <code>/distribute_lock</code> 节点上注册一个子节点变更的 <code>Watcher</code> 监听，以便见听到子节点的变更情况。</p>
<blockquote>
<p>— distribute_lock </br></p>
<blockquote>
<p>— lock</p>
</blockquote>
</blockquote>
<p><img src="/assets/picture/zk_simple_lock.png" alt="图片"></p>
<h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><ol>
<li>客户端执行完业务逻辑后，主动删除自己创建的临时节点；</li>
<li>客户端宕机后，<code>ZooKeeper</code> 和客户端之间的对话失效、连接断开，客户端创建的临时节点将被自动删除</li>
<li>客户端释放锁之后，其他客户端通过 <code>Watcher</code> 监控得到锁被释放的通知，而来竞争获取锁</li>
</ol>
]]></content>
      <categories>
        <category>分布式锁</category>
      </categories>
      <tags>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 中线程的状态</title>
    <url>/2020/06/26/%E6%8A%80%E6%9C%AF/java/Java%20%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<h1 id="Java-中的线程的状态"><a href="#Java-中的线程的状态" class="headerlink" title="Java 中的线程的状态"></a>Java 中的线程的状态</h1><h2 id="线程有哪些状态"><a href="#线程有哪些状态" class="headerlink" title="线程有哪些状态"></a>线程有哪些状态</h2><p>在 JDK 源码中，我们可以看到 <code>java.lang.Thread.State</code> 定义了 <code>Thread</code> 的五种状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">         * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">         * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">         * such as processor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">         * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">         * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">         * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">         * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">         * following methods:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">         * perform a particular action.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">         * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">         * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">         * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">         * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">         * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">         * The thread has completed execution.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>NEW<br>  线程刚刚被启动，还没有被执行的状态</p>
</li>
<li><p>RUNNABLE<br>  线程达到了可执行状态，也就是说线程可以被 JVM 执行，但是还需要操作系统分配执行资源，例如处理器</p>
</li>
<li><p>BLOCKED<br>  线程处于阻塞状态，等待获取到一个内置锁(<code>monitor lock</code> or <code>intrinsic lock</code>); 等待获取一个内置锁进入 <code>sychronized</code> 修饰的同步代码块或者同步方法；或者在当前线程调用了 <code>Object#wait</code> 方法之后等待重入同步代码块或者同步方法</p>
</li>
<li><p>WAITING<br>  线程处于等待状态，在下面这些方法被调用之后，线程在这个状态下，只有等待另外一个线程进行指定操作之后才会被唤醒</p>
<ul>
<li><code>Object#wait()</code> 方法，没有 timeout 参数</li>
<li><code>Thread#join()</code> 方法，没有 timeout 参数</li>
<li><code>LockSupport#park()</code>  方法，没有 timeout 参数</li>
</ul>
</li>
<li><p>TIMED_WAITING<br>  线程处于指定了等待时长的等待状态，在下面这些方法被调用之后，线程在这个状态下，只有等待另外一个线程进行指定操作之后才会被唤醒</p>
<ul>
<li><code>Thread#sleep</code> 方法，指定了 timeout 时长</li>
<li><code>Thread#join(long)</code> 方法，指定了 timeout 时长</li>
<li><code>Object#wait(long)</code> 方法，指定了 timeout 时长</li>
<li><code>LockSupport#parkNanos</code> 方法，指定了 timeout 时长</li>
<li><code>LockSupport#parkUntil</code> 方法，指定了 timeout 时长</li>
</ul>
</li>
<li><p>TERMINATED<br> 线程达到终态，正常执行结束，或者执行过程中遇到了异常而结束了</p>
<pre><code>         除了上述状态之外，线程还有个状态，就是 RUNNING(运行中)，但是 JDK 并没有提供这样一个状态，主要是因为 RUNNING 状态是个瞬时状态；JRE 很难快捷的区分出 RUNNING 和 RUNNABLE 状态</code></pre>
</li>
</ul>
<h2 id="线程的状态是如何流转的？"><a href="#线程的状态是如何流转的？" class="headerlink" title="线程的状态是如何流转的？"></a>线程的状态是如何流转的？</h2><p>状态流转情况如图</p>
<p><img src="/assets/picture/thread.state.flow.png" alt="线程状态流转图" title="线程状态流转图"></p>
<h2 id="线程的状态的流转是怎么触发的？"><a href="#线程的状态的流转是怎么触发的？" class="headerlink" title="线程的状态的流转是怎么触发的？"></a>线程的状态的流转是怎么触发的？</h2><h3 id="Object-中控制线程状态流转相关的方法"><a href="#Object-中控制线程状态流转相关的方法" class="headerlink" title="Object 中控制线程状态流转相关的方法"></a>Object 中控制线程状态流转相关的方法</h3><h4 id="Object-中让线程进入等待状态-WAIING-TIME-WAITING-的方法"><a href="#Object-中让线程进入等待状态-WAIING-TIME-WAITING-的方法" class="headerlink" title="Object 中让线程进入等待状态(WAIING, TIME_WAITING)的方法"></a>Object 中让线程进入等待状态(WAIING, TIME_WAITING)的方法</h4><ul>
<li>java.lang.Object#wait(): 让当前线程一直等待</li>
<li>java.lang.Object#wait(long timeout): 让当前线程等待指定时长，单位毫秒</li>
<li>java.lang.Object#wait(long timeout, int nanos): 让当前线程等待指定时长，timeout 单位毫秒, nonas 为补充字段，设置等待的纳秒数</li>
</ul>
<h4 id="Object-中让线程退出等待状态的方法"><a href="#Object-中让线程退出等待状态的方法" class="headerlink" title="Object 中让线程退出等待状态的方法"></a>Object 中让线程退出等待状态的方法</h4><ul>
<li>java.lang.Object#notify(): 唤醒等待当前对象的内置锁的一个线程</li>
<li>java.lang.Object#notifyAll(): 唤醒所有等待状态的线程</li>
</ul>
<h3 id="Thread-中控制线程状态流转相关的方法"><a href="#Thread-中控制线程状态流转相关的方法" class="headerlink" title="Thread 中控制线程状态流转相关的方法"></a>Thread 中控制线程状态流转相关的方法</h3><h4 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread#join"></a>Thread#join</h4><ul>
<li>java.lang.Thread#join(): 让线程进入无限等待状态，等待线程死亡</li>
<li>java.lang.Thread#join(long millis): 让线程进入无限等待状态，等待线程死亡，指定等待时间</li>
<li>java.lang.Thread#join(long millis, int nanos): 让线程进入无限等待状态，等待线程死亡，指定等待时间, timeout 单位毫秒, nonas 为补充字段，设置等待的纳秒数</li>
</ul>
<p>在 <code>Thread#join</code> 的核心实现中，还是通过调用 <code>Object#wait</code> 方法使得线程进入等待状态（<code>TIME_WAITING</code>, <code>WAITING</code>），等待线程死亡</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123; <span class="comment">// 不断调用 Object#wait 方法</span></span><br><span class="line">            wait(<span class="number">0</span>);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Thread-sleep"><a href="#Thread-sleep" class="headerlink" title="Thread#sleep"></a><code>Thread#sleep</code></h4><p><code>Thread#sleep</code> 方法会使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行），具体取决于系统定时器和调度程序的精度和准确性。<br>但是线程会继续持有内置锁</p>
<ul>
<li>java.lang.Thread#sleep(long): 让线程休眠指定时长，单位毫秒</li>
<li>java.lang.Thread#sleep(long, int): 让线程休眠指定时间，, timeout 单位毫秒, nonas 为补充字段，设置休眠的纳秒数</li>
</ul>
<h4 id="Thread-start"><a href="#Thread-start" class="headerlink" title="Thread#start"></a><code>Thread#start</code></h4><p>线程开始执行的入口方法，JVM 会去调度线程的 <code>run()</code> 方法</p>
<h4 id="Thread-run"><a href="#Thread-run" class="headerlink" title="Thread#run"></a><code>Thread#run</code></h4><p>调用 Runnable 接口中的 <code>run()</code> 方法，Thread 的子类必须覆写这个方法</p>
<h4 id="Thread-yield"><a href="#Thread-yield" class="headerlink" title="Thread#yield"></a><code>Thread#yield</code></h4><p>告知调度器，当前线程愿意放弃处理器资源，让线程从 <code>RUNNING</code> 状态流转到 <code>RUNNABLE</code> 状态，调度器也可以忽略这个通知</p>
<h4 id="线程的中断"><a href="#线程的中断" class="headerlink" title="线程的中断"></a>线程的中断</h4><p>线程中断相关的方法有三个</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>方法描述</th>
</tr>
</thead>
<tbody><tr>
<td>interrupt</td>
<td>将线程标记为中断</td>
</tr>
<tr>
<td>isInterrupt</td>
<td>测试线程是否标记为中断的</td>
</tr>
<tr>
<td>interrupted</td>
<td>将线程的中断标记清空</td>
</tr>
</tbody></table>
<h5 id="Thread-interrupt-方法"><a href="#Thread-interrupt-方法" class="headerlink" title="Thread#interrupt 方法"></a>Thread#interrupt 方法</h5><p>我们先看看方法上的说明文档：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Interrupts this thread.</span><br><span class="line"></span><br><span class="line">Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this</span><br><span class="line">thread is invoked, which may cause a SecurityException to be thrown.</span><br><span class="line"></span><br><span class="line">If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the </span><br><span class="line">Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of</span><br><span class="line">this class, then its interrupt status will be cleared and it will receive an InterruptedException.</span><br><span class="line"></span><br><span class="line">If this thread is blocked in an I/O operation upon an InterruptibleChannel then the channel will be closed,</span><br><span class="line">the thread&#x27;s interrupt status will be set, and the thread will receive a</span><br><span class="line">java.nio.channels.ClosedByInterruptException.</span><br><span class="line"></span><br><span class="line">If this thread is blocked in a java.nio.channels.Selector then the thread&#x27;s interrupt status will be set</span><br><span class="line">and it will return immediately from the selection operation, possibly with a non-zero value, just as if </span><br><span class="line">the selector&#x27;s wakeup method were invoked.</span><br><span class="line"></span><br><span class="line">If none of the previous conditions hold then this thread&#x27;s interrupt status will be set.</span><br><span class="line"></span><br><span class="line">Interrupting a thread that is not alive need not have any effect.</span><br><span class="line">------------------------------------------------------------------------------------------------------</span><br><span class="line">中断这个线程。</span><br><span class="line"></span><br><span class="line">当前线程中断自身的时候，始终被允许，否则 checkAccess 方法会被调用，可能会抛出 SecurityException 异常；   </span><br><span class="line"></span><br><span class="line">1) 当前线程在被调动 Thread#sleep、Thread#join 或者 Object#wait 方法后处于阻塞状态，此时中断这个线程的时候，</span><br><span class="line">它的中断状态会被清除，线程会接收到一个 InterruptedException；</span><br><span class="line"></span><br><span class="line">2) 如果该线程阻塞在一个操作可中断的通道 InterruptibleChannel 的 I/O 操作上，这个通道将被关闭，该线程的中断</span><br><span class="line">状态也会被标记，该线程也会接收到一个 java.nio.channels.ClosedByInterruptException 异常；</span><br><span class="line"></span><br><span class="line">3）如果线程在 java.nio.channels.Selector 中被阻塞，线程的中断状态被标记，并且理解从选择操作中返回，可能是一个</span><br><span class="line">非 0 的数值，就像 selector 的 wakeup 方法被调用</span><br><span class="line"></span><br><span class="line">4）如果该线程不满足上述所有条件，仅标记线程的中断标识，不对线程造成其他影响</span><br><span class="line"></span><br><span class="line">5）中断一个不存在的线程，将不会产生任何效果</span><br></pre></td></tr></table></figure>

<h6 id="中断一个正在运行的普通线程"><a href="#中断一个正在运行的普通线程" class="headerlink" title="中断一个正在运行的普通线程"></a>中断一个正在运行的普通线程</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunningThread());</span><br><span class="line">    thread1.start();</span><br><span class="line"></span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">    thread1.interrupt();</span><br><span class="line">    System.out.println(<span class="string">&quot;RunningThread.isInterrupted: &quot;</span> + thread1.isInterrupted());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunningThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<pre><code>            RunningThread.isInterrupted: true</code></pre>
<p>这里我们可以看到，主程序没有退出，线程一直在运行，只有线程的中断标识被标记了</p>
<h6 id="中断一个处于等待状态-TIME-WAITNG-WAITING-的线程"><a href="#中断一个处于等待状态-TIME-WAITNG-WAITING-的线程" class="headerlink" title="中断一个处于等待状态(TIME_WAITNG, WAITING)的线程"></a>中断一个处于等待状态(<code>TIME_WAITNG</code>, <code>WAITING</code>)的线程</h6><ul>
<li>中断调用了 <code>Thread#sleep</code> 方法的线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SleepingThread());</span><br><span class="line">    thread2.start();</span><br><span class="line"></span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">    thread2.interrupt();</span><br><span class="line">    System.out.println(<span class="string">&quot;SleepingThread.isInterrupted: &quot;</span> + thread2.isInterrupted());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepingThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          TimeUnit.SECONDS.sleep(<span class="number">30</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;do sth for InterruptedException...&quot;</span>);</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<pre><code>            SleepingThread.isInterrupted: false
            do sth for InterruptedException...
            java.lang.InterruptedException: sleep interrupted
                at java.lang.Thread.sleep(Native Method)
                at java.lang.Thread.sleep(Thread.java:340)
                at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)
                at com.liam.learn.interruptdemo.InterruptDemo$SleepingThread.run(InterruptDemo.java:40)
                at java.lang.Thread.run(Thread.java:748)</code></pre>
<p>从结果可以看出，这个一直调用 <code>Thread#sleep</code> 方法的线程调用了 <code>interrupt</code> 方法之后，接收到了 <code>InterruptedException</code> 异常，但是线程的中断标志位并没有被表示为已中断，但是我们可以在线程中捕获 <code>InterruptedException</code> 并根据这个信息作出应对操作。</p>
<ul>
<li>中断了调用了 <code>Object#wait</code> 方法的线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> WaitingThread(lock));</span><br><span class="line">    thread3.start();</span><br><span class="line"></span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">    thread3.interrupt();</span><br><span class="line">    System.out.println(<span class="string">&quot;WaitingThread.isInterrupted: &quot;</span> + thread3.isInterrupted());</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitingThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object lock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaitingThread</span><span class="params">(Object lock)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          lock.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;do sth for InterruptedException...&quot;</span>);</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果是：</p>
<pre><code>            do sth for InterruptedException...
            WaitingThread.isInterrupted: false
            java.lang.InterruptedException
                at java.lang.Object.wait(Native Method)
                at java.lang.Object.wait(Object.java:502)
                at com.liam.learn.interruptdemo.InterruptDemo$WaitingThread.run(InterruptDemo.java:70)
                at java.lang.Thread.run(Thread.java:748)

            Process finished with exit code 0</code></pre>
<ul>
<li>中断调用了 <code>Thread#join</code> 方法的线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread4 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> JoiningThread());</span><br><span class="line">    thread4.start();</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">    thread4.interrupt();</span><br><span class="line">    System.out.println(<span class="string">&quot;JoiningThread.isInterrupted: &quot;</span> + thread4.isInterrupted());</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JoiningThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;do sth for InterruptedException...&quot;</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果是</p>
<pre><code>            do sth for InterruptedException...
            JoiningThread.isInterrupted: false
            java.lang.InterruptedException
                at java.lang.Object.wait(Native Method)
                at java.lang.Thread.join(Thread.java:1252)
                at java.lang.Thread.join(Thread.java:1326)
                at com.liam.learn.interruptdemo.InterruptDemo$JoiningThread.run(InterruptDemo.java:91)
                at java.lang.Thread.run(Thread.java:748)</code></pre>
<p>调用 <code>Object#wait</code>、<code>Thread#join</code> 方法的线程和调用了 <code>Thread#sleep</code> 方法的线程被调用了 <code>interrupt</code> 方法的结果是一样的，都不会被标记为中断，都会接收到 <code>InterruptedException</code></p>
<h5 id="中断机制的实现"><a href="#中断机制的实现" class="headerlink" title="中断机制的实现"></a>中断机制的实现</h5><p><code>Thread#interrupt</code> 方法的实现如下，通过调用一个 native 方法去修改线程的中断标识，将线程标记位中断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">interrupt0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>而 <code>interrupt0</code> 的实现我们可以在 <a href="https://github.com/openjdk/jdk" title="OpenJDK">openjdk</a> 源码中找到</p>
<p>首先是 <code>Thread.c</code> 中定义了 native 方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;start0&quot;</span>,           <span class="string">&quot;()V&quot;</span>,        (<span class="keyword">void</span> *)&amp;JVM_StartThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;stop0&quot;</span>,            <span class="string">&quot;(&quot;</span> OBJ <span class="string">&quot;)V&quot;</span>, (<span class="keyword">void</span> *)&amp;JVM_StopThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;isAlive&quot;</span>,          <span class="string">&quot;()Z&quot;</span>,        (<span class="keyword">void</span> *)&amp;JVM_IsThreadAlive&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;suspend0&quot;</span>,         <span class="string">&quot;()V&quot;</span>,        (<span class="keyword">void</span> *)&amp;JVM_SuspendThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;resume0&quot;</span>,          <span class="string">&quot;()V&quot;</span>,        (<span class="keyword">void</span> *)&amp;JVM_ResumeThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;setPriority0&quot;</span>,     <span class="string">&quot;(I)V&quot;</span>,       (<span class="keyword">void</span> *)&amp;JVM_SetThreadPriority&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;yield&quot;</span>,            <span class="string">&quot;()V&quot;</span>,        (<span class="keyword">void</span> *)&amp;JVM_Yield&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;sleep&quot;</span>,            <span class="string">&quot;(J)V&quot;</span>,       (<span class="keyword">void</span> *)&amp;JVM_Sleep&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;currentThread&quot;</span>,    <span class="string">&quot;()&quot;</span> THD,     (<span class="keyword">void</span> *)&amp;JVM_CurrentThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;interrupt0&quot;</span>,       <span class="string">&quot;()V&quot;</span>,        (<span class="keyword">void</span> *)&amp;JVM_Interrupt&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;holdsLock&quot;</span>,        <span class="string">&quot;(&quot;</span> OBJ <span class="string">&quot;)Z&quot;</span>, (<span class="keyword">void</span> *)&amp;JVM_HoldsLock&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;getThreads&quot;</span>,        <span class="string">&quot;()[&quot;</span> THD,   (<span class="keyword">void</span> *)&amp;JVM_GetAllThreads&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;dumpThreads&quot;</span>,      <span class="string">&quot;([&quot;</span> THD <span class="string">&quot;)[[&quot;</span> STE, (<span class="keyword">void</span> *)&amp;JVM_DumpThreads&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;setNativeName&quot;</span>,    <span class="string">&quot;(&quot;</span> STR <span class="string">&quot;)V&quot;</span>, (<span class="keyword">void</span> *)&amp;JVM_SetNativeThreadName&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而 <code>JVM_Interrupt</code> 方法的是实现是在 <code>jvm.cpp</code> 中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_Interrupt(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(<span class="string">&quot;JVM_Interrupt&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function">ThreadsListHandle <span class="title">tlh</span><span class="params">(thread)</span></span>;</span><br><span class="line">  JavaThread* receiver = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">bool</span> is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (is_alive) &#123;</span><br><span class="line">    <span class="comment">// jthread refers to a live JavaThread.</span></span><br><span class="line">    receiver-&gt;interrupt();</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure>

<p>而 <code>JavaThread::interrupt</code> 的实现是 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interrupt support</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JavaThread::interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  debug_only(check_for_dangling_thread_pointer(<span class="keyword">this</span>);)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For Windows _interrupt_event</span></span><br><span class="line">  osthread()-&gt;set_interrupted(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For Thread.sleep</span></span><br><span class="line">  _SleepEvent-&gt;unpark();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For JSR166 LockSupport.park</span></span><br><span class="line">  parker()-&gt;unpark();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For ObjectMonitor and JvmtiRawMonitor</span></span><br><span class="line">  _ParkEvent-&gt;unpark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 JVM 将线程的中断标识标记为中断</p>
<h2 id="关于线程状态的一些常见问题"><a href="#关于线程状态的一些常见问题" class="headerlink" title="关于线程状态的一些常见问题"></a>关于线程状态的一些常见问题</h2><ol>
<li><p><code>sleep</code> 和 <code>wait</code> 方法的区别是什么？</p>
<pre><code> Thread#sleep 只会让线程进入休眠状态，但是不会放弃已经获得的内置锁；
 而 Object#wait 方法不仅会让线程进入等待状态，还会让线程释放内置锁</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>J.U.C 包中的工具类</title>
    <url>/2020/06/26/%E6%8A%80%E6%9C%AF/java/%E9%87%8D%E8%AF%BBJava%20%E6%BA%90%E7%A0%81%20%E2%80%94%E2%80%94%20J.U.C%20%E4%B8%AD%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="J-U-C-包中的工具类"><a href="#J-U-C-包中的工具类" class="headerlink" title="J.U.C 包中的工具类"></a>J.U.C 包中的工具类</h1><h2 id="atomic-包中的支持原子操作的类"><a href="#atomic-包中的支持原子操作的类" class="headerlink" title="atomic 包中的支持原子操作的类"></a>atomic 包中的支持原子操作的类</h2><p>在 Java 中 i++ 这种数字的自增操作不是原子性操作， i ++ 本质上是三个操作，获得当前变量的值，对当前值进行加一，再写回新的值；在没有额外资源可以使用的情况下，只有操作才能保证 <code>读-改-写</code> 操作的原子性，为了解决这种问题，j.u.c 提供了 atomic 包，其中包含了多种类型的具有原子性的工具类</p>
<h3 id="从-AtomicInteger-开始看-Atomic-工具类"><a href="#从-AtomicInteger-开始看-Atomic-工具类" class="headerlink" title="从 AtomicInteger 开始看 Atomic 工具类"></a>从 AtomicInteger 开始看 Atomic 工具类</h3><p>首先我们可以看看 <code>AtomicInteger</code>，其他的 Atomic 工具类的实现也和 <code>AtomicInteger</code> 类似，首先看看 <code>AtomicInteger</code> 的方法和属性</p>
<p><img src="/assets/picture/atomic.integer.method.list.jpg" title="AtomicInteger 的方法及属性"></p>
<p>这里首先看看和 i ++ 功能一致的方法 <code>incrementAndGet()</code>，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码可以看到，这里主要是依赖 <code>Unsafe</code> 这个底层工具类，从下面的代码可以看出，这里通过 <code>Unsafe</code> 提供的 <code>CAS</code> 实现了原子性操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var5;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">  &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他方法也和 <code>incrementAndGet()</code> 方法类似，都是依赖 <code>Unsafe</code> 提供的 <code>native</code> 的 <code>CAS</code> 方法实现的原子性操作；</p>
<p>除了 <code>AtomicInteger</code> 之外， <code>j.u.c</code> 还提供了 <code>AtomicIntegerArray</code>、<code>AtomicLong</code>、<code>AtomicLongArrray</code>、<code>AtomicBoolean</code>、<code>AtomicReference</code>、<code>AtomicReferenceArray</code>，可以对 int[]、long、long[]、boolean、T、T[] 等类型的数据进行原子性修改， 主要方法有：</p>
<ul>
<li>数字类型相关的方法:<ul>
<li>getAndIncrement</li>
<li>getAndDecrement</li>
<li>incrementAndGet</li>
<li>decrementAndGet</li>
<li>addAndGet</li>
<li>getAndAdd</li>
</ul>
</li>
<li>原子性工具类通用方法<ul>
<li>accumulateAndGet: 通过 accumulatorFunction自定义加和逻辑，对当前数据和参数进行加和，先加和再返回值</li>
<li>compareAndSet</li>
<li>getAndAccumulate: 通过 accumulatorFunction自定义加和逻辑，对当前数据和参数进行加和，返回加和前的值</li>
<li>getAndSet</li>
<li>getAndUpdate</li>
<li>updateAndGet</li>
<li>weakCompareAndSet</li>
</ul>
</li>
</ul>
<h3 id="Atomic-工具类的-ABA-问题及如何解决"><a href="#Atomic-工具类的-ABA-问题及如何解决" class="headerlink" title="Atomic 工具类的 ABA 问题及如何解决"></a>Atomic 工具类的 ABA 问题及如何解决</h3><p><code>AtomicInteger</code> 等工具类有一个问题，就是当 <code>AtomicInteger</code> 的值从 1 改为2 再从2 改为1 的时候，两次读取 <code>AtomicInteger</code> 的值都是 1 的情况下，无法确定 <code>AtomicInteger</code> 的值在两次查询之间是否被修改过，解决这个问题的思路也很简单，再加一个版本属性每次操作的时候，版本递增；或者新增一个时间戳字段，每次修改记录时间戳，JDK 采用的是方法二，提供了工具类 <code>AtomicStampedReference&lt;V&gt;</code>，它将需要被原子操作的属性 <code>reference</code> 和 int 类型的时间戳封装成 <code>Pair</code>，再对 <code>Pair</code> 进行 CAS 操作保证原子性</p>
<h3 id="Atomic-工具类的自旋性能问题"><a href="#Atomic-工具类的自旋性能问题" class="headerlink" title="Atomic 工具类的自旋性能问题"></a>Atomic 工具类的自旋性能问题</h3><p>AtomicInteger 等工具类利用 <code>Unsafe</code> 提供的 <code>CAS</code> 操作实现了在不加锁的情况下保证原子性操作，但是部分操作再单次 <code>CAS</code> 操作选择使用 while 循环实现自旋直至成功，如 <code>sun.misc.Unsafe#getAndAddInt</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var5;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">  &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法在高并发的情况下，多个线程同时执行 <code>CAS</code> 的且多次失败的情况下，每个线程都在自旋占用 CPU 资源；<code>Doug Lea</code> 大神也发现了这个问题，所以在 <code>JDK1.8</code> 中新增了 <code>LongAdder</code>、<code>LongAccumulator</code>、<code>DoubleAdder</code>、<code>DoubleAccumulator</code> 工具类</p>
<h4 id="LongAdder-等工具类分段操作降低竞争热度"><a href="#LongAdder-等工具类分段操作降低竞争热度" class="headerlink" title="LongAdder 等工具类分段操作降低竞争热度"></a>LongAdder 等工具类分段操作降低竞争热度</h4><p>这里对 <code>LongAdder</code> 的实现进行一个简单的分析，其他工具类和它的实现思路是基本一样的；</p>
<p><img src="/assets/picture/LongAdder.method.list.jpg" title="LongAdder 的方法列表"></p>
<p><code>LongAdder</code> 提供的方法列表中仅提供了单个操作接口，没有提供 <code>AtomicInteger</code> 等工具类中的 <code>getAndIncrement()</code> 或者 <code>incrementAndGet()</code> 这种复合的原子操作接口，通过 <code>increment()</code> 和 <code>longValue()</code> 组合实现，但是不具有原子性，这也是 <code>LongAdder</code> 区别于 <code>AtomicInteger</code> 等工具类的不足；</p>
<p>下面来看看 <code>LongAdder</code> 中的主要方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAdder</span> <span class="keyword">extends</span> <span class="title">Striped64</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Equivalent to &#123;<span class="doctag">@code</span> add(1)&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        add(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Equivalent to &#123;<span class="doctag">@code</span> add(-1)&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        add(-<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到，<code>increment()</code> 和 <code>decrement()</code> 方法的试下都是基于 <code>add(long x)</code> 方法，下面来看看 <code>add(long x)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the given value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x the value to add</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>add</code> 方法首先会尝试调用 <code>casBase</code> 方法，<code>casBase</code> 方法是父类 <code>Striped64</code> 中的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CASes the base field.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">casBase</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, BASE, cmp, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它也是使用 <code>Unsafe</code> 中的 <code>CAS</code> 方法，实现原子性操作，但是这里只会尝试一次 <code>CAS</code> 操作，失败之后就会进入下一步；在下一步操作中，首先是将变量 <code>uncontended</code> 变量置为 ture，从名字就可以看出来这个变量是标识没有竞争，下面的逻辑就是判断是否存在多线程竞争了；</p>
<p>下面的判断条件都是或逻辑</p>
<ul>
<li>as == null ?  ——— 如果当前的 cells 为 null，则进入下一步 <code>longAccumulate</code> 方法</li>
<li>(m = as.length - 1) &lt; 0 ？———— 当前的 cells 是否为空，为空时直接进入下一步 <code>longAccumulate</code> 方法</li>
<li>a = as[getProbe() &amp; m]) == null || !(uncontended = a.cas(v = a.value, v + x)<br>这一步稍微负责一点，首先通过 <code>getProbe()</code> 方法获取当前线程的 hash 标识，<code>getProbe()</code> 方法是从 <code>ThreadLocalRandom</code> 中复制来的获取线程的hash 标识的方法，通过 <code>getProbe() &amp; m</code> 来为当前线程获取 Cell，如果获取成功则对这个 Cell 段进行 CAS 操作；再根据CAS 操作成功则表示当前不存在多线程竞争，直接退出，否则则进入下一步 <code>longAccumulate</code>方法；如果当前线程的 hash 标识映射到的 Cell 段为空，也会进入下一步 <code>longAccumulate</code> 方法；</li>
</ul>
<p>上面的逻辑中出现了属性 <code>cells</code>，以及 <code>casBase</code> 方法中操作的属性 <code>base</code>， 这两个属性都来自 <code>LongAdder</code> 的父类 <code>Striped64</code>，<code>Striped64</code> 中定义了 <code>Cell</code> 段并管理了一组 <code>Cell</code> 段的数组和一个简单的 long 值；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Striped64</span> <span class="keyword">extends</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">  <span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    Cell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cas</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">          Class&lt;?&gt; ak = Cell.class;</span><br><span class="line">          valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">              (ak.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Table of cells. When non-null, size is a power of 2.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Base value, used mainly when there is no contention, but also as</span></span><br><span class="line"><span class="comment">  * a fallback during table initialization races. Updated via CAS.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出 <code>Cell</code> 可以视为删减版的 <code>AtomicInteger</code>，它维护了个 long 类型的值，并提供了基于 <code>Unsafe</code> 的 <code>cas</code> 方法；<code>Striped64</code> 维护了一组 <code>Cell</code> 数组和一个 long 值，没有多线程竞争的情况下对 long 值进行修改，出现了多线程竞争的情况下，为线程匹配一个 <code>Cell</code> 段，对 <code>Cell</code> 段维护的数值进行修改，最后获取值的时候在对 <code>base</code> 和 <code>Cell[]</code> 中的数值进行求和；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="keyword">long</span> sum = base;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的逻辑可以简单分析出，<code>LongAdder</code> 的思路就是线程竞争不充分的时候，和 AtomicInteger 类似对单个值进行 CAS 操作的竞争，不同点在于不会自旋等待；在多线程情况下从多个线程自旋竞争同一个字段的 <code>CAS</code> 操作，优化为多个线程自旋竞争多个字段的 <code>CAS</code> 操作，而线程和 <code>Cell</code> 端的映射通过线程的 hash 标识进行再次hash 映射；而最后需要获取只的时候，需要对所有 <code>Cell</code> 中的数值以及 <code>base</code> 进行加和即可；唯一的不足是占用的内存空间更多了一点，但是在多线程高并发的情况下能提高效率，这点空间的占用也不算什么了；而且在线程竞争不激烈的情况下还是只使用了单个数值；</p>
<p>这里可以简单总结一下 <strong><em>低并发的时候 <code>AtomicInteger</code> 等工具类的性能和 <code>LongAdder</code> 的性能差不多；高并发的情况下，<code>LongAdder</code> 明显更高效</em></strong></p>
<p>下面还是会继续分析一下 <code>longAccumulate</code> 方法的逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> h;</span><br><span class="line">  <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">    ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">    h = getProbe();</span><br><span class="line">    wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Cell[] as; Cell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Try to attach new Cell</span></span><br><span class="line">          Cell r = <span class="keyword">new</span> Cell(x);   <span class="comment">// Optimistically create</span></span><br><span class="line">          <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">              Cell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">              <span class="keyword">if</span> ((rs = cells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                rs[j] = r;</span><br><span class="line">                created = <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (created)</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        collide = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">        collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">        collide = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (cells == as) &#123;      <span class="comment">// Expand table unless stale</span></span><br><span class="line">            Cell[] rs = <span class="keyword">new</span> Cell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                rs[i] = as[i];</span><br><span class="line">            cells = rs;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            cellsBusy = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        collide = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">      &#125;</span><br><span class="line">      h = advanceProbe(h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">      <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">        <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">          Cell[] rs = <span class="keyword">new</span> Cell[<span class="number">2</span>];</span><br><span class="line">          rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> Cell(x);</span><br><span class="line">          cells = rs;</span><br><span class="line">          init = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        cellsBusy = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (init)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">      <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法比较长，逐步拆分看看</p>
<ul>
<li>首先如果当前线程的 hash 标识没有初始化则进行初始化，并且将 wasUncontented 置为 true，表示当前没有竞争</li>
<li>接下来是个自旋死循环，保证 CAS 更新成功</li>
<li>循环中首先如果 <code>cells</code> 不为空 <ul>
<li>如果线程映射到的 <code>Cell</code> 为 null 且 <code>cellsBusy</code> 标识位标识 <code>cells</code> 不是在调整大小或者新建 <code>Cell</code> 的时候，尝试创建一个新的 <code>Cell</code>，加入到数据中</li>
<li>如果线程映射到的 <code>Cell</code> 不为 null，则进行一次 <code>CAS</code> 尝试，成功了则返回</li>
<li>如果 <code>cellsBusy</code> 标识了 <code>cells</code> 没有被操作，而且 <code>cells</code> 满了之后，对 <code>cells</code> 进行扩容，每次扩大两倍，然后进入下一次循环</li>
</ul>
</li>
<li>如果 <code>cells</code> 为空而且成功将 <code>cellsBusy</code> 标识位置为 true 的时候，对 cells 初始化，长度为2，并且为当前现在映射的下标位置填充一个 <code>Cell</code></li>
</ul>
<p>上边的流程分析中始终多次出现了 <code>cellsBusy</code>，这个字段用于标识 <code>cells</code> 数组是否在调整大小或者被创建中，并且提供了 <code>CAS</code> 方法对这个标志位进行修改</p>
<pre><code>    总结一下，需要进行原子性数据统计的时候，推荐使用 LongAdder 等代替 AtomicLong, 《阿里巴巴 Java 开发手册》 中也推荐使用 LongAdder</code></pre>
<p><img src="/assets/picture/alibaba.java.guide.suggestion.LongAdder.jpg" title="《阿里巴巴开发规范》推荐使用 LongAdder"></p>
<h2 id="CountDownLatch-锁存器"><a href="#CountDownLatch-锁存器" class="headerlink" title="CountDownLatch(锁存器)"></a>CountDownLatch(锁存器)</h2><p><code>CountDownLatch</code> 工具类的作用，从注解中就能看出来</p>
<pre><code>    A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.
    一个同步辅助工具类，允许一个或多个线程等待其他线程中一组操作完成后再进行其他操作。</code></pre>
<p>下面看看方法列表</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>返回值</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>CountDownLatch(int)</td>
<td>CountDownLatch</td>
<td>构造方法，构造一个锁存器，并指定计数值</td>
</tr>
<tr>
<td>countDown()</td>
<td>void</td>
<td>对锁存器的计数值进行递减，线程安全，如果计数值减到了 0 则释放所有等待的线程</td>
</tr>
<tr>
<td>await() throws InterruptedException</td>
<td>void</td>
<td>阻塞当前线程进入等待状态，直至锁存器的计数值达到零，除非当前线程被中断</td>
</tr>
<tr>
<td>await(long timeout, TimeUnit unit) throws InterruptedException</td>
<td>boolean, 锁存器减为0 时返回 true，如果超过指定时间计数值没有减为0 返回 false</td>
<td>阻塞当前线程进入等待状态，直至锁存器的计数值达到零，除非线程被中断或者超过了指定的等待时间</td>
</tr>
<tr>
<td>getCount()</td>
<td>long</td>
<td>返回锁存器的计数值</td>
</tr>
</tbody></table>
<p>从上面的方法列表可以看出，<code>CountDownLatch(锁存器)</code> 维护了一个计数值，可以让当前线程阻塞等待，直到计数值减为 0，这个数值也就是需要等待的线程的数量；通过这个同步工具类可以做到让一个或一组线程等待其他线程完成之后再进行下一步的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> threadCount = <span class="number">5</span>;</span><br><span class="line">    CountDownLatch waitSignal = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> WaitedTask(<span class="string">&quot;waited-thread-&quot;</span> + i, waitSignal)).start();</span><br><span class="line">    &#125;</span><br><span class="line">    waitSignal.await();</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程等待其他线程执行完毕后, 执行后续动作&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitedTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    WaitedTask(String name, CountDownLatch countDownLatch) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程 &quot;</span> + name + <span class="string">&quot; 开始执行操作&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> timeVal = ThreadLocalRandom.current().nextInt(<span class="number">5</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(timeVal);</span><br><span class="line">        System.out.println(<span class="string">&quot;线程 &quot;</span> + name + <span class="string">&quot; 操作完成, 达到等待点&quot;</span>);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>    线程 waited-thread-0 开始执行操作
    线程 waited-thread-2 开始执行操作
    线程 waited-thread-1 开始执行操作
    线程 waited-thread-3 开始执行操作
    线程 waited-thread-4 开始执行操作
    线程 waited-thread-0 操作完成, 达到等待点
    线程 waited-thread-4 操作完成, 达到等待点
    线程 waited-thread-3 操作完成, 达到等待点
    线程 waited-thread-2 操作完成, 达到等待点
    线程 waited-thread-1 操作完成, 达到等待点
    主线程等待其他线程执行完毕后, 执行后续动作

    Process finished with exit code 0</code></pre>
<p>在上面这个简单的示例中我们能看到正常情况下，<code>CountDownLatch</code> 可以做到让主线程等待一组线程完成一系列操作，但是这里也会有一个问题，假设这一组线程中有一个线程执行过程中出现了异常，程序还能继续执行吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitedTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">  WaitedTask(String name, CountDownLatch countDownLatch) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;线程 &quot;</span> + name + <span class="string">&quot; 开始执行操作&quot;</span>);</span><br><span class="line">      <span class="keyword">int</span> timeVal = ThreadLocalRandom.current().nextInt(<span class="number">5</span>);</span><br><span class="line">      TimeUnit.SECONDS.sleep(timeVal);</span><br><span class="line">      <span class="keyword">if</span> (name.contains(<span class="string">&quot;3&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;一个用于测试的异常...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;线程 &quot;</span> + name + <span class="string">&quot; 操作完成, 达到等待点&quot;</span>);</span><br><span class="line">      countDownLatch.countDown();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里简单模拟一个抛出异常的情况，再看看执行结果~</p>
<pre><code>    线程 waited-thread-0 开始执行操作
    线程 waited-thread-2 开始执行操作
    线程 waited-thread-3 开始执行操作
    线程 waited-thread-1 开始执行操作
    线程 waited-thread-4 开始执行操作
    线程 waited-thread-4 操作完成, 达到等待点
    线程 waited-thread-0 操作完成, 达到等待点
    线程 waited-thread-1 操作完成, 达到等待点
    Exception in thread &quot;Thread-3&quot; 线程 waited-thread-2 操作完成, 达到等待点
    java.lang.IllegalStateException: 一个用于测试的异常...
      at com.liam.learn.CountDownLatchDemo$WaitedTask.run(CountDownLatchDemo.java:43)
      at java.lang.Thread.run(Thread.java:748)</code></pre>
<p>结果很遗憾，一个线程抛出异常之后，主线程陷入了阻塞等待的状态，没办法继续执行后续操作~ 因为 <code>CountDownLatch(锁存器)</code> 的计数值始终不能减为 0，<code>CountDownLatch#await()</code> 方法一直处于一个阻塞状态；</p>
<pre><code>CountDownLatch 的不足：
CountDownLatch 维护的计数值被减少后无法恢复，只能使用一次</code></pre>
<h2 id="CyclicBarrier（回环栅栏）"><a href="#CyclicBarrier（回环栅栏）" class="headerlink" title="CyclicBarrier（回环栅栏）"></a>CyclicBarrier（回环栅栏）</h2><p>还是从工具类开始看什么是 <code>CyclicBarrier(回环栅栏)</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point. </span><br><span class="line">CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other. </span><br><span class="line">The barrier is called `cyclic` because it can be re-used after the waiting threads are released.</span><br></pre></td></tr></table></figure>

<p>译文如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">CyclicBarrier 也是一个并发工具，目的在于让一组固定数量的线程相互等待，直到所有线程都到达一个栅栏点；</span><br><span class="line">栅栏之所以称为回环栅栏是因为等所有等待的线程都被释放之后，栅栏的状态将被重置</span><br></pre></td></tr></table></figure>

<p>下面看看方法列表</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>返回值</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>CyclicBarrier(int parties, Runnable barrierAction)</td>
<td>CyclicBarrier</td>
<td>构造方法，构造一个回环栅栏，并指定参与线程数量和栅栏函数，当等待跳过栅栏的线程数降为0 的时候，会触发栅栏函数的执行</td>
</tr>
<tr>
<td>CyclicBarrier(int parties)</td>
<td>CyclicBarrier</td>
<td>构造方法，构造一个回环栅栏，并指定参与线程数量，等待跳过栅栏的线程数降为0 的时候，进行后续操作</td>
</tr>
<tr>
<td>countDown()</td>
<td>void</td>
<td>对锁存器的计数值进行递减，线程安全，如果计数值减到了 0 则释放所有等待的线程</td>
</tr>
<tr>
<td>await() throws InterruptedException</td>
<td>void</td>
<td>阻塞当前线程进入等待状态，直至回环栅栏的所有参与线程都调用了此方法，或者参与栅栏的线程被阻断抛出异常</td>
</tr>
<tr>
<td>await(long timeout, TimeUnit unit) throws InterruptedException</td>
<td>void</td>
<td>阻塞当前线程进入等待状态，直至回环栅栏的所有参与线程都调用了此方法，或者参与栅栏的线程被阻断抛出异常，或者超过了指定的等待时间</td>
</tr>
<tr>
<td>getNumberWaiting()</td>
<td>int</td>
<td>获取当前正在等待跳过栅栏的参与方的数量</td>
</tr>
<tr>
<td>getParties()</td>
<td>int</td>
<td>获取需要跳过栅栏的参与方的数量</td>
</tr>
<tr>
<td>reset()</td>
<td>void</td>
<td>将栅栏置为初始化状态</td>
</tr>
</tbody></table>
<p>下面从代码示例中，我们来看看 <code>CyclicBarrier</code> 的使用场景</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> BrokenBarrierException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> threadCount = <span class="number">3</span>;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(threadCount + <span class="number">1</span>, () -&gt; System.out.println(<span class="string">&quot;所有线程都到达了等待点，可以进行下一步操作了~&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> WaitedTask(<span class="string">&quot;first-group-thread-&quot;</span> + i, cyclicBarrier)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        cyclicBarrier.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程等待第一组其他线程操作结束，执行下一步操作&quot;</span>);</span><br><span class="line">        ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();</span><br><span class="line">        <span class="keyword">int</span> randomVal = threadLocalRandom.nextInt(<span class="number">10</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(randomVal);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> WaitedTask(<span class="string">&quot;second-group-thread-&quot;</span> + i, cyclicBarrier)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        cyclicBarrier.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程等待第二组其他线程操作结束，执行下一步操作&quot;</span>);</span><br><span class="line">        randomVal = threadLocalRandom.nextInt(<span class="number">10</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(randomVal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitedTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">        WaitedTask(String name, CyclicBarrier cyclicBarrier) &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 &quot;</span> + name + <span class="string">&quot; 开始执行操作&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> timeVal = ThreadLocalRandom.current().nextInt(<span class="number">5</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(timeVal);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 &quot;</span> + name + <span class="string">&quot; 操作完成, 达到等待点&quot;</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                timeVal = ThreadLocalRandom.current().nextInt(<span class="number">5</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 &quot;</span> + name + <span class="string">&quot; 等待其他线程结束，执行其他操作~&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(timeVal);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 &quot;</span> + name + <span class="string">&quot; 执行其他操作完毕&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>    线程 first-group-thread-0 开始执行操作
    线程 first-group-thread-2 开始执行操作
    线程 first-group-thread-1 开始执行操作
    线程 first-group-thread-2 操作完成, 达到等待点
    线程 first-group-thread-1 操作完成, 达到等待点
    线程 first-group-thread-0 操作完成, 达到等待点
    所有线程都到达了等待点，可以进行下一步操作了~
    线程 first-group-thread-0 等待其他线程结束，执行其他操作~
    主线程等待第一组其他线程操作结束，执行下一步操作
    线程 first-group-thread-2 等待其他线程结束，执行其他操作~
    线程 first-group-thread-1 等待其他线程结束，执行其他操作~
    线程 first-group-thread-1 执行其他操作完毕
    线程 first-group-thread-0 执行其他操作完毕
    线程 first-group-thread-2 执行其他操作完毕
    线程 second-group-thread-0 开始执行操作
    线程 second-group-thread-0 操作完成, 达到等待点
    线程 second-group-thread-1 开始执行操作
    线程 second-group-thread-2 开始执行操作
    线程 second-group-thread-1 操作完成, 达到等待点
    线程 second-group-thread-2 操作完成, 达到等待点
    所有线程都到达了等待点，可以进行下一步操作了~
    线程 second-group-thread-2 等待其他线程结束，执行其他操作~
    主线程等待第二组其他线程操作结束，执行下一步操作
    线程 second-group-thread-0 等待其他线程结束，执行其他操作~
    线程 second-group-thread-1 等待其他线程结束，执行其他操作~
    线程 second-group-thread-1 执行其他操作完毕
    线程 second-group-thread-2 执行其他操作完毕
    线程 second-group-thread-0 执行其他操作完毕

    Process finished with exit code 0</code></pre>
<p>从上面这个例子可以看出，<code>CyclicBarrier</code> 的实例被使用了两次，都达到了让一组线程达到一个栅栏点之后再进行后续操作的目的；这里还有一个细节，在 <code>CyclicBarrier</code> 中，我们设置了 <code>barrierAction</code>，这个线程会在最后一个参与线程调用 <code>await()</code> 方法到达栅栏点之后会被触发调用，而我们创建的 <code>CyclicBarrier</code> 指定的参与线程数量是子线程数量加一，主线程也会去等待其他子线程达到栅栏点；所以如果主线程需要等待其他子线程到达栅栏点，我们可以将主线程也作为 <code>CyclicBarrier</code> 的参与线程，如果主线程不需要等待子线程达到栅栏点，可以使用 <code>barrierAction</code> 在所有子线程达到栅栏点之后进行一些操作。</p>
<h2 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore 信号量"></a>Semaphore 信号量</h2><p><code>Semaphore</code> 工具类见名知意，就是一个维护了一组信号量的工具类，它提供了 <code>acquire()</code> 方法，用于获取许可，在获取到许可之前会一致阻塞；它还提供了 <code>release()</code> 方法去释放已经获取了的许可；这些许可也只是一个计数而不是实际存在的许可对象；<code>Semaphore</code> 工具类一般用于控制一组线程对一定数量的资源的访问控制；</p>
<p>下面是方法列表</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>返回值</th>
<th>方法说明</th>
</tr>
</thead>
<tbody><tr>
<td>Semaphore(int permits)</td>
<td>Semaphore</td>
<td>构造方法，构造一个信号量工具类，permits 是许可数量，可以为负数，为负数是在获取许可之前必须先释放许可</td>
</tr>
<tr>
<td>Semaphore(int permits, boolean fair)</td>
<td>Semaphore</td>
<td>构造方法，构造一个信号量工具类；<br/>permits 是许可数量，可以为负数，为负数是在获取许可之前必须先释放许可<br/>fair 标识获取许可的任务是先进先出的公平模式，还是非公平模式</td>
</tr>
<tr>
<td>acquire() throws InterruptedException</td>
<td>void</td>
<td>获取单个信号量许可的方法，没有获取到之前一直阻塞，如果线程被中断，将抛出 java.lang.InterruptedException 异常</td>
</tr>
<tr>
<td>acquire(int permits) throws InterruptedException</td>
<td>void</td>
<td>获取信号量的一个或多个许可的方法，没有获取到之前一直阻塞，如果线程被中断，将抛出 java.lang.InterruptedException 异常</td>
</tr>
</tbody></table>
<h2 id="CompletionService"><a href="#CompletionService" class="headerlink" title="CompletionService"></a>CompletionService</h2><p>在上面讲到的并发工具类的使用的时候，我们讲到了使用 <code>CountDownLatch</code>、<code>CyclicBarrier</code>、<code>Semaphore</code> 来实现等待一组任务全完成之后的示例</p>
<h2 id="ThreadLocalRandom"><a href="#ThreadLocalRandom" class="headerlink" title="ThreadLocalRandom"></a>ThreadLocalRandom</h2><h2 id="TimeUnit"><a href="#TimeUnit" class="headerlink" title="TimeUnit"></a>TimeUnit</h2><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h3>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>J.U.C</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 中的 maven-shade-plugin 插件</title>
    <url>/2020/07/12/%E6%8A%80%E6%9C%AF/maven/Maven%20%E6%8F%92%E4%BB%B6%20shade/</url>
    <content><![CDATA[<h1 id="Maven-中的-maven-shade-plugin-插件"><a href="#Maven-中的-maven-shade-plugin-插件" class="headerlink" title="Maven 中的 maven-shade-plugin 插件"></a>Maven 中的 maven-shade-plugin 插件</h1><h2 id="maven-shade-plugin-插件有什么作用？"><a href="#maven-shade-plugin-插件有什么作用？" class="headerlink" title="maven-shade-plugin 插件有什么作用？"></a>maven-shade-plugin 插件有什么作用？</h2><p>Shade 插件的作用是将一个 maven 项目打包成一个 <code>uber-jar</code>(也成为 <code>fat-jar</code>)，并且将当前项目的依赖的部分依赖也打包进去。</p>
<ul>
<li>打包一个可运行的 <code>fat-jar</code>，支持指定 Main Class或者直接写入 MANIFEST.MF 文件</li>
<li>选择性的将依赖也打包到 <code>fat-jar</code> 中<ul>
<li>打包的时候自定义包含或者去除掉一些依赖</li>
<li>打包的时候对包含的依赖进行细粒度的控制，指定包含或者排除哪些类</li>
<li>可配置自动排除当前项目没有用到的依赖，最大程度的减小打包的 <code>fat-jar</code> 的体积</li>
</ul>
</li>
<li>重命名当前项目的依赖项，将依赖项放置到重命名的文件夹中，避免依赖冲突</li>
<li>将shade 插件指定的依赖项以及当前项目打包成包含自定义标识的 <code>fat-jar</code> 的同时打包一个普通 jar 包，还能部署到 maven 仓库    </li>
<li>资源转化</li>
<li>实现 Shader 接口，自定义 shading 逻辑</li>
</ul>
<h3 id="打包一个可运行的-jar-包"><a href="#打包一个可运行的-jar-包" class="headerlink" title="打包一个可运行的 jar 包"></a>打包一个可运行的 jar 包</h3><p><code>maven-shade-plugin</code> 插件最基础的功能就是打包出一个可执行的 <code>fat-jar</code>，主要是是对 <code>META-INF/MANIFEST.MF</code> 文件的修改</p>
<h4 id="为可执行的-jar-包设置-Main-Class"><a href="#为可执行的-jar-包设置-Main-Class" class="headerlink" title="为可执行的 jar 包设置 Main Class"></a>为可执行的 jar 包设置 Main Class</h4><p>打包一个可执行的 jar 最简单的方式就是设置 Main Class，<code>maven-shade-plugin</code> 插件提供通过<code>org.apache.maven.plugins.shade.resource.ManifestResourceTransformer</code> 设置 &lt;mainClass&gt;</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.liam.learning.maven.plugins.demo.shade.App<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>具体效果如下：</p>
<p><img src="/assets/picture/shade.executable.main.class.png" title="Shade 指定 Main Class"></p>
<h4 id="向-META-INF-MANIFEST-MF-文件写入自定义参数"><a href="#向-META-INF-MANIFEST-MF-文件写入自定义参数" class="headerlink" title="向 META-INF/MANIFEST.MF 文件写入自定义参数"></a>向 <code>META-INF/MANIFEST.MF</code> 文件写入自定义参数</h4><p>除了上面讲到了设置 Main-Class 的方式，我们还可以通过 <code>org.apache.maven.plugins.shade.resource.ManifestResourceTransformer</code> 的  &lt;manifestEntries&gt; 向 <code>META-INF/MANIFEST.MF</code> 文件写入 key-value 键值对</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">Main-Class</span>&gt;</span>com.liam.learning.maven.plugins.demo.shade.App<span class="tag">&lt;/<span class="name">Main-Class</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">Build-Number</span>&gt;</span>10086<span class="tag">&lt;/<span class="name">Build-Number</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">Custom-Parameter</span>&gt;</span>Custom Parameter<span class="tag">&lt;/<span class="name">Custom-Parameter</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里我们在 &lt;manifestEntries&gt; 中创建子节点，用子节点的名称作为 key，用子节点的值作为 value，写入 <code>META-INF/MANIFEST.MF</code> 文件，最终效果如下：</p>
<p><img src="/assets/picture/shade.plugin.writo.custom.pair.in.mainfest.mf.png" title="Shade 向 MANIFEST.MF 文件写入自定义键值对"></p>
<h3 id="打包-fat-jar-时选择放入jar-包中的依赖"><a href="#打包-fat-jar-时选择放入jar-包中的依赖" class="headerlink" title="打包 fat-jar 时选择放入jar 包中的依赖"></a>打包 fat-jar 时选择放入jar 包中的依赖</h3><p><code>maven-shade-plugin</code> 插件打包的时候可以选择性的将一些依赖项也打包到 <code>fat-jar</code> 中去</p>
<h4 id="通过-include-或者-exclude-选择依赖放入-fat-jar"><a href="#通过-include-或者-exclude-选择依赖放入-fat-jar" class="headerlink" title="通过 include 或者 exclude 选择依赖放入 fat-jar"></a>通过 include 或者 exclude 选择依赖放入 <code>fat-jar</code></h4><p><code>maven-shade-plugin</code> 插件的配置中有 &lt;artifactSet&gt;，它支持设置 &lt;excludes&gt; 或者 &lt;includes&gt; 来排除或者正向选择一些依赖项打包到 <code>fat-jar</code> 中去，下面这个例子就是使用 &lt;includes&gt;</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactSet</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">include</span>&gt;</span>com.google.guava:guava<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">artifactSet</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> &lt;includes&gt; 示例实际效果如下：</p>
<p><img src="/assets/picture/shade.plugin.artifact.set.include.png" title="Shade 选择加入 fat-jar 的依赖"></p>
<p>&lt;excludes&gt; 的使用方法和 &lt;includes&gt; 一致，需要注意的是 &lt;include&gt; 和 &lt;exclude&gt; 中的 artifact 的标识的格式是 <code>groupId:artifactId[[:type]:classifier]</code>，还有就是 &lt;excludes&gt; 的优先级高于 &lt;includes&gt; </p>
<p>Shade 插件除将依赖中的class 文件写入 <code>fat-jar</code> 之外，还会在 <code>/META-INF/maven/</code> 文件夹下面写入 maven 相关文件 <code>pom.properties</code> 和 <code>pom.xml</code>，包含依赖项的 maven 坐标以及依赖项自身的依赖信息</p>
<p><img src="/assets/picture/shade.plugin.select.dependency.write.maven.jpg" title="Shade 选择的依赖的 mave 信息"></p>
<p>这里的 <code>/META-INF/maven/com.google.guava/guava/pom.properties</code> 文件中就说明了打包进 <code>fat-jar</code> 的 guava 工具包的版本信息</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Generated by org.apache.felix.bundleplugin</span></span><br><span class="line"><span class="comment">#Thu Dec 26 22:08:20 EST 2019</span></span><br><span class="line"><span class="attr">version</span>=<span class="string">28.2-jre</span></span><br><span class="line"><span class="attr">groupId</span>=<span class="string">com.google.guava</span></span><br><span class="line"><span class="attr">artifactId</span>=<span class="string">guava</span></span><br></pre></td></tr></table></figure>

<h4 id="通过-lt-filter-gt-细粒度的控制依赖项的中的哪些-class-文件放入-fat-jar"><a href="#通过-lt-filter-gt-细粒度的控制依赖项的中的哪些-class-文件放入-fat-jar" class="headerlink" title="通过 &lt;filter&gt; 细粒度的控制依赖项的中的哪些 class 文件放入 fat-jar"></a>通过 &lt;filter&gt; 细粒度的控制依赖项的中的哪些 class 文件放入 fat-jar</h4><p>有时候我们需要使用的仅仅是依赖中的部分类，为了更细粒度的控制依赖中的哪些类被放入 <code>fat-jar</code> 中，Shade 插件提供了 &lt;filters&gt; 配置节点，可以正向选择或者排除掉依赖项中的一些类，将选中的类放入 <code>fat-jar</code> 中，下面是个简单的示例</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactSet</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>com.google.guava:guava<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">artifactSet</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifact</span>&gt;</span>com.google.guava:guava<span class="tag">&lt;/<span class="name">artifact</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">include</span>&gt;</span>com/google/common/base/**<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实际效果是：</p>
<p><img src="/assets/picture/shade.plugin.filter.select.dependency.class.png" title="Shade 细粒度选择放入 fat-jar 的依赖中的类"></p>
<p>这里将依赖 <code>com.google.guava:guava</code> 中的 <code>com/google/common/base/</code> 文件夹中的类都放入 <code>fat-jar</code> 中，这里需要注意注意一下，这时候 <code>/META-INF/maven/</code> 文件夹中没有 <code>com.google.guava:guava</code> 依赖的 maven 信息，没有办法直观的确定依赖项的版本信息了。</p>
<h4 id="使用-lt-minimizeJar-gt-true-lt-minimizeJar-gt-将最小范围内的依赖打包进-fat-jar"><a href="#使用-lt-minimizeJar-gt-true-lt-minimizeJar-gt-将最小范围内的依赖打包进-fat-jar" class="headerlink" title="使用 &lt;minimizeJar&gt;true&lt;/minimizeJar&gt; 将最小范围内的依赖打包进 fat-jar"></a>使用 &lt;minimizeJar&gt;true&lt;/minimizeJar&gt; 将最小范围内的依赖打包进 fat-jar</h4><p>除了上面讲到的手动的选择依赖放入 <code>fat-jar</code>，Shade 插件还支持自动删除依赖中没有用到的类，再将剩下的类放入 <code>fat-jar</code> 中，尽量打包一个体积最小的 <code>fat-jar</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">minimizeJar</span>&gt;</span>true<span class="tag">&lt;/<span class="name">minimizeJar</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>执行 mvn 指令时，加上 <code>-X</code> 参数，在 DEBUG 日志中可以看到 Shade 插件会删除没有使用的类</p>
<p><img src="/assets/picture/shade.plugin.minimize.jar.remove.class.jpg" title="Shade 删除不使用的类，精简 fat-jar"></p>
<h4 id="lt-minimizeJar-gt-和-lt-filter-gt-的结合使用"><a href="#lt-minimizeJar-gt-和-lt-filter-gt-的结合使用" class="headerlink" title="&lt;minimizeJar&gt; 和 &lt;filter&gt; 的结合使用"></a>&lt;minimizeJar&gt; 和 &lt;filter&gt; 的结合使用</h4><p>Shade 插件在 1.6 及其以上版本中， &lt;minimizeJar&gt; 和包含过滤器(&lt;filter&gt; 和 &lt;includes&gt;) 结合使用，可以对过滤器正向选择的依赖隐式去除不使用的依赖，但是如果使用过了 <code>&lt;excludeDefaults&gt;fasle&lt;/excludeDefaults&gt;</code> 则上述行为将不会发生</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">minimizeJar</span>&gt;</span>true<span class="tag">&lt;/<span class="name">minimizeJar</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifact</span>&gt;</span>com.google.guava:guava<span class="tag">&lt;/<span class="name">artifact</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">excludeDefaults</span>&gt;</span>false<span class="tag">&lt;/<span class="name">excludeDefaults</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">include</span>&gt;</span>com/google/common/base/Preconditions.class<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">include</span>&gt;</span>com/google/common/annotations/Beta.class<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">include</span>&gt;</span>com/google/common/annotations/GwtCompatible.class<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">include</span>&gt;</span>com/google/errorprone/annotations/CanIgnoreReturnValue.class<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="对依赖项的权限名进行重命名，避免依赖冲突"><a href="#对依赖项的权限名进行重命名，避免依赖冲突" class="headerlink" title="对依赖项的权限名进行重命名，避免依赖冲突"></a>对依赖项的权限名进行重命名，避免依赖冲突</h4><p>JVM 通过类加载器去加载类，类加载器通过类的全限定名去确定一个类，Shade 插件支持将依赖项中的类的全限定名进行重命名，当前项目中的 import 语句也会被修改</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">relocations</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">relocation</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>com.google<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">shadedPattern</span>&gt;</span>com.google.shade<span class="tag">&lt;/<span class="name">shadedPattern</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">relocation</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">relocations</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里我们将 <code>com.google</code> 重命名为 <code>com.google.shade</code>，Shade 插件在打包的时候，会将 com.google.* 下的类的全限定名改为 com.google.shade，还会将使用到 com.google.* 的 import 语句中的全限定名进行修改，效果如下：</p>
<p><img src="/assets/picture/shade.plugin.relocation.dependencies.result.jpg" title="Shade 插件重命名依赖项"></p>
<h4 id="同时打包-shade-包和普通-jar-包"><a href="#同时打包-shade-包和普通-jar-包" class="headerlink" title="同时打包 shade 包和普通 jar 包"></a>同时打包 shade 包和普通 jar 包</h4><p>默认情况下使用 Shade 插件打包会用插件修改后的 jar 包去替换支持情况下的普通包，并且能把这个jar 包部署到 maven 仓库；Shade 插件也支持同时打包、部署插件修改的 jar 包和普通的 jar 包，这就需要使用 <code>&lt;shadedArtifactAttached&gt;true&lt;/shadedArtifactAttached&gt;</code> 配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">shadedArtifactAttached</span>&gt;</span>true<span class="tag">&lt;/<span class="name">shadedArtifactAttached</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">shadedClassifierName</span>&gt;</span>with-shade-classifier<span class="tag">&lt;/<span class="name">shadedClassifierName</span>&gt;</span> <span class="comment">&lt;!-- Any name that makes sense --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/assets/picture/shade.plugin.package.shade.and.common.jar.jpg" title="Shade 插件同时打包 shade 包和普通jar 包"></p>
<h4 id="资源转换器"><a href="#资源转换器" class="headerlink" title="资源转换器"></a>资源转换器</h4><p>这一部分了解不多，目前没有用到过，有时间再补充，详细信息参见<a href="http://maven.apache.org/plugins/maven-shade-plugin/examples/resource-transformers.html#">官方文档</a></p>
<h4 id="自定义-Shade-插件的功能"><a href="#自定义-Shade-插件的功能" class="headerlink" title="自定义 Shade 插件的功能"></a>自定义 Shade 插件的功能</h4><p>Shade 插件定义了一个接口 <code>org.apache.maven.plugins.shade.Shader</code>，它的默认实现是 <code>org.apache.maven.plugins.shade.DefaultShader</code>；Shade 插件还支持自行实现 <code>Shader</code> 接口，自定义Shade 插件的功能，具体步骤如下</p>
<h5 id="实现一个自定义功能的-Shade-插件的扩展项目"><a href="#实现一个自定义功能的-Shade-插件的扩展项目" class="headerlink" title="实现一个自定义功能的 Shade 插件的扩展项目"></a>实现一个自定义功能的 Shade 插件的扩展项目</h5><p>首先是创建一个自定义的 Shade 插件扩展项目，然后在按照以下步骤完成扩展项目的开发</p>
<ul>
<li>引入依赖包 </li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.plexus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>plexus-component-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实现自己的 Shader </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component( role = Shader.class, hint = &quot;mock&quot; )</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockShader</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Shader</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="comment">// implement the interface here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在扩展项目中加入 plexus-component-metadata 插件</li>
</ul>
<p><code>org.codehaus.plexus:plexus-component-metadata</code> 插件的作用是生成 <code>META-INF/plexus/components.xml</code> 文件去描述组件信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.plexus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>plexus-component-metadata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>generate-metadata<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="使用自定义的-Shader-实现"><a href="#使用自定义的-Shader-实现" class="headerlink" title="使用自定义的 Shader 实现"></a>使用自定义的 Shader 实现</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.your.custom.shade<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mock-shader<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">shaderHint</span>&gt;</span>mock<span class="tag">&lt;/<span class="name">shaderHint</span>&gt;</span> // 在 MockShader 中设置的 hint</span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="maven-shade-plugin-的参数说明"><a href="#maven-shade-plugin-的参数说明" class="headerlink" title="maven-shade-plugin 的参数说明"></a>maven-shade-plugin 的参数说明</h2><p><code>maven-shade-plugin</code> 的目标只有两个， <code>shade:help</code> 和 <code>shade:shade</code>，这里讲解一下 <code>shade:shade</code> 相关的参数</p>
<h3 id="lt-artifactSet-gt"><a href="#lt-artifactSet-gt" class="headerlink" title="&lt;artifactSet&gt;"></a>&lt;artifactSet&gt;</h3><ul>
<li>参数说明：指定 <code>fat-jar</code> 中包含或者排除哪些依赖，通过 <code>groupId:artifactId:type:classifier</code> 这种复合标识符来标识，从 1.3 版本开始复合标识符支持 <code>*</code> 和 <code>?</code>，为了便利的使用<ul>
<li><code>groupId</code> 等同于 <code>groupId:*:*:*</code></li>
<li><code>groupId:artifactId</code> 等同于 <code>groupId:artifactId:*:*</code></li>
<li><code>groupId:artifactId:classifier</code> 等同于 <code>groupId:artifactId:*:classifier</code></li>
</ul>
</li>
<li>使用示例：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">artifactSet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>*:commons-logging<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">artifactSet</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>是否必填：否</li>
</ul>
<h3 id="lt-createDependencyReducedPom-gt"><a href="#lt-createDependencyReducedPom-gt" class="headerlink" title="&lt;createDependencyReducedPom&gt;"></a>&lt;createDependencyReducedPom&gt;</h3><ul>
<li>参数说明：控制是否精简 <code>fat-jar</code> 中 <code>pom.xml</code> 文件的参数，默认值为 true，包含在 <code>fat-jar</code> 中的依赖将被从 <code>pom.xml</code> 文件的 <code>&lt;dependencies&gt;</code> 节点下被删除，避免了使用 <code>fat-jar</code> 的项目中出现不必要的依赖冲突；被精简的 <code>pom.xml</code> 文件被命名为 <code>dependency-reduced-pom.xml</code>，存储在 <code>pom.xml</code> 所在目录中，除非你用 &lt;dependencyReducedPomLocation&gt; 参数指定 <code>dependency-reduced-pom.xml</code> 文件的存储位置</li>
<li>是否必填：否</li>
<li>默认值：true</li>
</ul>
<h3 id="lt-lt-createSourcesJar-gt"><a href="#lt-lt-createSourcesJar-gt" class="headerlink" title="&lt;&lt;createSourcesJar&gt;"></a>&lt;&lt;createSourcesJar&gt;</h3><ul>
<li>参数说明：控制是否的打包源文件 jar 包的参数</li>
<li>参数类型：boolean</li>
<li>是否必填：否</li>
</ul>
<h3 id="lt-lt-createSourcesJar-gt-1"><a href="#lt-lt-createSourcesJar-gt-1" class="headerlink" title="&lt;&lt;createSourcesJar&gt;"></a>&lt;&lt;createSourcesJar&gt;</h3><ul>
<li>参数说明：控制是否的打包测试源代码 jar 包的参数</li>
<li>参数类型：boolean</li>
<li>是否必填：否</li>
</ul>
<h3 id="lt-dependencyReducedPomLocation-gt"><a href="#lt-dependencyReducedPomLocation-gt" class="headerlink" title="&lt;dependencyReducedPomLocation&gt;"></a>&lt;dependencyReducedPomLocation&gt;</h3><ul>
<li>参数说明：指定 <code>dependency-reduced-pom.xml</code> 文件的存储位置</li>
<li>参数类型：java.io.File</li>
<li>是否必填：否</li>
<li>默认值：${basedir}/dependency-reduced-pom.xml</li>
</ul>
<h3 id="lt-filters-gt"><a href="#lt-filters-gt" class="headerlink" title="&lt;filters&gt;"></a>&lt;filters&gt;</h3><ul>
<li>参数说明：归档打包 <code>fat-jar</code> 的时候用到的过滤器，支持使用和 <code>&lt;artifactSet&gt;</code> 标签中格式一样的复合标识符标识一个依赖，再指定一组 <code>include</code>/<code>exclude</code> 文件表达式，去过滤选择加入 <code>fat-jar</code> 包的文件；<code>&lt;include&gt;</code> 节点先被处理，<code>&lt;exclude&gt;</code> 后被处理，所以 <code>&lt;exclude&gt;</code> 排除过滤器优先级更高，先用包含过滤器选择一批文件，再用排除过滤器去除掉一部分文件，剩下的再放入 <code>fat-jar</code> 包；默认情况下所有的依赖文件都会被归档，指定了多个包含和排除过滤器的时候，选择多个过滤器的交集放入 <code>fat-jar</code> 中。</li>
<li>使用示例：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifact</span>&gt;</span>junit:junit<span class="tag">&lt;/<span class="name">artifact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span>&gt;</span>org/junit/**<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org/junit/experimental/**<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>是否必填：否</li>
</ul>
<h3 id="lt-finalName-gt"><a href="#lt-finalName-gt" class="headerlink" title="&lt;finalName&gt;"></a>&lt;finalName&gt;</h3><ul>
<li>参数说明：<code>fat-jar</code> 的名称，通过 <code>&lt;build&gt;&lt;finalName&gt;</code> 可以自定义jar 包名称，Shade 插件的 <code>&lt;finalName&gt;</code> 如果和 <code>&lt;build&gt;&lt;finalName&gt;</code> 设置的不一致，部署到 maven 仓库的jar 包只会是普通的jar，Shade 插件不会进行任何替换操作，即使设置了 <code>shadedArtifactAttached</code> 参数</li>
<li>是否必填：否</li>
</ul>
<h3 id="lt-generateUniqueDependencyReducedPom-gt"><a href="#lt-generateUniqueDependencyReducedPom-gt" class="headerlink" title="&lt;generateUniqueDependencyReducedPom&gt;"></a>&lt;generateUniqueDependencyReducedPom&gt;</h3><ul>
<li>参数说明：创建 <code>dependency-reduced-pom.xml</code> 时，是否在文件名中增加唯一标识，如果为 true，则创建的文件名称为 <code>dependency-reduced-pom-[UniqueKey].xml</code>，避免多次构建中创建的 <code>dependency-reduced-pom.xml</code> 被覆盖</li>
<li>参数类型：boolean</li>
<li>是否必填：否</li>
<li>默认值：false</li>
</ul>
<h3 id="lt-keepDependenciesWithProvidedScope-gt"><a href="#lt-keepDependenciesWithProvidedScope-gt" class="headerlink" title="&lt;keepDependenciesWithProvidedScope&gt;"></a>&lt;keepDependenciesWithProvidedScope&gt;</h3><ul>
<li><p>参数说明：和 createDependencyReducedPom 参数不一样，keepDependenciesWithProvidedScope 参数为 true 时 <code>pom.xml</code> 中的依赖项不会被删除，会被保留，但是 <code>&lt;scope&gt;</code> 是 <code>provided</code>， 也就是说项目的依赖项需要实际项目所在的容器提供。**<em>这也意味着使用这个参数的时候不要对依赖项进行重命名了，否则会出现依赖缺失**</em></p>
</li>
<li><p>参数类型：boolean</p>
</li>
<li><p>是否必填：否</p>
</li>
<li><p>默认值：false</p>
</li>
<li><p>使用示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">keepDependenciesWithProvidedScope</span>&gt;</span>true<span class="tag">&lt;/<span class="name">keepDependenciesWithProvidedScope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>示例效果</p>
</li>
</ul>
<p><img src="/assets/picture/shade.plugin.keep.dependencies.with.provided.scope.jpg" title="Shade 插件保留依赖项，设置为 provided 作用域"></p>
<h3 id="lt-minimizeJar-gt"><a href="#lt-minimizeJar-gt" class="headerlink" title="&lt;minimizeJar&gt;"></a>&lt;minimizeJar&gt;</h3><p><strong><em>注意：使用此特性需要 <code>JDK1.5</code> 或更高版本</em></strong></p>
<ul>
<li>参数说明：是否自动精简依赖项中的文件，当前项目中没有使用的类文件被自动删除，不会被加入 <code>fat-jar</code></li>
<li>参数类型：boolean</li>
<li>是否必填：否</li>
<li>默认值：false </li>
</ul>
<h3 id="lt-outputDirectory-gt"><a href="#lt-outputDirectory-gt" class="headerlink" title="&lt;outputDirectory&gt;"></a>&lt;outputDirectory&gt;</h3><ul>
<li>参数说明：结合 <code>&lt;finalName&gt;</code> 参数可以设置 shade 插件修改后的jar 包的路径，<code>&lt;finalName&gt;</code> 设置jar 包名称，<code>&lt;outputDirectory&gt;</code> 指定 jar 包所在的目录</li>
<li>参数类型：java.io.File</li>
<li>是否必填：否</li>
</ul>
<h3 id="lt-outputFile-gt"><a href="#lt-outputFile-gt" class="headerlink" title="&lt;outputFile&gt;"></a>&lt;outputFile&gt;</h3><ul>
<li>参数说明：设置shade 插件修改后的jar 包的绝对路径；这个参数被设置之后 <code>finalName</code>、<code>shadedArtifactAttached</code>、<code>shadedClassifierName</code> 和 <code>createDependencyReducedPom</code> 参数将被忽略</li>
<li>参数类型：java.io.File</li>
<li>是否必填：否</li>
</ul>
<h3 id="lt-promoteTransitiveDependencies-gt"><a href="#lt-promoteTransitiveDependencies-gt" class="headerlink" title="&lt;promoteTransitiveDependencies&gt;"></a>&lt;promoteTransitiveDependencies&gt;</h3><ul>
<li>参数说明：当前参数设置为 <code>true</code> 时，被删除的依赖的传递依赖会被提升为直接依赖</li>
<li>参数类型：boolean</li>
<li>是否必填：否</li>
</ul>
<p><strong><em>未完待续</em></strong></p>
<h2 id="maven-shade-plugin-的使用场景是什么？"><a href="#maven-shade-plugin-的使用场景是什么？" class="headerlink" title="maven-shade-plugin 的使用场景是什么？"></a>maven-shade-plugin 的使用场景是什么？</h2><p>从上面讲到的 Shade 插件的功能来看，它的作用主要是</p>
<ul>
<li>打包一个可以执行 jar 包</li>
<li>选择项目依赖也打包到 <code>fat-jar</code> 中</li>
<li>重命名依赖项中 Class 的全限定名，对使用依赖的的 import 语句也进行修改，避免依赖冲突</li>
</ul>
<p>前两个功能的使用都比较简单，从上面即可看到如何使用，下面主要讲讲 <strong><em>如何使用 Shade 插件解决依赖同一个jar 包的不同版本</em></strong></p>
<h3 id="如何使用-Shade-插件解决依赖同一个jar-包的不同版本"><a href="#如何使用-Shade-插件解决依赖同一个jar-包的不同版本" class="headerlink" title="如何使用 Shade 插件解决依赖同一个jar 包的不同版本"></a>如何使用 Shade 插件解决依赖同一个jar 包的不同版本</h3><p>实际项目中可能会出现这种情况，我们的业务项目 <code>com.liam:biz</code> 依赖 <code>com.xxx:dep1:1.0</code> 和 <code>com.xxx:dep2:1.0</code>，<code>com.xxx:dep1:1.0</code> 传递依赖 <code>com.xxx:dep3:1.1</code>，而 <code>com.xxx:dep2:1.0</code> 依赖 <code>com.xxx:dep3:1.2</code>，这里就出现了对 <code>com.xxx:dep3</code> 两个版本的依赖，如果 <code>com.xxx:dep3</code> 高版本对低版本进行了向下兼容，你可以直接在 &lt;dependencyManagement&gt; 中指定使用高版本的 <code>com.xxx:dep3:1.2</code>，但是如果 <code>com.xxx:dep3:1.3</code> 和 <code>com.xxx:dep3:1.2</code> 不兼容呢？</p>
<p><img src="/assets/picture/biz.use.same.dependency.with.multi.version.png" title="业务项目中使用到同一个 jar 包的不同版本"></p>
<p>看到这个问题，我们考虑对三方包 <code>com.xxx:dep3</code> 进行一些修改，修改成一个自定义的二方包，修改 依赖的类的全限定名，这里我们就可以使用 Shade 插件的 &lt;relocations&gt;，将依赖项打包进 <code>fat-jar</code> 的同时，对依赖的类的全限定名进行修改，就可以避免依赖冲突了，具体插件配置如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">relocations</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">relocation</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>com.xxx.dep3<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">shadedPattern</span>&gt;</span>shaded.com.xxx.dep3<span class="tag">&lt;/<span class="name">shadedPattern</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">relocation</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">relocations</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样 <code>fat-jar</code> 中就会包含 <code>/shaded/com.xxx.dep3/**</code> 为路径的依赖，业务代码中的 import 语句也会被修改为 <code>import shaded.com.xxx.dep3.xxx</code> </p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql常用指令</title>
    <url>/2017/05/22/%E6%8A%80%E6%9C%AF/mysql/2017-05-22-mysql%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="执行-sql-文件"><a href="#执行-sql-文件" class="headerlink" title="执行 .sql 文件"></a>执行 <code>.sql</code> 文件</h3><p><em>方法1</em></p>
<pre><code>mysql -h1.1.1.1 -P3306 -uadmin -ppwd db_name &lt; test.sql</code></pre>
<p><em>方法2</em></p>
<ol>
<li>使用 <code>mysql-client</code> 登录到 mysql 服务器</li>
<li>source /root/path/to/.sql</li>
</ol>
<h3 id="mysql-查看-binlog"><a href="#mysql-查看-binlog" class="headerlink" title="mysql 查看 binlog"></a>mysql 查看 binlog</h3><p><code>mysql</code> 提供了 <code>mysqlbinlog</code> 指令，用于查看binlog</p>
<p>先来一个小例子, 查看某一段时间的 bin log</p>
<pre><code>    mysqlbinlog -h[host]  -P[port] -u[username] -p[password] --read-from-remote-server [binlog file name]
    --base64-output=decode-rows --start-datetime=&#39;2017-11-02 00:00:00&#39;
    --stop-datetime=&#39;2017-11-02 00:10:00&#39;</code></pre>
<p>看了上面这个小例子，发现一个小问题: <em><em>binlog file name 从哪来？</em></em><br>这个需要我们去mysql中去查看</p>
<pre><code>    mysql&gt; mysql -u[username] -p[password]    ## 登录mysql
    mysql&gt; show variables like &#39;log_bin&#39;;
    +---------------+-------+
    | Variable_name | Value |
    +---------------+-------+
    | log_bin       | OFF   | # 这个参数说明当前mysql 没有开启binlog 日志
    +---------------+-------+</code></pre>
<p>这里又引入一个问题: <em><em>如何开启 mysql 的 binlog</em></em></p>
<p>在 <code>mysql</code> 的 <code>官方文档</code> 中，对于 <code>binlog</code> 的开启只有一段内容</p>
<pre><code>    Binary logging is enabled by default (the log_bin system variable is set to ON). The exception is if you use mysqld to initialize the data directory manually by invoking it with the --initialize or --initialize-insecure option, when binary logging is disabled by default, but can be enabled by specifying the --log-bin option.
    二进制日志是默认启用（系统变量log_bin默认设置为ON）。唯一的例外是如果你使用mysqld来初始化数据目录手动调用它的 --initialize 或 --initialize-insecure 选项，当二进制日志默认是禁用的，但可以通过指定 `--log-bin` 选项启用。</code></pre>
<p>我们开始设置 <code>mysql</code> 的启动配置， 这里有两种方式</p>
<ol>
<li><p>直接在启动命令行中添加参数</p>
<pre><code> sudo /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --log-bin=mysql-bin --user=\_mysql</code></pre>
</li>
<li><p>在 mysql 配置文件中增加配置信息<br>这个时候我们遇到一个问题: Mysql 的配置文件在哪？</p>
<pre><code> &gt; sudo mysqld --verbose --help | grep -A2 &quot;Default options are read from the following files in the given order:&quot;
 Default options are read from the following files in the given order:
 /etc/my.cnf /etc/mysql/my.cnf /usr/local/mysql/etc/my.cnf ~/.my.cnf</code></pre>
</li>
</ol>
<p>从上面可以看到 <code>mysql</code> 的配置文件如下：</p>
<pre><code>    /etc/my.cnf /etc/mysql/my.cnf /usr/local/mysql/etc/my.cnf ~/.my.cnf</code></pre>
<p>在 <code>/etc/my.cnf</code> 添加配置如下</p>
<pre><code>    [mysqld]
    basedir=/usr/local/mysql
    datadir=/usr/local/mysql/data
    plugin-dir=/usr/local/mysql/lib/plugin
    user=\_mysql
    log-bin=mysql-bin
    port=3306</code></pre>
<p>我们来尝试启动 <code>mysql</code>，但是却没能启动成功， 报错信息如下</p>
<pre><code>    [ERROR] You have enabled the binary log, but you haven&#39;t provided the mandatory server-id. Please refer to the proper server start-up parameters documentation</code></pre>
<p>遇到问题，我们再去看看官方文档，在官方文档中有如下介绍，在 mysql 5.7 及以上版本中，需要设置参数 <code>server-id</code></p>
<pre><code>    In MySQL 5.7, a server ID had to be specified when binary logging was enabled, or the server would not start. The server_id system variable is set to 1 by default. The server can be started with this default ID when binary logging is enabled, but a warning message is issued if you do not specify a server ID explicitly using the --server-id option. For servers that are used in a replication topology, you must specify a unique non-zero server ID for each server.
    在MySQL 5.7中，当启用二进制日志时，必须指定服务器ID，否则服务器将无法启动。系统变量 server_id 默认设置为1。当启用二进制日志记录时，服务器可以以这个默认ID启动，但如果未显式使用服务器ID选项指定服务器ID，则会发出警告消息。对于复制拓扑中使用的服务器，必须为每个服务器指定唯一的非零服务器ID。</code></pre>
<p>将 <code>/etc/my.cnf</code> 配置修改如下：</p>
<pre><code>    [mysqld]
    basedir=/usr/local/mysql
    datadir=/usr/local/mysql/data
    plugin-dir=/usr/local/mysql/lib/plugin
    user=\_mysql
    log-bin=mysql-bin
    port=3306
    server-id=1</code></pre>
<p>再次启动mysql，成功了！但是有个问题，mysql 的日志直接输出在控制台中，需要输出到指定文件夹中，在 <code>/etc/my.cnf</code> 的 <code>[mysqld]</code> 中增加配置</p>
<pre><code>    log-error=/usr/local/mysql/data/local.err</code></pre>
<p>我们开启了binlog之后，可以使用 <code>mysqlbinlog</code> 来查看binlog了！<br>回到第一个问题 <em><em>binlog file name 从哪来？</em></em></p>
<pre><code>    mysql&gt; show master status;

    +------------------+-----------+--------------+------------------+-------------------------------------------------+
    | File             | Position  | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set                               |
    +------------------+-----------+--------------+------------------+-------------------------------------------------+
    | mysql-bin.000065 | 516819919 |              |                  | 63c58e9d-e063-11e6-8a0e-6c92bf324c90:1-19804498 |
    +------------------+-----------+--------------+------------------+-------------------------------------------------+
    1 row in set (0.00 sec)</code></pre>
<p>这里第一列就是 binlog 日志文件的名称了！</p>
<pre><code>    mysqlbinlog
    -?, --help          Display this help and exit.
                        查看帮助信息
    --base64-output=name
                        Determine when the output statements should be
                        base64-encoded BINLOG statements: &#39;never&#39; disables it and
                        works only for binlogs without row-based events;
                        &#39;decode-rows&#39; decodes row events into commented
                        pseudo-SQL statements if the --verbose option is also
                        given; &#39;auto&#39; prints base64 only when necessary (i.e.,
                        for row-based events and format description events).  If
                        no --base64-output[=name] option is given at all, the
                        default is &#39;auto&#39;.
    --bind-address=name IP address to bind to.
    --character-sets-dir=name
                        Directory for character set files.
    -d, --database=name 指明查询binlog 的数据库，如：-dtest，查看test 数据库
    --rewrite-db=name   Rewrite the row event to point so that it can be applied
                        to a new database
    -#, --debug[=#]     This is a non-debug version. Catch this and exit.
    --debug-check       This is a non-debug version. Catch this and exit.
    --debug-info        This is a non-debug version. Catch this and exit.
    --default-auth=name Default authentication client-side plugin to use.
    -D, --disable-log-bin
                        Disable binary log. This is useful, if you enabled
                        --to-last-log and are sending the output to the same
                        MySQL server. This way you could avoid an endless loop.
                        You would also like to use it when restoring after a
                        crash to avoid duplication of the statements you already
                        have. NOTE: you will need a SUPER privilege to use this
                        option.
    -F, --force-if-open Force if binlog was not closed properly.
                        (Defaults to on; use --skip-force-if-open to disable.)
    -f, --force-read    Force reading unknown binlog events.
    -H, --hexdump       Augment output with hexadecimal and ASCII event dump.
    -h, --host=name     Get the binlog from server.
    -i, --idempotent    Notify the server to use idempotent mode before applying
                        Row Events
    -l, --local-load=name
                        Prepare local temporary files for LOAD DATA INFILE in the
                        specified directory.
    -o, --offset=#      Skip the first N entries.
    -p, --password[=name]
                        Password to connect to remote server.
    --plugin-dir=name   Directory for client-side plugins.
    -P, --port=#        Port number to use for connection or 0 for default to, in
                        order of preference, my.cnf, $MYSQL_TCP_PORT,
                        /etc/services, built-in default (3306).
    --protocol=name     The protocol to use for connection (tcp, socket, pipe,
                        memory).
    -R, --read-from-remote-server
                        Read binary logs from a MySQL server. This is an alias
                        for read-from-remote-master=BINLOG-DUMP-NON-GTIDS.
    --read-from-remote-master=name
                        Read binary logs from a MySQL server through the
                        COM_BINLOG_DUMP or COM_BINLOG_DUMP_GTID commands by
                        setting the option to either BINLOG-DUMP-NON-GTIDS or
                        BINLOG-DUMP-GTIDS, respectively. If
                        --read-from-remote-master=BINLOG-DUMP-GTIDS is combined
                        with --exclude-gtids, transactions can be filtered out on
                        the master avoiding unnecessary network traffic.
    --raw               Requires -R. Output raw binlog data instead of SQL
                        statements, output is to log files.
    -r, --result-file=name
                        Direct output to a given file. With --raw this is a
                        prefix for the file names.
    --secure-auth       Refuse client connecting to server if it uses old
                        (pre-4.1.1) protocol. Deprecated. Always TRUE
    --server-id=#       Extract only binlog entries created by the server having
                        the given id.
    --server-id-bits=#  Set number of significant bits in server-id
    --set-charset=name  Add &#39;SET NAMES character_set&#39; to the output.
    -s, --short-form    Just show regular queries: no extra info and no row-based
                        events. This is for testing only, and should not be used
                        in production systems. If you want to suppress
                        base64-output, consider using --base64-output=never
                        instead.
    -S, --socket=name   The socket file to use for connection.
    --ssl-mode=name     SSL connection mode.
    --ssl               Deprecated. Use --ssl-mode instead.
                        (Defaults to on; use --skip-ssl to disable.)
    --ssl-verify-server-cert
                        Deprecated. Use --ssl-mode=VERIFY_IDENTITY instead.
    --ssl-ca=name       CA file in PEM format.
    --ssl-capath=name   CA directory.
    --ssl-cert=name     X509 cert in PEM format.
    --ssl-cipher=name   SSL cipher to use.
    --ssl-key=name      X509 key in PEM format.
    --ssl-crl=name      Certificate revocation list.
    --ssl-crlpath=name  Certificate revocation list path.
    --tls-version=name  TLS version to use, permitted values are: TLSv1, TLSv1.1
    --start-datetime=name
                        Start reading the binlog at first event having a datetime
                        equal or posterior to the argument; the argument must be
                        a date and time in the local time zone, in any format
                        accepted by the MySQL server for DATETIME and TIMESTAMP
                        types, for example: 2004-12-25 11:25:56 (you should
                        probably use quotes for your shell to set it properly).
    -j, --start-position=#
                        Start reading the binlog at position N. Applies to the
                        first binlog passed on the command line.
    --stop-datetime=name
                        Stop reading the binlog at first event having a datetime
                        equal or posterior to the argument; the argument must be
                        a date and time in the local time zone, in any format
                        accepted by the MySQL server for DATETIME and TIMESTAMP
                        types, for example: 2004-12-25 11:25:56 (you should
                        probably use quotes for your shell to set it properly).
    --stop-never        Wait for more data from the server instead of stopping at
                        the end of the last log. Implicitly sets --to-last-log
                        but instead of stopping at the end of the last log it
                        continues to wait till the server disconnects.
    --stop-never-slave-server-id=#
                        The slave server_id used for --read-from-remote-server
                        --stop-never. This option cannot be used together with
                        connection-server-id.
    --connection-server-id=#
                        The slave server_id used for --read-from-remote-server.
                        This option cannot be used together with
                        stop-never-slave-server-id.
    --stop-position=#   Stop reading the binlog at position N. Applies to the
                        last binlog passed on the command line.
    -t, --to-last-log   Requires -R. Will not stop at the end of the requested
                        binlog but rather continue printing until the end of the
                        last binlog of the MySQL server. If you send the output
                        to the same MySQL server, that may lead to an endless
                        loop.
    -u, --user=name     链接数据库的用户名
    -v, --verbose       Reconstruct pseudo-SQL statements out of row events. -v
                        -v adds comments on column data types.
    -V, --version       查看 `mysqlbinlog` 版本信息
    --open-files-limit=#
                        Used to reserve file descriptors for use by this program.
    -c, --verify-binlog-checksum
                        Verify checksum binlog events.
    --binlog-row-event-max-size=#
                        The maximum size of a row-based binary log event in
                        bytes. Rows will be grouped into events smaller than this
                        size if possible. This value must be a multiple of 256.
    --skip-gtids        Do not preserve Global Transaction Identifiers; instead
                        make the server execute the transactions as if they were
                        new.
    --include-gtids=name
                        打印binlog 信息时，只打印指定的部分全局事务id对应的binglog 信息
    --exclude-gtids=name
                        打印binlog 信息时，排除部分全局事务id对应的binglog 信息</code></pre>
<h4 id="待解决问题"><a href="#待解决问题" class="headerlink" title="待解决问题"></a>待解决问题</h4><p>如果在 mac os 的设置中启动了mysql 而且勾选了 <code>Automatically Start MySQL Server on Startup</code>, 当你想要关闭 mysql 的时候，mysql 会自动重启！！！<br>这个问题找了好久才发现，至于这个不断重启功能的实现待研究…</p>
<h3 id="mysql-查看存储过程"><a href="#mysql-查看存储过程" class="headerlink" title="mysql 查看存储过程"></a>mysql 查看存储过程</h3><h4 id="查看存储过程状态"><a href="#查看存储过程状态" class="headerlink" title="查看存储过程状态"></a>查看存储过程状态</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">procedure</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<pre><code>    mysql&gt; show procedure status\G
    *************************** 1. row ***************************
                  Db: db_name
                Name: procedure_name
                Type: PROCEDURE
             Definer: root@localhost
            Modified: 2017-05-10 14:10:00
             Created: 2017-05-10 14:10:00
       Security_type: DEFINER
             Comment:
    character_set_client: utf8mb4
    collation_connection: utf8mb4_general_ci
    Database Collation: utf8_general_ci
    1 row in set (0.02 sec)</code></pre>
<h4 id="查看存储过程具体定义"><a href="#查看存储过程具体定义" class="headerlink" title="查看存储过程具体定义"></a>查看存储过程具体定义</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> %procedure_name%;</span><br></pre></td></tr></table></figure>

<h4 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h4><p><strong><em>注意：在创建存储过程的时候，语句中的分号会导致报错，需要用 <code>DELIMITER</code> 重新定义分隔符</em></strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="comment">-- to create procedure</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h4 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> &#123;<span class="keyword">PROCEDURE</span> | <span class="keyword">FUNCTION</span>&#125; [<span class="keyword">IF</span> <span class="keyword">EXISTS</span>] sp_name</span><br></pre></td></tr></table></figure>

<h3 id="mysql-查看数据库和表容量大小"><a href="#mysql-查看数据库和表容量大小" class="headerlink" title="mysql 查看数据库和表容量大小"></a>mysql 查看数据库和表容量大小</h3><p><code>information_schema</code> 库中有个 <code>TABLES</code> 表</p>
<pre><code>    mysql&gt; show create table TABLES\G
    *************************** 1. row ***************************
    Table: TABLES
    Create Table: CREATE TEMPORARY TABLE `TABLES` (
    `TABLE_CATALOG` varchar(512) NOT NULL DEFAULT &#39;&#39;,
    `TABLE_SCHEMA` varchar(64) NOT NULL DEFAULT &#39;&#39;,
    `TABLE_NAME` varchar(64) NOT NULL DEFAULT &#39;&#39;,
    `TABLE_TYPE` varchar(64) NOT NULL DEFAULT &#39;&#39;,
    `ENGINE` varchar(64) DEFAULT NULL,
    `VERSION` bigint(21) unsigned DEFAULT NULL,
    `ROW_FORMAT` varchar(10) DEFAULT NULL,
    `TABLE_ROWS` bigint(21) unsigned DEFAULT NULL,
    `AVG_ROW_LENGTH` bigint(21) unsigned DEFAULT NULL,
    `DATA_LENGTH` bigint(21) unsigned DEFAULT NULL,
    `MAX_DATA_LENGTH` bigint(21) unsigned DEFAULT NULL,
    `INDEX_LENGTH` bigint(21) unsigned DEFAULT NULL,
    `DATA_FREE` bigint(21) unsigned DEFAULT NULL,
    `AUTO_INCREMENT` bigint(21) unsigned DEFAULT NULL,
    `CREATE_TIME` datetime DEFAULT NULL,
    `UPDATE_TIME` datetime DEFAULT NULL,
    `CHECK_TIME` datetime DEFAULT NULL,
    `TABLE_COLLATION` varchar(32) DEFAULT NULL,
    `CHECKSUM` bigint(21) unsigned DEFAULT NULL,
    `CREATE_OPTIONS` varchar(255) DEFAULT NULL,
    `TABLE_COMMENT` varchar(2048) NOT NULL DEFAULT &#39;&#39;
    ) ENGINE=MEMORY DEFAULT CHARSET=utf8
    1 row in set (0.00 sec)</code></pre>
<p>其中主要字段是</p>
<p><code>TABLE_SCHEMA</code>: 数据库名称<br><code>TABLE_NAME</code>: 表名称<br><code>DATA_LENGTH</code>: 数据占用的空间大小，单位是字节<br><code>INDEX_LENGTH</code>: 索引占用的空间大小，单位是字节</p>
<h4 id="查看数据库占用空间大小"><a href="#查看数据库占用空间大小" class="headerlink" title="查看数据库占用空间大小"></a>查看数据库占用空间大小</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (<span class="keyword">SUM</span>(DATA_LENGTH) + <span class="keyword">SUM</span>(INDEX_LENGTH)) / <span class="number">1024</span> / <span class="number">1024</span></span><br><span class="line"><span class="keyword">FROM</span> information_schema.TABLES</span><br><span class="line"><span class="keyword">WHERE</span> TABLE_SCHEMA = <span class="string">&#x27;database_name&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="查看表占用空间大小"><a href="#查看表占用空间大小" class="headerlink" title="查看表占用空间大小"></a>查看表占用空间大小</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (<span class="keyword">SUM</span>(DATA_LENGTH) + <span class="keyword">SUM</span>(INDEX_LENGTH)) / <span class="number">1024</span> / <span class="number">1024</span></span><br><span class="line"><span class="keyword">FROM</span> information_schema.TABLES</span><br><span class="line"><span class="keyword">WHERE</span> TABLE_NAME = <span class="string">&#x27;table_name&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="mysql-求时间差距"><a href="#mysql-求时间差距" class="headerlink" title="mysql 求时间差距"></a>mysql 求时间差距</h3><p><code>timestampdiff(unit,datetime_expr1,datetime_expr2)</code> 比较两个 timestamp 时间间隔，返回单位是unit 的数值</p>
<p>例如</p>
<p><code>timestampdiff(second,&#39;2018-01-01 00:00:00&#39;,&#39;2018-01-01 00:00:02&#39;)</code> 得到 2</p>
<h3 id="表结构常用修改语句"><a href="#表结构常用修改语句" class="headerlink" title="表结构常用修改语句"></a>表结构常用修改语句</h3><h4 id="重置-AUTO-INCREMENT"><a href="#重置-AUTO-INCREMENT" class="headerlink" title="重置 AUTO_INCREMENT"></a>重置 AUTO_INCREMENT</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;<span class="keyword">Table</span> <span class="keyword">Name</span>&gt; AUTO_INCREMENT = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 线程池</title>
    <url>/2020/06/26/%E6%8A%80%E6%9C%AF/java/%E9%87%8D%E8%AF%BBJava%20%E6%BA%90%E7%A0%81%20%E2%80%94%E2%80%94%20Java%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="Java-线程池"><a href="#Java-线程池" class="headerlink" title="Java 线程池"></a>Java 线程池</h1><h2 id="线程池存在的意义"><a href="#线程池存在的意义" class="headerlink" title="线程池存在的意义"></a>线程池存在的意义</h2><p>在机器的 CPU 核数越来越多的发展趋势下，为了更好的利用机器资源，我们就会想到创建更多的线程，理想状态下对于每个任务都去创建一个线程；但是 CPU 的数量也是有限的，创建了过多的线程会导致多个线程去竞争 CPU 资源，导致线程上下文的频繁切换，浪费系统资源；而且每个线程都有自己的内存空间，系统创建了过多的线程也会浪费系统资源；线程的创建和销毁也会消耗系统资源；</p>
<p>总而言之，线程是很稀有的资源，通过线程池我们可以减少线程的创建和销毁所消耗的时间和系统资源的开销，也避免了为大量线程分配内存，以及线程上下文的 <code>过度切换</code>；<br>将线程这种稀有资源池化使用也是开发人员的惯用方法，同理还有 <code>数据库连接池</code>，可以在接受一个任务之后，直接在资源池中获取一个线程，用完之后再归还。</p>
<p>线程池的好处主要是</p>
<ul>
<li>线程资源的复用，降低资源消耗</li>
<li>提高响应速度，直接使用空闲线程，不用每个请求都要等待创建线程</li>
<li>提高线程的可管理性，对线程实现统一分配和实时监控</li>
</ul>
<h2 id="Executor-的重要实现-————-ThreadPoolExecutor"><a href="#Executor-的重要实现-————-ThreadPoolExecutor" class="headerlink" title="Executor 的重要实现 ———— ThreadPoolExecutor"></a><code>Executor</code> 的重要实现 ———— <code>ThreadPoolExecutor</code></h2><p>在 <code>J.U.C</code> 工具包中，线程池的实现主要是 <code>ThreadPoolExecutor</code>，下面个将对线程池进行更详细的介绍</p>
<h3 id="ThreadPoolExecutor-的参数"><a href="#ThreadPoolExecutor-的参数" class="headerlink" title="ThreadPoolExecutor 的参数"></a><code>ThreadPoolExecutor</code> 的参数</h3><p><code>ThreadPoolExecutor</code> 的构造方法的参数如下</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>corePoolSize</code></td>
<td>int</td>
<td>线程池核心线程数量，如果没有设置 <code>allowCoreThreadTimeOut</code> 参数，即使空间也会保留的线程数量</td>
</tr>
<tr>
<td><code>maximumPoolSize</code></td>
<td>int</td>
<td>线程池允许的最大线程数</td>
</tr>
<tr>
<td><code>keepAliveTime</code></td>
<td>long</td>
<td>空闲线程存活时间，空闲线程在终止之前等待新任务的最长时间；超出核心线程数的非核心线程会阻塞等待一段时间去获取任务等待队列中的任务，也就是说任务等待队列中的任务的等待时长最多为这个时间</td>
</tr>
<tr>
<td><code>unit</code></td>
<td>TimeUnit</td>
<td>空闲线程存活时间的单位</td>
</tr>
<tr>
<td><code>workQueue</code></td>
<td>BlockingQueue</td>
<td>用于缓存任务的阻塞等待队列</td>
</tr>
<tr>
<td><code>threadFactory</code></td>
<td>ThreadFactory</td>
<td>创建线程的工厂类</td>
</tr>
<tr>
<td><code>handler</code></td>
<td>RejectedExecutionHandler</td>
<td>线程池无法接受新任务时，拒绝新任务的策略，简称饱和策略</td>
</tr>
<tr>
<td><code>allowCoreThreadTimeOut</code></td>
<td>boolean</td>
<td>是否允许核心线程超过空闲存活时间后被销毁</td>
</tr>
</tbody></table>
<p><strong><em>注意：<code>allowCoreThreadTimeOut</code> 参数不是 <code>ThreadPoolExecutor</code> 构造方法的参数，默认为 <code>false</code></em></strong></p>
<h4 id="J-U-C-提供的-RejectExecutionHandler-的实现"><a href="#J-U-C-提供的-RejectExecutionHandler-的实现" class="headerlink" title="J.U.C 提供的 RejectExecutionHandler 的实现"></a><code>J.U.C</code> 提供的 <code>RejectExecutionHandler</code> 的实现</h4><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AbortPolicy</td>
<td>抛出一个 RejectedExecutionException 异常，中断任务提交</td>
</tr>
<tr>
<td>DiscardPolicy</td>
<td>忽略这个被拒绝的任务，什么都不做</td>
</tr>
<tr>
<td>DiscardOldestPolicy</td>
<td>将任务等待队列中最老的任务丢弃掉</td>
</tr>
<tr>
<td>CallerRunsPolicy</td>
<td>直接在主线程中调用被拒绝放入线程池的任务</td>
</tr>
</tbody></table>
<h3 id="ThreadPoolExecutor-的状态"><a href="#ThreadPoolExecutor-的状态" class="headerlink" title="ThreadPoolExecutor 的状态"></a><code>ThreadPoolExecutor</code> 的状态</h3><p>线程池的状态信息如下：</p>
<table>
<thead>
<tr>
<th>状态名称</th>
<th>状态特征描述</th>
</tr>
</thead>
<tbody><tr>
<td>RUNNING(运行中)</td>
<td>接受新任务而且处理缓存队列中的任务</td>
</tr>
<tr>
<td>SHUTDOWN(待关闭)</td>
<td>不接受新任务，但是处理缓存队列中的任务，</td>
</tr>
<tr>
<td>STOP(停止)</td>
<td>不接受新任务，现有缓存队列中的任务不会处理，正在运行的任务会被中断</td>
</tr>
<tr>
<td>TIDYING(整理)</td>
<td>所有任务都被终止了，并且准备去调用 terminal() 钩子方法</td>
</tr>
<tr>
<td>TERMINATED(终止)</td>
<td>terminal() 方法执行完毕，进入终态</td>
</tr>
</tbody></table>
<p>状态流转流程如下</p>
<p><img src="/assets/picture/thread.pool.executor.state.flow.png" alt="ThreadPoolExecutor 状态流转图" title="ThreadPoolExecutor 状态流转图"></p>
<h4 id="shutdown-方法"><a href="#shutdown-方法" class="headerlink" title="shutdown() 方法"></a><code>shutdown()</code> 方法</h4><p>在这个方案中，我们会将线程池状态置为 SHUTDOWN，中断闲置线程，但是还会继续处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 确认线程可访问</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//将状态设置为 SHUTOWN</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 中断线程池中的空闲的线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        <span class="comment">// 调用钩子方法</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="comment">// 确认线程没有中断，并且处于闲置状态之后再中断</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="shutdownNow-方法"><a href="#shutdownNow-方法" class="headerlink" title="shutdownNow() 方法"></a><code>shutdownNow()</code> 方法</h4><p><code>shutdownNow()</code> 方法中，除了将线程池状态置为 STOP 的之外，还会主动去中断工作线程，并且将任务阻塞等待队列清空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 确认线程可访问</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//将状态设置为 STOP</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 中断线程池中的所有工作线程，无论是否在运行</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 将任务阻塞等待队列清空</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终止线程池，因为当前线程池状态是 STOP，</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock; </span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">          w.interruptIfStarted();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Thread t;</span><br><span class="line">      <span class="comment">// 中断所有可以中断的线程</span></span><br><span class="line">      <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              t.interrupt();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ThreadPoolExecutor-的任务提交流程"><a href="#ThreadPoolExecutor-的任务提交流程" class="headerlink" title="ThreadPoolExecutor 的任务提交流程"></a><code>ThreadPoolExecutor</code> 的任务提交流程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码的注释可以了解到，任务提交流程的逻辑如下：</p>
<ol>
<li>当线程池中线程数量小于核心线程数量时，直接创建创建新的线程</li>
<li>当线程池中线程数量大于核心线程数量时，如果线程缓存存队列没有满，则将任务加入缓存队列</li>
<li>当线程池中线程数量大于核心线程数量时，如果线程缓存队列满了，而且线程数量小于线程池最大容量的时候直接新建线程</li>
<li>当线程池中线程数量大于核心线程数量时，如果线程缓存队列满了，而且线程数量大于线程池最大容量的时候，调用拒绝处理器，拒绝新增任务</li>
</ol>
<p>具体的流程可以看下图：</p>
<p><img src="/assets/picture/thread.pool.executor.execute.flow.svg" alt="ThreadPoolExecutor 任务提交流程图" title="ThreadPoolExecutor 任务提交流程图"></p>
<p>上面这个图只是线程池任务提交流程的概要图，具体的为任务新建线程的逻辑在 <code>addWoker</code> 方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">// 线程状态为 SHUTDOWN，提交非空任务时， 直接退出</span></span><br><span class="line">        <span class="comment">// 线程状态为 SHUTDOWN，并且等待队列为空，此时提交空任务的时候直接退出</span></span><br><span class="line">        <span class="comment">// 线程状态为 STOP、TIDYING、TERMINATED 状态时，直接退出</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上面的代码分析一下就得到了下图</p>
<p><img src="/assets/picture/thread.pool.executor.state.detail.flow.svg" alt="ThreadPoolExecutor 任务提交详细流程图" title="ThreadPoolExecutor 任务提交详细流程图"></p>
<h3 id="ThreadPoolExecutor-是如何收缩的？"><a href="#ThreadPoolExecutor-是如何收缩的？" class="headerlink" title="ThreadPoolExecutor 是如何收缩的？"></a><code>ThreadPoolExecutor</code> 是如何收缩的？</h3><p>在任务执行过程中，线程池会根据状态去选择性的收缩大小，如下代码，<br>任务的线程在运行的时候，执行完了自身任务之后，会从线程池中取出等待的任务进行执行；在从任务等待队列中获取任务的过程中会根据情况对线程池进行收缩</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">  Thread wt = Thread.currentThread();</span><br><span class="line">  Runnable task = w.firstTask;</span><br><span class="line">  w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">  w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">  <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 当前需要执行的任务执行完毕之后，会从任务阻塞等待队列中提取待运行的任务并执行</span></span><br><span class="line">      <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 省略</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            task = <span class="keyword">null</span>;</span><br><span class="line">            w.completedTasks++;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      processWorkerExit(w, completedAbruptly);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">// 当线程池状态为 SHUTDOWN，并且等待队列为空时，线程池将被清空</span></span><br><span class="line">        <span class="comment">// 当线程池状态为 STOP 或者 TIDYING 或者 TERMINATED 时，忽略等待队列中的任务，线程池将被清空</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 1. 线程状态为 RUNNING</span></span><br><span class="line"><span class="comment">        *     1) 线程数量超过了线程池最大容量，线程池容量减一</span></span><br><span class="line"><span class="comment">        *     2) 线程数量超过了核心线程数，且上一循环中获取线程超时了，线程池容量减一</span></span><br><span class="line"><span class="comment">        *     3) 线程数量小于核心线程数且大于1，但是核心线程允许闲置超时销毁时，线程池容量减一</span></span><br><span class="line"><span class="comment">        *     4)线程数量小于等于1，但是核心线程允许闲置超时销毁时，且上一循环中获取线程超时了，且任务缓存队列为空，线程池容量减一</span></span><br><span class="line"><span class="comment">        * 2. 线程状态为 SHUTDOWN, 但是任务缓存队列不为空</span></span><br><span class="line"><span class="comment">        *     1) 线程数量超过了线程池最大容量，线程池容量减一</span></span><br><span class="line"><span class="comment">        *     2) 线程数量超过了核心线程数，且上一循环中获取线程超时了，线程池容量减一</span></span><br><span class="line"><span class="comment">        *     3) 线程数量小于核心线程数且大于1，但是核心线程允许闲置超时销毁时，线程池容量减一</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，线程池的线程在执行完当前任务之后会去从任务阻塞等待队列中提取待运行的任务，这个时候线程池会在不同的状态下，根据情况进行收缩</p>
<ul>
<li>线程池状态为RUNNIING<ul>
<li>线程数量超过了线程池最大容量，线程池容量减一</li>
<li>线程数量超过了核心线程数，且上一循环中获取线程超时了（等待队列可能为空），线程池容量减一</li>
<li>线程数量小于核心线程数且大于1，且上一循环中获取线程超时了（等待队列可能为空），但是核心线程允许闲置超时销毁时，线程池容量减一</li>
<li>线程数量小于核心线程数且大于1，但是核心线程不允许闲置超时销毁时，线程池会阻塞在从任务等待队列中提起任务的操作上，除非被中断</li>
<li>线程数量小于等于1，但是核心线程允许闲置超时销毁时，且上一循环中获取线程超时了（等待队列可能为空），且任务等待队列为空，线程池容量减一</li>
</ul>
</li>
<li>线程池状态为 SHUTDOWN，并且任务缓存队列为空的时候，CAS 自旋将线程池大小降到 0 为止</li>
<li>线程池状态为 SHUTDOWN，且任务缓存队列不为空<ul>
<li>线程数量超过了线程池最大容量，线程池容量减一</li>
<li>线程数量超过了核心线程数，且上一循环中获取线程超时了（等待队列可能为空），线程池容量减一</li>
<li>线程数量小于核心线程数且大于1，但是核心线程允许闲置超时销毁时，线程池容量减一</li>
</ul>
</li>
<li>线程池状态为 STOP 或者 TIDYING 或者 TERMINATED 时，CAS 自旋将线程池大小降到 0 为止</li>
</ul>
<p><strong><em>注意：上面说到的超时，就是超过了线程池的闲置超时时间</em></strong></p>
<pre><code>    总结一下：
    1. 线程池在运行中(RUNNING)状态时，
    1) 当线程数超过线程池最大容量时，线程池容量减一，确保线程池容量限制
    2) 当线程数超过了核心线程数，而且暂时没有等待运行的任务，线程池容量减一，让线程数逐步
    回归核心线程数；
    3) 当线程数小于核心线程数且大于1，而线程池允许核心线程闲置超时销毁，而且暂时没有等待
    运行的任务，线程池容量也会减一，让线程数逐步减少到 1；
    4) 当线程数小于核心线程数且大于1，但是运行中的线程池如果核心线程不允许闲置超时销毁，
    线程池会阻塞在从等待队列中提取待运行的任务，除非被中断；
    5) 当这个运行中的线程池中的线程数减少到 1 的时候，如果核心线程允许闲置超时销毁，而且
    暂时没有等待运行的任务，且当前任务等待队列为空，线程池容量减一，线程池为空了
    6) 当这个运行中的线程池中的线程数减少到 1 的时候，但是运行中的线程池如果核心线程不允
    许闲置超时销毁，线程池会阻塞在从等待队列中提取待运行的任务，除非被中断；
    2. 线程池在待关闭(SHUTDOWN)状态时，
    1) 如果任务等待队列为空，线程池将被清空；如果任务等待队列不为空，还是处理等待任务，当
    线程数超过线程池最大容量时，线程池容量减一，保证线程数不超过最大容量；
    2) 当线程数超过了核心线程数，而且暂时没有等待运行的任务，线程池容量减一，让线程数逐步
    回归核心线程数；
    3) 当线程数小于核心线程数且大于 1 的时候，如果核心线程允许闲置超时销毁，而且暂时没有
    等待运行的任务，线程池容量减一，让线程数逐步减少到 1；
    4) 当线程数减少到 1 时，因为线程池处于待关闭状态，且任务等待队列不为空，这个线程会被
    保留用于处理等待运行的任务
    3. 线程池在停止(STOP)、整理(TIDYING)、终止(TERMINATED) 状态下，不会接受新任务，
    也不会处理等待队列中的任务，直接将线程池容量逐步清空</code></pre>
<p>说了这么多我们直降到了线程池的数量被减少了，但是 <strong><em>闲置的线程是怎么被清除的呢？</em></strong></p>
<p>让我们再回看一下 <code>getTask()</code> 方法中在将线程池的容量收缩之后，马上返回了一个 <code>null</code><br><img src="/assets/picture/thred.pool.get.task.reuturn.null.after.decrement.jpg" title="getTask() 线程池容量收缩后返回 null"></p>
<p>获取到的待运行任务为 null 时，就要开始清除这个线程了<br><img src="/assets/picture/thread.pool.executor.process.worker.exit.jpg" title="待运行任务为 null 时处理退出线程"></p>
<p>下面就是 <code>processWorkerExit</code> 方法的逻辑了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        workers.remove(w); <span class="comment">// 将线程从线程池中删除</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试终止线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池状态时 RUNNING 或者 SHUTDOWN 且线程运行过程中没有抛出异常时</span></span><br><span class="line">    <span class="comment">// 当线程池不允许核心线程闲置超时被销毁时，确保线程池有核心线程数的线程</span></span><br><span class="line">    <span class="comment">// 当线程池允许核心线程闲置超时被销毁时，确保线程池至少有一个线程</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>      总结：
      当等待队列中暂时没有待执行任务时，将线程池数量收缩之后，这里会将当前工作线程从线程池中清除掉
      当线程池状态是 SHUTDOWN 且任务等待队列为空时，这里还会尝试去终止线程池
      当线程池状态是 RUNNING 或者状态是 SHUTDOWN 且任务队列不为空是，我们需要有一定的线程去处理任务；
      这个时候当线程池允许核心线程闲置超时被销毁时，如果线程池为空，向线程池新增一个不带任务的线程；
      当线程池不允许核心线程闲置超时被销毁时，如果线程数量小于核心线程数，也向线程池新增一个不带任务的线程；

      总之是当线程池还在运行中，或者待关闭需要处理等待队列中的待运行任务时，保证线程池有一定的线程去处理
      这些任务</code></pre>
<p><strong><em>注意：线程池中的闲置线程在达到超时时间之后不一定会立刻被清除掉，而是在超时时间之后的某个时刻被清除掉</em></strong></p>
<h3 id="ThreadPoolExecutor-执行任务过程中的扩展操作"><a href="#ThreadPoolExecutor-执行任务过程中的扩展操作" class="headerlink" title="ThreadPoolExecutor 执行任务过程中的扩展操作"></a><code>ThreadPoolExecutor</code> 执行任务过程中的扩展操作</h3><p><code>ThreadPoolExecutor</code> 线程池在执行任务的过程中，支持进行一些扩展的插入操作</p>
<ul>
<li><code>terminated()</code>: 线程池终止前的插入操作</li>
</ul>
<p>在上面的状态流转说明中，线程池从 <code>TIDYING</code> 流转到 <code>TERMINATED</code> 状态之前，就是去调用 <code>terminated()</code> 方法，下面的代码就是具体逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    terminated(); <span class="comment">// 扩展插入操作</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>beforeExecute()</code> 和 <code>afterExecute()</code>: 任务执行前后的插入操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task); <span class="comment">// 执行任务之前的插入操作</span></span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown); <span class="comment">// 执行任务之后的插入操作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="通过-Executors-创建-ThreadPoolExecutor"><a href="#通过-Executors-创建-ThreadPoolExecutor" class="headerlink" title="通过 Executors 创建 ThreadPoolExecutor"></a>通过 <code>Executors</code> 创建 <code>ThreadPoolExecutor</code></h3><h4 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无界线程池，它的特性是</p>
<ul>
<li>corePoolSize 是 0</li>
<li>workQueue 任务等待队列是 <code>SynchronousQueue</code>，不存储任何元素，放入元素的时候直接返回 false</li>
<li>maximumPoolSize 是 INTEGER.MAX_VALUE</li>
</ul>
<p>上述特点意味着，向线程池提交任务之后，即超过了核心线程数，可以加入任务等待队列，但是 <code>SynchronousQueue</code> 不支持存储任何元素，线程池容量向 maximumPoolSize 发展，也就是 Integer.MAX_VALUE，线程池开始无限新建新线程</p>
<h4 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h4><p>固定大小的线程池的特性是</p>
<ul>
<li>任务阻塞等待队列的长度是无界的</li>
</ul>
<p>这意味着，线程池中线程数量达到核心线程数后，新提交的任务会进入无界等待队列(长度为 <code>Integer.MAX_VALUE</code>)，这意味 <code>线程池最大容量</code> 参数失去了意义，线程池中的线程数量不会超过核心线程数；</p>
<ul>
<li>闲置线程的存活时间是 0</li>
</ul>
<p>这表示，运行中的线程从任务等待队列中提取任务时，不会阻塞等待，</p>
<p>用户指定线程池和核心线程数和线程池最大容量，而且核心线程数和线程池容量一致，任务等待阻塞队列的长度是无界的，这意味着当线程数量超过核心线程数之后，新提交的任务被放入任务阻塞等待队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>注意：阿里巴巴 Java 开发规范要求我们不要使用 <code>Executors</code> 去创建上述两种 <code>ThreadPoolExecutor</code></em></strong></p>
<p><img src="/assets/picture/why.not.use.executors.jpg" title="Why can not use Executors to create ThreadPoolExecutor"></p>
<h4 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单线程线程池，它的特点是</p>
<ul>
<li>核心线程数和线程池容量都是 1</li>
<li>任务等待队列是无界的阻塞队列</li>
</ul>
<p>这意味着 ———— 向线程池提交任务之后，会创建唯一的线程，然后任务被放入阻塞等待队列，然后被唯一的线程一个个的处理</p>
<h3 id="关于线程池参数"><a href="#关于线程池参数" class="headerlink" title="关于线程池参数"></a>关于线程池参数</h3><h4 id="线程池大小"><a href="#线程池大小" class="headerlink" title="线程池大小"></a>线程池大小</h4><p>关于线程池的参数，所有所有资料都在告诉我们，线程池中的任务分为 IO 密集型和 CPU 密集型；在 《Java 并发编程实战》一书的 8.2 章节中我们可以学习到下面的结论：</p>
<p>CPU 密集型的任务特点是任务有大量计算，消耗 CPU 资源，CPU 占用率很高；执行这种任务的时候线程数过多，会发生很多线程抢占CPU 的情况，线程的上下文切换也比较浪费资源；所以对于 CPU 密集型的任务，我们需要的是 N<sub>cpu</sub> + 1 个线程，这里比 CPU 个数多一个的原因是，**<em>即使当计算密集型的线程偶尔由于页缺失故障或者其他原因而暂停时，这个额外的线程也能确保CPU的时钟周期不会被浪费。**</em></p>
<p>而对于其他任务，CPU 计算操作和 IO 操作是混合在一起的，对于这种CPU 使用率不会特别高的任务，线程池的容量可以大一点，对于这种任务多很多文章都说线程池容量可以设置成 2N，这个值没有什么准确的依据，只是个经验预估值，没什么参考价值；针对 IO密集型的任务，我们需要关注的是 CPU 计算时间和 CPU 等待时间的比例，以及 CPU  的目标使用率</p>
<hr>
<p>线程池容量 = N<sub>cpu</sub> * U<sub>cpu</sub> * (1 + W/C)<br>N<sub>cpu</sub>: CPU 个数<br>U<sub>cpu</sub>: 目标 CPU 使用率<br>W: CPU 等待时间<br>C: CPU 计算时间</p>
<hr>
<p>举例说明，现在有个任务，CPU 计算的时间是 10ms， IO 操作的时间是 90ms，理想情况下我们以 CPU 利用率 100% 为假定目标，这个时候对于一个 8 核的机器：<br>线程池容量 = 8 * 1 * (1 + 90/10) = 80；所以这里我们需要 80 个线程</p>
<p><strong><em>线程池的大小是根据目标 CPU 使用率计算出来的，所以这就是我们的能设置的最大的线程池容量了</em></strong></p>
<h4 id="任务等待队列"><a href="#任务等待队列" class="headerlink" title="任务等待队列"></a>任务等待队列</h4><h5 id="任务等待队列实现的选择"><a href="#任务等待队列实现的选择" class="headerlink" title="任务等待队列实现的选择"></a>任务等待队列实现的选择</h5><p>任务等待队列的类型是阻塞队列，下面先介绍一下阻塞队列，再说明如何选择任务等待队列的实现</p>
<h5 id="阻塞队列的特性"><a href="#阻塞队列的特性" class="headerlink" title="阻塞队列的特性"></a>阻塞队列的特性</h5><p>先看看 <code>BlockingQueue</code> 中的方法<br><img src="/assets/picture/blocking.queue.method.list.jpg" title="阻塞队列的方法列表"></p>
<p>下面是具体一点的方法列表</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>方法介绍</th>
<th>返回值</th>
<th>是否抛出异常</th>
<th>附加说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean add(E e)</td>
<td>向队列中添加元素</td>
<td>添加成功则返回 true</td>
<td>队列容量不足时，抛出 IllegalStateException</td>
<td>使用有界队列的时候，推荐使用 offer(E) 方法</td>
</tr>
<tr>
<td>boolean offer(E e)</td>
<td>向队列中添加元素</td>
<td>添加成功返回true， 否则返回 false</td>
<td>-</td>
<td>使用有界队列的时候，优先于 add(E) 方法被使用</td>
</tr>
<tr>
<td>boolean offer(E e, long timeout, TimeUnit)</td>
<td>向队列中添加元素</td>
<td>添加成功返回true， 否则返回 false，超时也返回 false</td>
<td>被中断时抛出 InterruptedException</td>
<td>使用有界队列的时候，优先于 add(E) 方法被使用</td>
</tr>
<tr>
<td>void put(E e)</td>
<td>向队列中添加元素</td>
<td>无</td>
<td>被中断的时候抛出 InterruptedException</td>
<td>一直阻塞，直至成功或失败</td>
</tr>
<tr>
<td>E remove()</td>
<td>删除队列头第一个元素</td>
<td>删除成功时，返回被删除的元素</td>
<td>队列头为空时抛出 NoSuchElementException</td>
<td>-</td>
</tr>
<tr>
<td>boolean remove(E e)</td>
<td>删除指定元素</td>
<td>删除成功时返回 true，反正返回 false</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>E poll()</td>
<td>删除并返回队列头元素或者null</td>
<td>返回队列头元素，队列为空时返回 null</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>E poll(long timeout, TimeUnit unit)</td>
<td>删除并返回队列头元素或者null</td>
<td>返回队列头元素，队列为空或者超时的时候返回 null</td>
<td>被中断时抛出 InterruptedException</td>
<td>没有命中元素时，阻塞直至超时</td>
</tr>
<tr>
<td>E take()</td>
<td>删除并返回队列头元素或者null</td>
<td>返回队列头元素</td>
<td>被中断时抛出 InterruptedException</td>
<td>一直阻塞，直至成功或失败</td>
</tr>
<tr>
<td>E element()</td>
<td>返回队列头元素，但是不删除</td>
<td>返回队列头元素</td>
<td>没有命中任何元素的时候抛出 NoSuchElementException</td>
<td>-</td>
</tr>
<tr>
<td>E peek()</td>
<td>返回队列头元素或者 null，但是不删除</td>
<td>返回队列头元素或者null</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p>阻塞队列的特性就会提供了上述方法，分类以下几类</p>
<ul>
<li>一直阻塞等待的方法，可以被中断，put(E e) 新增元素，take() 获取并删除头元素</li>
<li>阻塞超时的方法，可以被中断，offer(E e, long timeout, TimeUnit) 新增元素， poll(long timeout, TimeUnit unit) 获取并删除头元素</li>
<li>抛出异常，add(E e) 新增元素，remove() 删除元素，element() 获取头元素</li>
<li>返回特征值，offer(E e) 新增失败返回false；poll() 没有命中时返回 null；peek() 没有命中时返回 null</li>
</ul>
<table>
<thead>
<tr>
<th>方法\处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞(可中断)</th>
<th>超时退出(可中断)</th>
</tr>
</thead>
<tbody><tr>
<td>插入元素</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e, time, unit)</td>
</tr>
<tr>
<td>返回队列头元素，并从队列中移除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>返回队列头元素，但不删除</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<p>方法的选用取决于我们是否需要立即同步获取操作结果，可以等待一定时长，还是可以一直等待</p>
<h6 id="阻塞队列的实现"><a href="#阻塞队列的实现" class="headerlink" title="阻塞队列的实现"></a>阻塞队列的实现</h6><p>先看看类图</p>
<p><img src="/assets/picture/blocking.queue.implements.class.diagram.png" title="阻塞队列的主要实现的类图"></p>
<p>主要实现的简要说明：</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>特性</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>LinkedBlockingQueue</td>
<td>由单向链表实现的先进先出的阻塞队列</td>
<td>可阻塞，入出队列锁分离，效率高，支持容量限制，可以作为无界队列的实现</td>
<td>由于存在锁机制，同时链表需要遍历才能定位一个元素，因此效率有一定的影响</td>
</tr>
<tr>
<td>ArrayBlockingQueue</td>
<td>由数组实现的先进先出的阻塞队列</td>
<td>可阻塞，支持容量限制，遍历元素的效率更快，可以作为有界队列的实现</td>
<td>容量固定，不支持扩容，出入队列不能同时进行</td>
</tr>
<tr>
<td>SynchronousQueue</td>
<td>每一个插入操作都必须等待另一个线程的移除操作，反之亦然；这意味同步队列没有容量，或者说容量为 1，元素被生产者放入同步队列之后，期待消费者移除处理之后生产者才能继续放入元素</td>
<td>可阻塞，快速交换元素</td>
<td>内部没有容量</td>
</tr>
<tr>
<td>PriorityBlockingQueue</td>
<td>按照自然排序实现的阻塞队列，在元素需要排序的情况下是唯一的选择</td>
<td>可阻塞，元素有序，支持扩容</td>
<td>出入队列比较慢，效率比较低，基于数组的实现每次扩容都需要复制数组，同时容量不能减小，入队列不能被阻塞</td>
</tr>
<tr>
<td>DelayQueue</td>
<td>基于 PriorityBlockingQueue 实现的延时处理队列，每个元素都有一个延时时间，当且仅当延时时间过期才能出队列</td>
<td>可阻塞，可延时</td>
<td>效率低，入队列不能被阻塞</td>
</tr>
</tbody></table>
<h6 id="阻塞队列的使用场景"><a href="#阻塞队列的使用场景" class="headerlink" title="阻塞队列的使用场景"></a>阻塞队列的使用场景</h6><p>从阻塞队列的特性来看，<br><code>LinkedBlockingQueue</code> 是无界阻塞队列的首选，但是线程池不推荐使用无界队列；<br>为了更好的控制线程池，需要一个有界阻塞队列，<code>ArrayBlockingQueue</code> 是实现首选；<br><code>PriorityBlockingQueue</code> 支持队列中元素排序，对于需要处理不同优先级的任务的线程池，最优选择是优先级阻塞队列，最好设置上长度；<br><code>DelayQueue</code> 主要作用是元素需要延时被延时处理，只有线程池需要处理的任务需要等待一定时间才能处理时，才会选择这种阻塞队列的实现；</p>
<p><strong><em>结论：一般情况下，使用有界阻塞队列 <code>ArrayBlockingQueue</code> 作为线程池的任务等待队列</em></strong></p>
<h5 id="任务等待队列的长度和闲置线程存活时间"><a href="#任务等待队列的长度和闲置线程存活时间" class="headerlink" title="任务等待队列的长度和闲置线程存活时间"></a>任务等待队列的长度和闲置线程存活时间</h5><p>为了线程池的可控，我们给线程池的任务等待队列设置一个可接受的大小，否则像 CachedThreadPool 一样设置一个无界阻塞队列，很容易就会因为队列过程而 OOM；考虑等待队列长、闲置线程存活时间和线程池容量这三个参数的时候，我们需要综合考虑，因为线程数超过核心线程数之后再提交的任务，会先先尝试放入任务等待队列，队列空间不足就会去创建非核心线程，非核心线程从阻塞队列中提取任务的等待时长就是 <code>闲置线程的存活时间</code>，超过这个时间非核心线程就可能会被回收，也就是说 <strong><em>任务等待队列的核心功能就是将核心线程暂时无法忙碌无法处理的任务缓存起来；核心线程忙碌的情况下，如果等待队列没有空的情况下，队列中的任务都需要等待线程来处理</em></strong> ；</p>
<p>任务等待队列的长度，首先需要保证能够缓存所有的任务，其次缓存在队列中的任务的等待时长必须在业务可接受范围内；</p>
<ul>
<li>在核心线程忙碌，任务进入等待队列的阶段，任务处理的最大时长是 </li>
</ul>
<hr>
<p>T<sub>task</sub> = ceil(workQueue.length / coorPoolSize) * T<sub>process</sub> + T<sub>process</sub><br>T<sub>task</sub>: 核心线程忙碌时，任务处理总时长<br>workQueue.length: 任务等待队列的长度<br>coorPoolSize: 核心线程数<br>T<sub>process</sub>: 任务实际处理时长<br>ceil(): 向上取整的函数</p>
<hr>
<p>在这个情况下，任务队列的长度，取决于业务能接受的任务最大处理时长，假定业务能接受的任务处理时长</p>
<ul>
<li>在任务等待度列满了之后，创建了非核心线程之后，任务处理的最大时长是</li>
</ul>
<hr>
<p>T<sub>task</sub> = ceil(workQueue.length / poolSize) * keepAliveTime + T<sub>process</sub><br>T<sub>task</sub>: 核心线程忙碌时，任务处理总时长<br>workQueue.length: 任务等待队列的长度<br>poolSize: 线程池中工作线程数<br>keepAliveTime: 闲置线程存活时间<br>T<sub>process</sub>: 任务实际处理时长<br>ceil(): 向上取整的函数</p>
<hr>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql explain 介绍</title>
    <url>/2016/09/08/%E6%8A%80%E6%9C%AF/mysql/2016-09-08-mysql%20explain%20%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="explain-指令"><a href="#explain-指令" class="headerlink" title="explain 指令"></a><code>explain</code> 指令</h2><p>在日常使用 mysql 的过程中，我们需要查看表结构设计，或者查看sql 执行计划；mysql 提供了一个指令 ———— <code>explain</code>，它有以下功能：</p>
<pre><code>    1. 查看表结构信息
    2. 查看sql 执行计划信息 
    3. mysql 8.18 版本以上，还支持 [explain analyze]</code></pre>
<p><strong><em>注意：<br/> 1. 在 <code>mysql 5.6</code> 之前 <code>explain</code> 只能分析 <code>select</code> 语句，其他类型的语句只能先改写为 <code>select</code> 语句再分析； 但是 <code>mysql 5.6</code> 及以后， <code>explain</code> 支持其他语句的解析 <br/> 2. <code>explain</code> 指令还有一个同名的指令 <code>describe</code>。</em></strong></p>
<h3 id="explain-查看表结构"><a href="#explain-查看表结构" class="headerlink" title="explain 查看表结构"></a><code>explain</code> 查看表结构</h3><p><code>explain</code> 和 <code>describe</code> 都能查看表结构信息，实例如下</p>
<pre><code>    mysql&gt; explain TABLES;
    +-----------------+--------------------------------------------------------------------+------+-----+---------+-------+
    | Field           | Type                                                               | Null | Key | Default | Extra |
    +-----------------+--------------------------------------------------------------------+------+-----+---------+-------+
    | TABLE_CATALOG   | varchar(64)                                                        | YES  |     | NULL    |       |
    | TABLE_SCHEMA    | varchar(64)                                                        | YES  |     | NULL    |       |
    | TABLE_NAME      | varchar(64)                                                        | YES  |     | NULL    |       |
    | TABLE_TYPE      | enum(&#39;BASE TABLE&#39;,&#39;VIEW&#39;,&#39;SYSTEM VIEW&#39;)                            | NO   |     | NULL    |       |
    | ENGINE          | varchar(64)                                                        | YES  |     | NULL    |       |
    | VERSION         | int(2)                                                             | YES  |     | NULL    |       |
    | ROW_FORMAT      | enum(&#39;Fixed&#39;,&#39;Dynamic&#39;,&#39;Compressed&#39;,&#39;Redundant&#39;,&#39;Compact&#39;,&#39;Paged&#39;) | YES  |     | NULL    |       |
    | TABLE_ROWS      | bigint(21) unsigned                                                | YES  |     | NULL    |       |
    | AVG_ROW_LENGTH  | bigint(21) unsigned                                                | YES  |     | NULL    |       |
    | DATA_LENGTH     | bigint(21) unsigned                                                | YES  |     | NULL    |       |
    | MAX_DATA_LENGTH | bigint(21) unsigned                                                | YES  |     | NULL    |       |
    | INDEX_LENGTH    | bigint(21) unsigned                                                | YES  |     | NULL    |       |
    | DATA_FREE       | bigint(21) unsigned                                                | YES  |     | NULL    |       |
    | AUTO_INCREMENT  | bigint(21) unsigned                                                | YES  |     | NULL    |       |
    | CREATE_TIME     | timestamp                                                          | NO   |     | NULL    |       |
    | UPDATE_TIME     | datetime                                                           | YES  |     | NULL    |       |
    | CHECK_TIME      | datetime                                                           | YES  |     | NULL    |       |
    | TABLE_COLLATION | varchar(64)                                                        | YES  |     | NULL    |       |
    | CHECKSUM        | bigint(21)                                                         | YES  |     | NULL    |       |
    | CREATE_OPTIONS  | varchar(256)                                                       | YES  |     | NULL    |       |
    | TABLE_COMMENT   | text                                                               | YES  |     | NULL    |       |
    +-----------------+--------------------------------------------------------------------+------+-----+---------+-------+
    21 rows in set (0.00 sec)</code></pre>
<p><code>explain table_name</code> 指令可以说是 <code>show columns from table_name</code> 指令的缩写，可以查看表结构中的所有的列信息；</p>
<p>查看表结构信息我们还可以使用以下指令 </p>
<p><code>show create table table_name</code>: 查看建表语句<br><code>show table status [&#123;in | from&#125; db_name] [like &#39;pattern&#39; | where expr]</code>: 查看数据库中的数据表概要信息，具体见<a href="https://dev.mysql.com/doc/refman/8.0/en/show-table-status.html" title="show table status">文档</a><br><code>show index [&#123;in | from&#125; table_name]</code>: 查看表结构中的索引信息，具体见<a href="https://dev.mysql.com/doc/refman/8.0/en/show-index.html" title="show index">文档</a></p>
<h3 id="explain-查看执行计划情况"><a href="#explain-查看执行计划情况" class="headerlink" title="explain 查看执行计划情况"></a><code>explain</code> 查看执行计划情况</h3><p>先来个使用范例</p>
<pre><code>explain select sql
如：
explain select * from grade_info where teacher_id = &#39;1&#39;;</code></pre>
<p>下面看看 <code>explain</code> 的执行结果：<br><img src="/assets/picture/mysql_index_a.png" alt="图片" title="使用索引第一列的情况"><br><code>explain</code> 的结果有这些列<br /><br> <code>id</code>, <code>select_type</code>, <code>table</code>, <code>partitions</code>, <code>type</code>, <code>possible_keys</code>, <code>key</code>, <code>key_len</code>, <code>ref</code>, <code>rows</code>, <code>filtered</code>, <code>Extra</code></p>
<h4 id="explain-查看执行计划输出字段概要说明"><a href="#explain-查看执行计划输出字段概要说明" class="headerlink" title="explain 查看执行计划输出字段概要说明"></a><code>explain</code> 查看执行计划输出字段概要说明</h4><table>
<thead>
<tr>
<th>列名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>sql 语句中多个嵌套语句的唯一标识，如果只有一条 sql 始终为 1</td>
</tr>
<tr>
<td>select_type</td>
<td>select 语句的类型，或其他语句的类型（较高版本中 explain 支持 delete,update,insert 等语句）</td>
</tr>
<tr>
<td>table</td>
<td>表名称，或者 sql 中表的别名</td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区</td>
</tr>
<tr>
<td>type</td>
<td>连接类型</td>
</tr>
<tr>
<td>possible_keys</td>
<td>可能被用到的索引名称</td>
</tr>
<tr>
<td>key</td>
<td>实际被使用的索引的名称</td>
</tr>
<tr>
<td>key_len</td>
<td>被选用的索引实际被使用的长度</td>
</tr>
<tr>
<td>ref</td>
<td>和索引比较的列，todo</td>
</tr>
<tr>
<td>rows</td>
<td>将要被检查的行数的估计值</td>
</tr>
<tr>
<td>filtered</td>
<td>被“表”条件过滤的行数的百分比</td>
</tr>
<tr>
<td>Extra</td>
<td>附加信息</td>
</tr>
</tbody></table>
<h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>sql 语句执行顺序号， 就是sql 语句的执行顺序<br><img src="/assets/picture/mysql_nested_sql_explain.png" alt="图片" title="mysql嵌套语句"><br>这里可以看到 id 的变化</p>
<h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h4><p>select 语句的类型</p>
<p><strong>*注意：非 <code>select</code> 语句的 <code>select_type</code> 就是该语句的类型，如 <code>delete</code> 语句的 <code>select_type</code> 就是 <code>delete</code> *</strong></p>
<table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SIMPLE</td>
<td>简单的查询语句（没有子查询，也没有 UNION）</td>
</tr>
<tr>
<td>PRIMARY</td>
<td>在外层的select 语句</td>
</tr>
<tr>
<td>UNION</td>
<td>UNION 查询中第二个或者第二个之后的 select 语句</td>
</tr>
<tr>
<td>DEPENDENT UNION</td>
<td>UNION 查询中第二个或者第二个之后的, 并且依赖外部查询语句的 select 语句</td>
</tr>
<tr>
<td>UNION RESULT</td>
<td>UNION 查询的结果</td>
</tr>
<tr>
<td>SUBQUERY</td>
<td>子查询中的第一个 select 语句</td>
</tr>
<tr>
<td>DEPENDENT SUBQUERY</td>
<td>子查询中的第一个，依赖外部查询语句的 select 语句</td>
</tr>
<tr>
<td>DERIVED</td>
<td>派生表查询</td>
</tr>
<tr>
<td>DEPENDENT DERIVED</td>
<td>依赖其他表的派生表查询</td>
</tr>
<tr>
<td>MATERIALIZED</td>
<td></td>
</tr>
<tr>
<td>UNCACHEABLE SUBQUERY</td>
<td>查询结果不能被缓存，每一行查询结果都必须被外部查询语句评估的子查询语句</td>
</tr>
<tr>
<td>UNCACHEABLE UNION</td>
<td>UNION 查询中第二个或者第二个之后的属于 <code>UNCACHEABLE SUBQUERY</code> 类型的子查询语句</td>
</tr>
</tbody></table>
<h5 id="SIMPLE-没有UNION-也没有子查询的简单查询语句"><a href="#SIMPLE-没有UNION-也没有子查询的简单查询语句" class="headerlink" title="SIMPLE 没有UNION 也没有子查询的简单查询语句"></a>SIMPLE 没有UNION 也没有子查询的简单查询语句</h5><pre><code>mysql&gt; explain select * from Employee;
+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | Employee | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    6 |   100.00 | NULL  |
+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)</code></pre>
<h5 id="PRIMARY-有子查询或者-UNION查询中最外层的查询语句"><a href="#PRIMARY-有子查询或者-UNION查询中最外层的查询语句" class="headerlink" title="PRIMARY 有子查询或者 UNION查询中最外层的查询语句"></a>PRIMARY 有子查询或者 UNION查询中最外层的查询语句</h5><pre><code>mysql&gt; explain select * from Employee where id = (select id from Employee where id = 5);
+----+-------------+----------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
| id | select_type | table    | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |
+----+-------------+----------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
|  1 | PRIMARY     | Employee | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL        |
|  2 | SUBQUERY    | Employee | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | Using index |
+----+-------------+----------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)

mysql&gt; explain select id from Employee where id = 5 union all select id from Employee2;
+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
| id | select_type | table     | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |
+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
|  1 | PRIMARY     | Employee  | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | Using index |
|  2 | UNION       | Employee2 | NULL       | ALL   | NULL          | NULL    | NULL    | NULL  |    7 |   100.00 | NULL        |
+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)</code></pre>
<h5 id="UNION-UNION查询中第二个或者第二个之后的-select-语句"><a href="#UNION-UNION查询中第二个或者第二个之后的-select-语句" class="headerlink" title="UNION: UNION查询中第二个或者第二个之后的 select 语句"></a>UNION: UNION查询中第二个或者第二个之后的 select 语句</h5><pre><code>mysql&gt; explain select id from Employee where id = 5 union all select id from Employee2 union all select id from Employee2;
+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
| id | select_type | table     | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |
+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
|  1 | PRIMARY     | Employee  | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | Using index |
|  2 | UNION       | Employee2 | NULL       | ALL   | NULL          | NULL    | NULL    | NULL  |    7 |   100.00 | NULL        |
|  3 | UNION       | Employee2 | NULL       | ALL   | NULL          | NULL    | NULL    | NULL  |    7 |   100.00 | NULL        |
+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
3 rows in set, 1 warning (0.00 sec)</code></pre>
<h5 id="DEPENDENT-UNION-UNION-查询中第二个或者第二个之后的-并且依赖外部查询语句的-select-语句"><a href="#DEPENDENT-UNION-UNION-查询中第二个或者第二个之后的-并且依赖外部查询语句的-select-语句" class="headerlink" title="DEPENDENT UNION: UNION 查询中第二个或者第二个之后的, 并且依赖外部查询语句的 select 语句"></a>DEPENDENT UNION: UNION 查询中第二个或者第二个之后的, 并且依赖外部查询语句的 select 语句</h5><p><strong><em>DEPENDENT UNION 是什么意思？？？</em></strong></p>
<pre><code>mysql&gt; explain select * from Employee where id in (select id from Employee where id = 5 union all select id from Employee2 union all select id from Employee2);
+----+--------------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
| id | select_type        | table     | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |
+----+--------------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
|  1 | PRIMARY            | Employee  | NULL       | ALL   | NULL          | NULL    | NULL    | NULL  |    6 |   100.00 | Using where |
|  2 | DEPENDENT SUBQUERY | Employee  | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | Using index |
|  3 | DEPENDENT UNION    | Employee2 | NULL       | ALL   | NULL          | NULL    | NULL    | NULL  |    7 |    14.29 | Using where |
|  4 | DEPENDENT UNION    | Employee2 | NULL       | ALL   | NULL          | NULL    | NULL    | NULL  |    7 |    14.29 | Using where |
+----+--------------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
4 rows in set, 1 warning (0.00 sec)</code></pre>
<h5 id="UNION-RESULT-UNION-查询结果"><a href="#UNION-RESULT-UNION-查询结果" class="headerlink" title="UNION RESULT: UNION 查询结果"></a>UNION RESULT: UNION 查询结果</h5><pre><code>mysql&gt; explain select * from Employee union select * from Employee2;
+------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
|  id  | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |
+------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
|  1   | PRIMARY      | Employee   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    6 |   100.00 | NULL            |
|  2   | UNION        | Employee2  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    7 |   100.00 | NULL            |
| NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | Using temporary |
+------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
3 rows in set, 1 warning (0.01 sec)</code></pre>
<h5 id="SUBQUERY-子查询中第一个-select-语句"><a href="#SUBQUERY-子查询中第一个-select-语句" class="headerlink" title="SUBQUERY: 子查询中第一个 select 语句"></a>SUBQUERY: 子查询中第一个 select 语句</h5><pre><code>mysql&gt; explain select * from Employee where id = (select id from Employee where id = 5);
+----+-------------+----------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
| id | select_type | table    | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |
+----+-------------+----------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
|  1 | PRIMARY     | Employee | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL        |
|  2 | SUBQUERY    | Employee | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | Using index |
+----+-------------+----------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)</code></pre>
<h5 id="DEPENDENT-SUBQUERY-引用了外部查询结果或者变量的子查询"><a href="#DEPENDENT-SUBQUERY-引用了外部查询结果或者变量的子查询" class="headerlink" title="DEPENDENT SUBQUERY: 引用了外部查询结果或者变量的子查询"></a>DEPENDENT SUBQUERY: 引用了外部查询结果或者变量的子查询</h5><pre><code>mysql&gt; explain select * from Employee where id in (select id from Employee where id = 5 union all select id from Employee2);
+----+--------------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
| id | select_type        | table     | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |
+----+--------------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
|  1 | PRIMARY            | Employee  | NULL       | ALL   | NULL          | NULL    | NULL    | NULL  |    6 |   100.00 | Using where |
|  2 | DEPENDENT SUBQUERY | Employee  | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | Using index |
|  3 | DEPENDENT UNION    | Employee2 | NULL       | ALL   | NULL          | NULL    | NULL    | NULL  |    7 |    14.29 | Using where |
+----+--------------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
3 rows in set, 1 warning (0.00 sec)</code></pre>
<p>关联子查询除了上面举的例子之外，<code>having</code>, <code>group by</code> 等其他语句引用外部查询结果或者变量的时候也会成为关联子查询</p>
<p><strong><em><code>DEPENDENT SUBQUERY</code> 是低效的，如果能转化为 join 语句，效率会好很多</em></strong></p>
<h5 id="DERIVED-查询过程中的衍生表查询"><a href="#DERIVED-查询过程中的衍生表查询" class="headerlink" title="DERIVED: 查询过程中的衍生表查询"></a>DERIVED: 查询过程中的衍生表查询</h5><pre><code>mysql&gt; explain select * from Employee e join  (select id from Employee union select id from Employee2) a on e.id = a.id;
+------+--------------+------------+------------+-------+---------------+-------------+---------+-----------+------+----------+-----------------+
|  id  | select_type  | table      | partitions | type  | possible_keys | key         | key_len | ref       | rows | filtered | Extra           |
+------+--------------+------------+------------+-------+---------------+-------------+---------+-----------+------+----------+-----------------+
|   1  | PRIMARY      | e          | NULL       | ALL   | PRIMARY       | NULL        | NULL    | NULL      |    6 |   100.00 | NULL            |
|   1  | PRIMARY      | &lt;derived2&gt; | NULL       | ref   | &lt;auto_key0&gt;   | &lt;auto_key0&gt; | 4       | test.e.Id |    2 |   100.00 | Using index     |
|   2  | DERIVED      | Employee   | NULL       | index | NULL          | PRIMARY     | 4       | NULL      |    6 |   100.00 | Using index     |
|   3  | UNION        | Employee2  | NULL       | ALL   | NULL          | NULL        | NULL    | NULL      |    7 |   100.00 | NULL            |
| NULL | UNION RESULT | &lt;union2,3&gt; | NULL       | ALL   | NULL          | NULL        | NULL    | NULL      | NULL |     NULL | Using temporary |
+------+--------------+------------+------------+-------+---------------+-------------+---------+-----------+------+----------+-----------------+
5 rows in set, 1 warning (0.00 sec)</code></pre>
<h5 id="DEPENDENT-DERIVED-依赖外部查询的衍生表查询"><a href="#DEPENDENT-DERIVED-依赖外部查询的衍生表查询" class="headerlink" title="DEPENDENT DERIVED: 依赖外部查询的衍生表查询"></a>DEPENDENT DERIVED: 依赖外部查询的衍生表查询</h5><h5 id="MATERIALIZED-物化子查询"><a href="#MATERIALIZED-物化子查询" class="headerlink" title="MATERIALIZED: 物化子查询"></a>MATERIALIZED: 物化子查询</h5><p>通过在内存中用临时表去缓存子查询结果来优化子查询结果来优化子查询效率，但当临时表过大的时候也会落盘到磁盘中；物化子查询通过临时表避免子查询每次都被触发，最好只被触发一次；</p>
<p>物化子查询的开关是可以通过变量设置的，变量 <code>optimizer_switch</code> 中的 <code>materialization</code></p>
<pre><code>mysql&gt; SELECT @@optimizer_switch\G
*************************** 1. row ***************************
@@optimizer_switch: index_merge=on,index_merge_union=on,
                    index_merge_sort_union=on,index_merge_intersection=on,
                    engine_condition_pushdown=on,index_condition_pushdown=on,
                    mrr=on,mrr_cost_based=on,block_nested_loop=on,
                    batched_key_access=off,materialization=on,semijoin=on,
                    loosescan=on,firstmatch=on,duplicateweedout=on,
                    subquery_materialization_cost_based=on,
                    use_index_extensions=on,condition_fanout_filter=on,
                    derived_merge=on,use_invisible_indexes=off,skip_scan=on,
                    hash_join=on</code></pre>
<p>物化子查询触发场景有：</p>
<ol>
<li>如下形式sql 中，外部查询中的 <code>oe_N</code> 不为空或者内部子查询 <code>ie_N</code> 不为空，<code>N</code> 大于等于1<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(oe_1, oe_2, ..., oe_N) [NOT] IN (<span class="keyword">SELECT</span> ie_1, i_2, ..., ie_N ...)</span><br></pre></td></tr></table></figure></li>
<li>如下形式sql 中，外部查询中只有单个表达式 <code>oe</code>，内存子查询也只有一个表达式 <code>ie</code>，表达式可以为空<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">oe [NOT] IN (<span class="keyword">SELECT</span> ie ...)</span><br></pre></td></tr></table></figure></li>
<li>查询结果为<code>UNKNOWN(NULL)</code> 表示 <code>false</code> 含义的<code>IN</code> 或 <code>NOT IN</code> 语句</li>
</ol>
<p><strong><em>注意：物化子查询存在使用限制</em></strong><br><strong><em>1. 物化子查询必须是子查询结果和外部查询结果的变量类型是一致的，都是Integer 或者都是Long 或者其他类型</em></strong><br><strong><em>2. 物化子查询不支持查询结果类型是 BLOB 类型的子查询</em></strong></p>
<h5 id="UNCACHEABLE-SUBQUERY-不可缓存的子查询，每一层外部查询都会触发一次子查询"><a href="#UNCACHEABLE-SUBQUERY-不可缓存的子查询，每一层外部查询都会触发一次子查询" class="headerlink" title="UNCACHEABLE SUBQUERY: 不可缓存的子查询，每一层外部查询都会触发一次子查询"></a>UNCACHEABLE SUBQUERY: 不可缓存的子查询，每一层外部查询都会触发一次子查询</h5><h5 id="UNCACHEABLE-UNION-不可缓存的-UNION-查询，每一层外部查询都会触发一次子查询"><a href="#UNCACHEABLE-UNION-不可缓存的-UNION-查询，每一层外部查询都会触发一次子查询" class="headerlink" title="UNCACHEABLE UNION: 不可缓存的 UNION 查询，每一层外部查询都会触发一次子查询"></a>UNCACHEABLE UNION: 不可缓存的 UNION 查询，每一层外部查询都会触发一次子查询</h5><h4 id="table-查询的表名"><a href="#table-查询的表名" class="headerlink" title="table: 查询的表名"></a><code>table</code>: 查询的表名</h4><ol>
<li><p>查询的表名</p>
</li>
<li><p>查询中指定的表的别名</p>
</li>
<li><p><derived N> 衍生临时表的名称，id 为 N 的表的部分数据的衍生临时表</p>
</li>
<li><p>&lt;union M,N&gt; id 为M，N 的表的连接查询结果</p>
</li>
<li><p><subquery N> 物化子查询 N 的引用</p>
<pre><code> mysql&gt; explain select e.id from Employee e join (select id from Employee union select id from Employee2) a on e.id = a.id;
 +----+--------------+------------+------------+-------+---------------+-------------+---------+-----------+------+----------+-----------------+
 | id | select_type  | table      | partitions | type  | possible_keys | key         | key_len | ref       | rows | filtered | Extra           |
 +----+--------------+------------+------------+-------+---------------+-------------+---------+-----------+------+----------+-----------------+
 |  1 | PRIMARY      | e          | NULL       | index | PRIMARY       | PRIMARY     | 4       | NULL      |    6 |   100.00 | Using index     |
 |  1 | PRIMARY      | &lt;derived2&gt; | NULL       | ref   | &lt;auto_key0&gt;   | &lt;auto_key0&gt; | 4       | test.e.Id |    2 |   100.00 | Using index     |
 |  2 | DERIVED      | Employee   | NULL       | index | NULL          | PRIMARY     | 4       | NULL      |    6 |   100.00 | Using index     |
 |  3 | UNION        | Employee2  | NULL       | ALL   | NULL          | NULL        | NULL    | NULL      |    7 |   100.00 | NULL            |
 | NULL | UNION RESULT | &lt;union2,3&gt; | NULL       | ALL   | NULL          | NULL        | NULL    | NULL      | NULL |     NULL | Using temporary |
 +----+--------------+------------+------------+-------+---------------+-------------+---------+-----------+------+----------+-----------------+
 5 rows in set, 1 warning (0.00 sec)

 mysql&gt; explain select * from Employee e1 where e1.id = any (select e2.id from Employee2 e2 where e2.Salary = e1.Salary);
 +----+--------------+-------------+------------+--------+---------------+------------+---------+---------------------------+------+----------+-------------+
 | id | select_type  | table       | partitions | type   | possible_keys | key        | key_len | ref                       | rows | filtered | Extra       |
 +----+--------------+-------------+------------+--------+---------------+------------+---------+---------------------------+------+----------+-------------+
 |  1 | SIMPLE       | e1          | NULL       | ALL    | PRIMARY       | NULL       | NULL    | NULL                      |    6 |   100.00 | Using where |
 |  1 | SIMPLE       | &lt;subquery2&gt; | NULL       | eq_ref | &lt;auto_key&gt;    | &lt;auto_key&gt; | 12      | test.e1.Id,test.e1.Salary |    1 |   100.00 | NULL        |
 |  2 | MATERIALIZED | e2          | NULL       | ALL    | NULL          | NULL       | NULL    | NULL                      |    7 |   100.00 | NULL        |
 +----+--------------+-------------+------------+--------+---------------+------------+---------+---------------------------+------+----------+-------------+
 3 rows in set, 2 warnings (0.00 sec)</code></pre>
</li>
</ol>
<h4 id="partition-分区信息（暂不介绍）"><a href="#partition-分区信息（暂不介绍）" class="headerlink" title="partition 分区信息（暂不介绍）"></a><code>partition</code> 分区信息（暂不介绍）</h4><h4 id="type-连接类型"><a href="#type-连接类型" class="headerlink" title="type: 连接类型"></a><code>type</code>: 连接类型</h4><h5 id="system-查询的表只有一行数据，是-const-连接类型的一种特殊形式"><a href="#system-查询的表只有一行数据，是-const-连接类型的一种特殊形式" class="headerlink" title="system: 查询的表只有一行数据，是 const 连接类型的一种特殊形式"></a><code>system</code>: 查询的表只有一行数据，是 <code>const</code> 连接类型的一种特殊形式</h5><h5 id="const-查询条件完全匹配唯一索引或者主键索引，且只有最多一行符合查询条件的数据"><a href="#const-查询条件完全匹配唯一索引或者主键索引，且只有最多一行符合查询条件的数据" class="headerlink" title="const: 查询条件完全匹配唯一索引或者主键索引，且只有最多一行符合查询条件的数据"></a><code>const</code>: 查询条件完全匹配唯一索引或者主键索引，且只有最多一行符合查询条件的数据</h5><p>因为只有一行数据符合查询条件，所以后续的查询优化器可以把这个查询条件看作是常量的比较查询</p>
<h5 id="eq-ref-当前表和前一个表关联查询的时候，查询条件完全匹配不为空的唯一索引或者主键索引，且每个关联条件只有一行符合查询条件的数据"><a href="#eq-ref-当前表和前一个表关联查询的时候，查询条件完全匹配不为空的唯一索引或者主键索引，且每个关联条件只有一行符合查询条件的数据" class="headerlink" title="eq_ref: 当前表和前一个表关联查询的时候，查询条件完全匹配不为空的唯一索引或者主键索引，且每个关联条件只有一行符合查询条件的数据"></a><code>eq_ref</code>: 当前表和前一个表关联查询的时候，查询条件完全匹配不为空的唯一索引或者主键索引，且每个关联条件只有一行符合查询条件的数据</h5><p><strong><em>注意: <code>eq_ref</code> 和 <code>const</code> 有一点不一样，前者要求匹配的唯一索引是不允许为空的唯一索引，而后者没这个限制</em></strong></p>
<p><code>eq_ref</code> 是当前表和前一个表的关联查询，两者的关联查询支持 <code>=</code> 操作符；也可以说当前表和常量的 <code>=</code> 比较查询，示例如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.key_column=other_table.column;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.key_column_part1=other_table.column</span><br><span class="line">  <span class="keyword">AND</span> ref_table.key_column_part2=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>具体示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;名称&#x27;</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">3</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_general_ci <span class="keyword">COMMENT</span>=<span class="string">&#x27;学生信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student_info`</span> (</span><br><span class="line">  <span class="string">`student_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`email`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;email&#x27;</span>,</span><br><span class="line">  <span class="string">`phone`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;电话&#x27;</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`student_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_general_ci <span class="keyword">COMMENT</span>=<span class="string">&#x27;学生联系信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`grade`</span> (</span><br><span class="line">  <span class="string">`student_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`course_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  <span class="string">`grade`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;成绩&#x27;</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`student_course`</span> (<span class="string">`student_id`</span>,<span class="string">`course_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_general_ci <span class="keyword">COMMENT</span>=<span class="string">&#x27;学生成绩信息表&#x27;</span></span><br></pre></td></tr></table></figure>

<pre><code># grade.course_id = 1 且 grade.student_id = student.id 这个匹配条件下 每个&lt;student_id, course_id(1)&gt; 都只会查询到一个 grade 信息
mysql&gt; explain select * from grade g, student s where g.student_id = s.id and g.course_id = 1;
+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+
| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref             | rows | filtered | Extra |
+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+
|  1 | SIMPLE      | s     | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL            |    2 |   100.00 | NULL  |
|  1 | SIMPLE      | g     | NULL       | eq_ref | PRIMARY       | PRIMARY | 8       | test.s.id,const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+

mysql&gt; explain select s.id, si.student_id from student s,student_info si where s.id = si.student_id;
+----+-------------+-------+------------+--------+---------------+---------+---------+-----------+------+----------+-------------+
| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref       | rows | filtered | Extra       |
+----+-------------+-------+------------+--------+---------------+---------+---------+-----------+------+----------+-------------+
| 1  | SIMPLE      | s     | &lt;null&gt;     | index  | PRIMARY       | PRIMARY | 4       | &lt;null&gt;    | 2    | 100.0    | Using index |
| 1  | SIMPLE      | si    | &lt;null&gt;     | eq_ref | PRIMARY       | PRIMARY | 4       | test.s.id | 1    | 100.0    | Using index |
+----+-------------+-------+------------+--------+---------------+---------+---------+-----------+------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)</code></pre>
<h5 id="ref-通过-gt-lt-比较符号匹配非-唯一索引-和-主键索引-或者其他类型索引的左前缀查询到一行以上的数据，索引匹配是还可以是部分匹配"><a href="#ref-通过-gt-lt-比较符号匹配非-唯一索引-和-主键索引-或者其他类型索引的左前缀查询到一行以上的数据，索引匹配是还可以是部分匹配" class="headerlink" title="ref: 通过 =, &gt;=, &lt;= 比较符号匹配非 唯一索引 和 主键索引 或者其他类型索引的左前缀查询到一行以上的数据，索引匹配是还可以是部分匹配"></a><code>ref</code>: 通过 <code>=</code>, <code>&gt;=</code>, <code>&lt;=</code> 比较符号匹配非 <code>唯一索引</code> 和 <code>主键索引</code> 或者其他类型索引的左前缀查询到一行以上的数据，索引匹配是还可以是部分匹配</h5><p>示例：建表语句见上一小节</p>
<pre><code>mysql&gt; explain select * from grade g, student s where g.student_id = s.id;
+----+-------------+-------+------------+------+---------------+---------+---------+-----------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key     | key_len | ref       | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+---------+---------+-----------+------+----------+-------+
|  1 | SIMPLE      | s     | NULL       | ALL  | PRIMARY       | NULL    | NULL    | NULL      |    2 |   100.00 | NULL  |
|  1 | SIMPLE      | g     | NULL       | ref  | PRIMARY       | PRIMARY | 4       | test.s.id |    3 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+---------+---------+-----------+------+----------+-------+
2 rows in set, 1 warning (0.00 sec)</code></pre>
<h5 id="fulltext-全文索引的连接方式"><a href="#fulltext-全文索引的连接方式" class="headerlink" title="fulltext: 全文索引的连接方式"></a><code>fulltext</code>: 全文索引的连接方式</h5><h5 id="ref-or-null-和-ref-高度相似，只是会在匹配的时候判断索引列是否为空"><a href="#ref-or-null-和-ref-高度相似，只是会在匹配的时候判断索引列是否为空" class="headerlink" title="ref_or_null: 和 ref 高度相似，只是会在匹配的时候判断索引列是否为空"></a><code>ref_or_null</code>: 和 <code>ref</code> 高度相似，只是会在匹配的时候判断索引列是否为空</h5><p>实例如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`employee`</span> (</span><br><span class="line">  <span class="string">`Id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`Salary`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  <span class="string">`type`</span> <span class="built_in">tinyint</span>(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;类型&#x27;</span>,</span><br><span class="line">  <span class="string">`company_id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;公司id&#x27;</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`Id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`company_type`</span> (<span class="string">`company_id`</span>,<span class="string">`type`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_general_ci</span><br></pre></td></tr></table></figure>

<pre><code>mysql&gt; explain select * from employee where company_id = 1 or company_id is null;
+----+-------------+----------+------------+-------------+---------------+--------------+---------+-------+------+----------+-----------------------+
| id | select_type | table    | partitions | type        | possible_keys | key          | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+----------+------------+-------------+---------------+--------------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | employee | NULL       | ref_or_null | company_type  | company_type | 5       | const |    3 |   100.00 | Using index condition |
+----+-------------+----------+------------+-------------+---------------+--------------+---------+-------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)</code></pre>
<p>关联知识点：<a href="https://dev.mysql.com/doc/refman/8.0/en/is-null-optimization.html" title="IS NULL Optimization">Section 8.2.1.15, “IS NULL Optimization”.</a></p>
<h5 id="index-merge-索引合并优化"><a href="#index-merge-索引合并优化" class="headerlink" title="index_merge: 索引合并优化"></a><code>index_merge</code>: 索引合并优化</h5><p>索引合并优化将单个表的多个范围查询合并到一个查询结果中，不支持跨表合并；合并可以是交集(<code>intersection</code>)、并集(<code>union</code>)或者交集的并集<code>(unions of intersection)</code>；</p>
<pre><code>索引合并优化存在如下限制：
1. 在复查子查询中如果有深度嵌套的 AND/OR 语句，mysql 可能不会选择最优的优化算法，可以用如下方式拆分复杂语句

    (x AND y) OR z =&gt; (x OR z) AND (y OR z)
    (x OR y) AND z =&gt; (x AND z) OR (y AND z)

2. 索引合并优化不能作用于全文索引(fulltext-indexes)</code></pre>
<p>索引合并优化在 <code>explain</code> 指令输出列 <code>extra</code> 中会展示 </p>
<ol>
<li>并集 union(key1, key2)</li>
<li>交集 intersection(key1, key2)</li>
</ol>
<h6 id="交集访问算法"><a href="#交集访问算法" class="headerlink" title="交集访问算法"></a>交集访问算法</h6><ol>
<li>对于包含 N 列的组合索引，需要用 and 连接 N 个索引列和常数进行比较</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">key_part1 = const1 AND key_part2 = const2 ... AND key_partN = constN</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>InnoDB 表主键的范围查询</li>
</ol>
<p>index merge 交集访问算法会在使用多个索引同时进行读取扫描，并产生这些被读取数据的交集</p>
<p>如果被查询的结果列被使用的索引完全覆盖了（即索引包含所有被查询列），就不会在读取扫描索引之后再次去读取数据文件中的行数据。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> key1 = <span class="number">1</span> <span class="keyword">AND</span> key2 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>如果被查询的结果列不能被使用的索引完全覆盖，被索引范围查询匹配到的索引数据对应的的数据文件中的行数据就会被扫描读取；</p>
<p>如果索引合并的查询条件中存在覆盖InnoDB表的主键索引的查询条件，这个查询条件不会被用来扫描读取数据文件中的行数据，而是用来过滤其他查询条件查询出的数据。</p>
<h6 id="并集访问算法"><a href="#并集访问算法" class="headerlink" title="并集访问算法"></a>并集访问算法</h6><ol>
<li>对于包含 N 列的组合索引，需要用 or 连接 N 个索引列和常数进行比较</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">key_part1 = const1 AND key_part2 = const2 ... AND key_partN = constN</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>InnoDB 主键索引的任何范围查询</p>
</li>
<li><p>索引合并优化交集访问算法适用的条件，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1</span><br><span class="line">  <span class="keyword">WHERE</span> key1 = <span class="number">1</span> <span class="keyword">OR</span> key2 = <span class="number">2</span> <span class="keyword">OR</span> key3 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> innodb_table</span><br><span class="line">  <span class="keyword">WHERE</span> (key1 = <span class="number">1</span> <span class="keyword">AND</span> key2 = <span class="number">2</span>)</span><br><span class="line">     <span class="keyword">OR</span> (key3 = <span class="string">&#x27;foo&#x27;</span> <span class="keyword">AND</span> key4 = <span class="string">&#x27;bar&#x27;</span>) <span class="keyword">AND</span> key5 = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h6 id="排序并集访问算法"><a href="#排序并集访问算法" class="headerlink" title="排序并集访问算法"></a>排序并集访问算法</h6><p>通过 or 连接范围查询，且不不适用于并集访问算法的查询条件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_col1 &lt; <span class="number">10</span> <span class="keyword">OR</span> key_col2 &lt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> (key_col1 &gt; <span class="number">10</span> <span class="keyword">OR</span> key_col2 = <span class="number">20</span>) <span class="keyword">AND</span> nonkey_col = <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<p><code>排序并集访问算法</code> 和 <code>并集访问算法</code> 的区别在于 <code>排序并集访问算法</code> 首先要先获取所有满足条件的数据的 Row Id， 按照 Row Id 排序之后再返回查询结果</p>
<h6 id="索引合并算法的参数化配置"><a href="#索引合并算法的参数化配置" class="headerlink" title="索引合并算法的参数化配置"></a>索引合并算法的参数化配置</h6><p>可以通过 <code>optimizer_switch</code> 系统参数中的 <code>index_merge</code>、<code>index_merge_intersection</code>、<code>index_merge_union</code> 以及 <code>index_merge_sort_union</code> 标识控制 <code>Index Merge</code>的使用。<br>默认配置下，这些标识都是 <code>启用状态-on</code>。如果只想启用特定的某种算法，则可以设置index_merge为off，然后将相应启用算法的标识设置为on即可。</p>
<h5 id="ALL-全表扫描，按照行的顺序从头到尾读取去找到符合条件的行"><a href="#ALL-全表扫描，按照行的顺序从头到尾读取去找到符合条件的行" class="headerlink" title="ALL: 全表扫描，按照行的顺序从头到尾读取去找到符合条件的行"></a><code>ALL</code>: 全表扫描，按照行的顺序从头到尾读取去找到符合条件的行</h5><h5 id="index-和全表扫描一样，但是是按照索引的存储顺序从头到尾读取去找到符合条件的行；优点是可以避免排序，缺点是会随机访问行"><a href="#index-和全表扫描一样，但是是按照索引的存储顺序从头到尾读取去找到符合条件的行；优点是可以避免排序，缺点是会随机访问行" class="headerlink" title="index: 和全表扫描一样，但是是按照索引的存储顺序从头到尾读取去找到符合条件的行；优点是可以避免排序，缺点是会随机访问行"></a><code>index</code>: 和全表扫描一样，但是是按照索引的存储顺序从头到尾读取去找到符合条件的行；优点是可以避免排序，缺点是会随机访问行</h5><h5 id="unique-subquery"><a href="#unique-subquery" class="headerlink" title="unique_subquery"></a><code>unique_subquery</code></h5><p>这个连接类型在部分 IN 子查询语句中用于替换 <code>eq_ref</code> 连接类型</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">value IN (<span class="keyword">SELECT</span> key_column <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span> some_expr)</span><br></pre></td></tr></table></figure>

<p><code>unique_subquery</code> 连接类型是完全可以用来提高子查询效率的索引查询方法</p>
<h5 id="index-subquery"><a href="#index-subquery" class="headerlink" title="index_subquery"></a><code>index_subquery</code></h5><p>这个连接类型类似于 <code>unique_subquery</code>，只是子查询只作用于非唯一索引</p>
<h5 id="range-范围查询"><a href="#range-范围查询" class="headerlink" title="range: 范围查询"></a><code>range</code>: 范围查询</h5><p>通过索引查询给定范围的数据行，这个连接类型中的 <code>ref</code> 列是 <code>NULL</code>，<code>range</code> 范围查询类的连接类型用于索引通过如下比较符(=, &lt;, &gt;, &lt;=, &gt;=, BETWEEN, LIKE, IN()) 和常量比较的时候</p>
<h4 id="possible-keys：-可能命中的索引，可能为空"><a href="#possible-keys：-可能命中的索引，可能为空" class="headerlink" title="possible_keys： 可能命中的索引，可能为空"></a><code>possible_keys</code>： 可能命中的索引，可能为空</h4><h4 id="key-查询命中的索引，可能为空"><a href="#key-查询命中的索引，可能为空" class="headerlink" title="key: 查询命中的索引，可能为空"></a><code>key</code>: 查询命中的索引，可能为空</h4><p><code>key</code> 的取值可能不是 <code>possible_keys</code> 的取值</p>
<h4 id="key-len-使用的索引的长度"><a href="#key-len-使用的索引的长度" class="headerlink" title="key_len: 使用的索引的长度"></a><code>key_len</code>: 使用的索引的长度</h4><p>使用的索引的长度决定能用的组合索引的长度，如果 <code>key</code> 为空， <code>key_len</code> 也为空</p>
<p><strong><em>索引存储方式决定了允许为空的列的索引长度可能会大于不能为空的列组成的索引</em></strong></p>
<h4 id="rows-查询语句为了查询出结果要读取的行数"><a href="#rows-查询语句为了查询出结果要读取的行数" class="headerlink" title="rows: 查询语句为了查询出结果要读取的行数"></a><code>rows</code>: 查询语句为了查询出结果要读取的行数</h4><p>对于 <code>InnoDB</code>, 这个行数是个估计值，可能不是实际值</p>
<h4 id="filtered-被条件过滤的行数的百分比"><a href="#filtered-被条件过滤的行数的百分比" class="headerlink" title="filtered: 被条件过滤的行数的百分比"></a><code>filtered</code>: 被条件过滤的行数的百分比</h4><p><code>filtered</code> 列预估了被表查询条件过滤的行的百分比，最大值是 100，意味着没有对表数据进行过滤;<br><code>rows</code> 行预估了被读取的行数， <code>rows x filtered</code> 计算的结果是与后续表进行连接的行数，例如 <code>rows</code> 为 1000，<code>filtered</code> 是 50（代表着 50%）的时候，与后续表进行连接的行数就是 1000 x 50% = 500。</p>
<h4 id="Extra-sql-被解析执行的附加信息"><a href="#Extra-sql-被解析执行的附加信息" class="headerlink" title="Extra: sql 被解析执行的附加信息"></a><code>Extra</code>: sql 被解析执行的附加信息</h4><p>附加信息的可能取值有很多，具体有</p>
<h5 id="Using-index"><a href="#Using-index" class="headerlink" title="Using index"></a>Using index</h5><p>仅仅使用索引树中的信息检索表中的列信息，而不用进行其他搜索去读取实际数据行；这个策略在查询的列是单个索引的部分列的时候会被使用</p>
<h5 id="Using-filesort"><a href="#Using-filesort" class="headerlink" title="Using filesort"></a>Using filesort</h5><p>不是字面意义上的通过文件进行排序，而是表示无法使用索引进行排序，实际上是使用 <code>快排</code>；这里不一定会产生临时文件存放在磁盘中，这取决于临时文件的大小以及数据库的参数，例如 <code>sort_buffer_size</code> 等</p>
<h5 id="Using-where"><a href="#Using-where" class="headerlink" title="Using where"></a>Using where</h5><p>使用 where 从句来限制哪些行会和下一张表进行匹配查询或者直接返回给客户端。</p>
<p>A WHERE clause is used to restrict which rows to match against the next table or send to the client. Unless you specifically intend to fetch or examine all rows from the table, you may have something wrong in your query if the Extra value is not Using where and the table join type is ALL or index.</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC Http 请求处理流程</title>
    <url>/2020/06/01/%E6%8A%80%E6%9C%AF/spring/Spring%20Mvc%20HTTP%20%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Spring-MVC-Http-请求处理流程"><a href="#Spring-MVC-Http-请求处理流程" class="headerlink" title="Spring MVC Http 请求处理流程"></a>Spring MVC Http 请求处理流程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Spring MVC 还是目前业界主流的 MVC 框架，通过 Spring MVC 可以轻松的构建一个完整的 Web 应用程序。这里我们将从代码触发，简单分析一下 HTTP 请求的处理流程。</p>
<h2 id="Spring-MVC-重要组件"><a href="#Spring-MVC-重要组件" class="headerlink" title="Spring MVC 重要组件"></a>Spring MVC 重要组件</h2><p>首先介绍一下 Spring MVC 框架中主要组件</p>
<ul>
<li><code>DispatcherServlet</code>: Spring MVC 实现 Servlet API 的关键耦合点，管理Spring MVC 的其他组件，是 HTTP 请求处理的控制中心</li>
<li><code>HandlerMapping</code>: 请求映射器，映射请求和处理器(Handler)，根据请求获取请求处理调用链(HttpExecutionChain)</li>
<li><code>HandlerExecutionChain</code>: 请求处理调用链，包含一个处理器(Handler)和链状的拦截器(HandlerInterceptor)</li>
<li><code>HandlerAdapter</code>: 请求适配器，为请求匹配参数解析工具及返回值处理工具，调用处理器 Handler</li>
<li><code>HandlerInterceptor</code>: Spring MVC 拦截器，提供处理器被调用前后的插入操作，以及请求处理完成后插入操作</li>
<li><code>ViewResolver</code>: 视图渲染器</li>
<li><code>LocalResolver</code>: 本地化解析器，可以用于国际化处理</li>
<li><code>View</code>: 视图，Spring MVC 支持多种视图，jsp, json, xml 等</li>
<li><code>HandlerExceptionResolver</code>: Http 请求全局异常处理，支持将异常信息转化为视图</li>
<li><code>MultipartResolver</code>: 判断请求是否是 multipart 请求，将 multipart 请求转化为 Spring MVC multipart 请求，结束请求时清除文件资源缓存</li>
</ul>
<h2 id="Spring-MVC-Http-请求处理流程概览"><a href="#Spring-MVC-Http-请求处理流程概览" class="headerlink" title="Spring MVC Http 请求处理流程概览"></a>Spring MVC Http 请求处理流程概览</h2><p><img src="/assets/picture/spring.mvc.flow.png" alt="Spring MVC Http 请求处理流程" title="Spring MVC http 请求处理流程图"></p>
<ul>
<li>DispatcherServlet.doDispatch 接收到 http 请求</li>
<li>MultipartResolver 判断标记是否是 multipart 请求</li>
<li>HandlerMapping 根据请求获取包含处理器(Handler) 中的 HandlerExecutionChain </li>
<li>通过处理器(Handler) 获取处理适配器HandlerAdapter</li>
<li>链式调用拦截器 HandlerInterceptor 中的 preHandle</li>
<li>通过处理适配器调用处理器获取 ModelAndView；分别进行参数注入、处理方法调用、返回结果处理</li>
<li>链式调用拦截器中的 postHandle</li>
<li>调用 LocalResolver 处理 i18n 信息</li>
<li>调用 ViewResolver 解析视图</li>
<li>视图渲染</li>
<li>链式调用拦截器 afterCompletion</li>
<li>MultipartResolver 清理文件上传请求处理中的资源占用</li>
</ul>
<p><strong><em>注意：上述流程中请求 ExceptionHandlerInterceptor 会处理请求处理流程中的异常</em></strong></p>
<h2 id="DispatcherServlet-初始化"><a href="#DispatcherServlet-初始化" class="headerlink" title="DispatcherServlet 初始化"></a>DispatcherServlet 初始化</h2><p><img src="/assets/picture/dispatcher_servlet_class_diagram.png" alt="DispatcherServlet 类图" title="DispatcherServlet 类图"></p>
<p><code>DispatcherServlet</code> 是 Servlet API 中 Servlet 的具体实现，是 Http 请求处理的控制入口，也是 Spring MVC 其他组件的管理中心</p>
<p>在 <code>DispatcherServlet</code> 初始化的时候，会去初始化其他的 MVC 重要组件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This implementation calls &#123;<span class="doctag">@link</span> #initStrategies&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the strategy objects that this servlet uses.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    initMultipartResolver(context);</span><br><span class="line">    initLocaleResolver(context);</span><br><span class="line">    initThemeResolver(context);</span><br><span class="line">    initHandlerMappings(context);</span><br><span class="line">    initHandlerAdapters(context);</span><br><span class="line">    initHandlerExceptionResolvers(context);</span><br><span class="line">    initRequestToViewNameTranslator(context);</span><br><span class="line">    initViewResolvers(context);</span><br><span class="line">    initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上述代码所述，DispatcherServlet 在初始化的时候会初始化 MultipartResolver、HandlerMapping、HandlerAdapter、HandlerExceptionResolver、ViewResolver 等组件</p>
<p><strong><em>注意：<code>DispatcherServlet</code> 在 Spring 容器中没有找到部分组件的 Bean 实例的时候，会从 <code>DispatcherServlet.properties</code> 文件中加载默认配置，使用默认配置的组件信息</em></strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Default implementation classes for DispatcherServlet&#x27;s strategy interfaces.</span></span><br><span class="line"><span class="comment"># Used as fallback when no matching beans are found in the DispatcherServlet context.</span></span><br><span class="line"><span class="comment"># Not meant to be customized by application developers.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">org.springframework.web.servlet.LocaleResolver</span>=<span class="string">org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</span></span><br><span class="line"></span><br><span class="line"><span class="meta">org.springframework.web.servlet.ThemeResolver</span>=<span class="string">org.springframework.web.servlet.theme.FixedThemeResolver</span></span><br><span class="line"></span><br><span class="line"><span class="meta">org.springframework.web.servlet.HandlerMapping</span>=<span class="string">org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</span></span><br><span class="line">    org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping,\</span><br><span class="line">    <span class="attr">org.springframework.web.servlet.function.support.RouterFunctionMapping</span></span><br><span class="line"></span><br><span class="line"><span class="meta">org.springframework.web.servlet.HandlerAdapter</span>=<span class="string">org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</span></span><br><span class="line">    org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</span><br><span class="line">    org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter,\</span><br><span class="line">    <span class="attr">org.springframework.web.servlet.function.support.HandlerFunctionAdapter</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">org.springframework.web.servlet.HandlerExceptionResolver</span>=<span class="string">org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver,\</span></span><br><span class="line">    org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\</span><br><span class="line">    <span class="attr">org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</span></span><br><span class="line"></span><br><span class="line"><span class="meta">org.springframework.web.servlet.RequestToViewNameTranslator</span>=<span class="string">org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</span></span><br><span class="line"></span><br><span class="line"><span class="meta">org.springframework.web.servlet.ViewResolver</span>=<span class="string">org.springframework.web.servlet.view.InternalResourceViewResolver</span></span><br><span class="line"></span><br><span class="line"><span class="meta">org.springframework.web.servlet.FlashMapManager</span>=<span class="string">org.springframework.web.servlet.support.SessionFlashMapManager</span></span><br></pre></td></tr></table></figure>

<h2 id="Spring-MVC-Http-请求处理代码简析"><a href="#Spring-MVC-Http-请求处理代码简析" class="headerlink" title="Spring MVC Http 请求处理代码简析"></a>Spring MVC Http 请求处理代码简析</h2><h3 id="Servlet-API-请求入口"><a href="#Servlet-API-请求入口" class="headerlink" title="Servlet API 请求入口"></a>Servlet API 请求入口</h3><p><code>DispatcherServlet</code> 继承自 <code>FrameworkServlet</code>，<code>FrameworkServlet</code> 是 <code>Servlet</code> 的子类，针对每种 Http 请求有 <code>doXxx</code> 方法处理</p>
<p><img src="/assets/picture/frame_servlet_process_request.png" alt="FrameworkServlet#processRequest" title="FrameworkServlet#processRequest"></p>
<p>org.springframework.web.servlet.FrameworkServlet#processRequest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doService(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ServletException | IOException ex) &#123;</span><br><span class="line">        failureCause = ex;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        failureCause = ex;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Request processing failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    logRequest(request);</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doDispatch(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line">            <span class="keyword">if</span> (attributesSnapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line">                restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Http-请求处理核心流程"><a href="#Http-请求处理核心流程" class="headerlink" title="Http 请求处理核心流程"></a>Http 请求处理核心流程</h3><ul>
<li><code>MultipartResolver</code> 判断是否是 multipart 请求，对 multipart 请求进行标记</li>
<li><code>HandlerMapping</code> 根据请求获取处理执行链 <code>HandlerExecutionChain</code></li>
<li>根据处理器 <code>Handler</code> 获取 <code>HandlerAdapter</code></li>
<li>链式调用拦截器 <code>HandlerInterceptor</code> 中的 <code>preHandle</code> 方法</li>
<li>调用处理器 <code>Handler</code></li>
<li>链式调用拦截器 <code>HandlerInterceptor</code> 中的 <code>postHandle</code> 方法</li>
<li>调用 <code>ViewResolver</code> 将 ModelAndView 渲染成视图，或者通过 <code>HandlerExceptionResolver</code> 对异常进行处理，返回异常信息的视图</li>
<li>链式调用拦截器 <code>HandlerInterceptor</code> 中的 <code>afterCompletion</code></li>
<li>MultipartResolver 清理文件上传请求处理中的资源占用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 判断请求是否是 multipart 请求</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">               <span class="comment">// 通过请求获取请求处理执行链 HandlerExecutionChain</span></span><br><span class="line">               <span class="comment">// 默认的 RequestMappingHandlerMapping 是通过 URL 匹配请求和处理器 Handler</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// 没有匹配的处理器时，直接返回</span></span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">               <span class="comment">// 通过处理器获取处理器适配器</span></span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            <span class="keyword">boolean</span> isGet = <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">               <span class="comment">// 链式调用拦截器的 preHandle 方法</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">               <span class="comment">// 通过处理适配器调用处理器，包含参数解析和返回值处理</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line">               <span class="comment">// 链式调用拦截器的 postHandle 方法</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            <span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line">            <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">            dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">           <span class="comment">// 处理请求返回结果，包含异常处理和正常的视图渲染流程</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">           <span class="comment">// 链式调用拦截器的 afterCompletion 方法</span></span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">           <span class="comment">// 链式调用拦截器的 afterCompletion 方法</span></span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">                <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler processing failed&quot;</span>, err));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">               <span class="comment">// 清理 multipart 请求的处理过程中的资源占用；链式调用拦截器的 afterCompletion 方法</span></span><br><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="HandlerMapping-匹配请求和处理器以及拦截器链"><a href="#HandlerMapping-匹配请求和处理器以及拦截器链" class="headerlink" title="HandlerMapping 匹配请求和处理器以及拦截器链"></a>HandlerMapping 匹配请求和处理器以及拦截器链</h3><p>遍历 <code>DispatcherServlet</code> 中的 HandlerMapping，获取到第一个 <code>HandlerMapping</code> 匹配到的处理执行链 <code>HandlerExecutionChain</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HandlerMapping mapping : <span class="keyword">this</span>.handlerMappings) &#123;</span><br><span class="line">            HandlerExecutionChain handler = mapping.getHandler(request);</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> handler;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="主要的-HandlerMapping"><a href="#主要的-HandlerMapping" class="headerlink" title="主要的 HandlerMapping"></a>主要的 HandlerMapping</h4><p>在 <code>DispatcherServlet.properties</code> 中配置的默认的 HandlerMapping 有</p>
<ul>
<li>BeanNameUrlHandlerMapping<br>  对于name 以 “/“ 开头的 Bean, 注册到映射表中，通过 beanName 进行映射匹配</li>
<li>RequestMappingHandlerMapping<br>  对于 @Controller 修饰的类，将 @RequestMapping 修饰的方法注册到映射表中，通过 requestMapping 和 URL 进行映射匹配</li>
<li>RouterFunctionMapping<br>  自定义 RouteFunction，自定义匹配逻辑，匹配请求和处理器</li>
</ul>
<h3 id="HandlerAdapter-调用处理器的过程"><a href="#HandlerAdapter-调用处理器的过程" class="headerlink" title="HandlerAdapter 调用处理器的过程"></a>HandlerAdapter 调用处理器的过程</h3><p>在现有版本的 Spring Mvc 中 <code>HandlerAdapte</code> 的实现是 <code>RequestMappingHandlerAdapter</code>；<br><code>RequestMappingHandlerAdapter</code> 调用处理器的过程大概如下：</p>
<p>DispatcherServlet#doDispatch ==&gt; AbstractHandlerMethodAdapter#handle ==&gt; RequestMappingHandlerAdapter#handleInternal ==&gt; RequestMappingHandlerAdapter#invokeHandlerMethod</p>
<p>下面是 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#invokeHandlerMethod 的具体逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoke the &#123;<span class="doctag">@link</span> RequestMapping&#125; handler method preparing a &#123;<span class="doctag">@link</span> ModelAndView&#125;</span></span><br><span class="line"><span class="comment"> * if view resolution is required.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #createInvocableHandlerMethod(HandlerMethod)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">  HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"> ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 1. 在处理器类中获取 @InitBinder 注解修饰的方法</span></span><br><span class="line">   <span class="comment">// 2. 在 @ControllerAdvice 修饰的类中，获取 @InitBinder 注解修饰的方法</span></span><br><span class="line">   <span class="comment">// 3. 结合上面两个步骤中的所有 @InitBinder 修饰的方法生成 WebDataBinderFactory</span></span><br><span class="line">   <span class="comment">// DataBinder: 实现参数注入和参数校验，以及绑定结果分析</span></span><br><span class="line">  WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</span><br><span class="line">  <span class="comment">// 1. 在处理器类中获取 @ModelAttribute 注解修饰的方法，注意在方法上 @ModelAttribute 和 @RequestMapping 不能同时使用</span></span><br><span class="line">  <span class="comment">// 2. 在 @ControllerAdvice 修饰的类中，获取 @ModelAttribute 注解修饰的方法</span></span><br><span class="line">  <span class="comment">// 3. 结合上面两个步骤中的所有 @ModelAttribute 修饰的方法生成 ModelFactory</span></span><br><span class="line">  ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装 ServletInvocableHandlerMethod， 设置参数解析器、返回数据处理器、参数名称发现器</span></span><br><span class="line">  ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers != <span class="keyword">null</span>) &#123;</span><br><span class="line">   invocableMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">   invocableMethod.setHandlerMethodReturnValueHandlers(<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line">  &#125;</span><br><span class="line">  invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">  invocableMethod.setParameterNameDiscoverer(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line">  ModelAndViewContainer mavContainer = <span class="keyword">new</span> ModelAndViewContainer();</span><br><span class="line">  mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">  <span class="comment">// 初始化 Model，将 session 中的属性参数提取出来合并放入 Model 中</span></span><br><span class="line">  <span class="comment">// 调用 @ModelAttribute 修饰的方法，提取出这些参数属性，放入 Model 中</span></span><br><span class="line">  modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">  mavContainer.setIgnoreDefaultModelOnRedirect(<span class="keyword">this</span>.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line">  AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">  asyncWebRequest.setTimeout(<span class="keyword">this</span>.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">  WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">  asyncManager.setTaskExecutor(<span class="keyword">this</span>.taskExecutor);</span><br><span class="line">  asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">  asyncManager.registerCallableInterceptors(<span class="keyword">this</span>.callableInterceptors);</span><br><span class="line">  asyncManager.registerDeferredResultInterceptors(<span class="keyword">this</span>.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">   Object result = asyncManager.getConcurrentResult();</span><br><span class="line">   mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">   asyncManager.clearConcurrentResult();</span><br><span class="line">   LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;</span><br><span class="line">    String formatted = LogFormatUtils.formatValue(result, !traceOn);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Resume with async result [&quot;</span> + formatted + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">   &#125;);</span><br><span class="line">   invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">  <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">finally</span> &#123;</span><br><span class="line">  webRequest.requestCompleted();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RequestMappingHandleAdapter-初始化"><a href="#RequestMappingHandleAdapter-初始化" class="headerlink" title="RequestMappingHandleAdapter 初始化"></a><code>RequestMappingHandleAdapter</code> 初始化</h4><p><code>RequestMappingHandleAdapter</code> 中管理了其他的 MVC 组件，包括 <code>HandlerMethodArgumentResolver</code>、<code>HandlerMethodReturnValueHandler</code> 等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestMappingHandlerAdapter</span> <span class="keyword">extends</span> <span class="title">AbstractHandlerMethodAdapter</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// @ControllerAdvice 修饰的类中的 @ModelAttribute 修饰的方法的缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt; modelAttributeAdviceCache = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @ControllerAdvice 修饰的类中的 @InitBinder 修饰的方法的缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt; initBinderAdviceCache = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RequestBodyAdvice 和 ResponseBodyAdvice 的子类实现的缓存列表</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; requestResponseBodyAdvice = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一组 HandlerMethodArgumentResolver 的集合，和 方法参数和 HandlerMethodArgumentResolver 的映射关系缓存</span></span><br><span class="line">    <span class="comment">// 处理请求用的 HandlerMethodArgumentResovler</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> HandlerMethodArgumentResolverComposite argumentResolvers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 专门处理 @InitBinder 修饰的方法的参数的 HandlerMethodArgumentResolverComposite</span></span><br><span class="line">    <span class="comment">// 包含一组 HandlerMethodArgumentResolver 的集合，和 方法参数和 HandlerMethodArgumentResolver 的映射关系缓存</span></span><br><span class="line">    <span class="comment">// 用于处理WebDataBinderFactory</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> HandlerMethodArgumentResolverComposite initBinderArgumentResolvers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果处理器</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> HandlerMethodReturnValueHandlerComposite returnValueHandlers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>RequestMappingHandleAdapter</code> 初始化的时候会去初始化上述代码中的各种组件，具体代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Do this first, it may add ResponseBody advice beans</span></span><br><span class="line">    <span class="comment">// 1. </span></span><br><span class="line">    initControllerAdviceCache();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();</span><br><span class="line">        <span class="keyword">this</span>.argumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.initBinderArgumentResolvers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();</span><br><span class="line">        <span class="keyword">this</span>.initBinderArgumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();</span><br><span class="line">        <span class="keyword">this</span>.returnValueHandlers = <span class="keyword">new</span> HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the list of argument resolvers to use including built-in resolvers</span></span><br><span class="line"><span class="comment"> * and custom resolvers provided via &#123;<span class="doctag">@link</span> #setCustomArgumentResolvers&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; <span class="title">getDefaultArgumentResolvers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;HandlerMethodArgumentResolver&gt; resolvers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Annotation-based argument resolution</span></span><br><span class="line">    <span class="comment">// 新增注解相关的参数解析器，如 @RequestParam，@RequestBody 等</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">false</span>));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> RequestParamMapMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> PathVariableMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> PathVariableMapMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> MatrixVariableMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> MatrixVariableMapMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> ServletModelAttributeMethodProcessor(<span class="keyword">false</span>));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> RequestResponseBodyMethodProcessor(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> RequestPartMethodArgumentResolver(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> RequestHeaderMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> RequestHeaderMapMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> ServletCookieValueMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> ExpressionValueMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> SessionAttributeMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> RequestAttributeMethodArgumentResolver());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Type-based argument resolution</span></span><br><span class="line">    <span class="comment">// 新增参数类型匹配的参数解析器</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> ServletRequestMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> ServletResponseMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> HttpEntityMethodProcessor(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> RedirectAttributesMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> ModelMethodProcessor());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> MapMethodProcessor());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> ErrorsMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> SessionStatusMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> UriComponentsBuilderMethodArgumentResolver());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Custom arguments</span></span><br><span class="line">    <span class="comment">// 新增自定义参数解析器</span></span><br><span class="line">    <span class="keyword">if</span> (getCustomArgumentResolvers() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        resolvers.addAll(getCustomArgumentResolvers());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Catch-all</span></span><br><span class="line">    <span class="comment">// 新增兜底参数解析器</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">true</span>));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> ServletModelAttributeMethodProcessor(<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resolvers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the list of argument resolvers to use for &#123;<span class="doctag">@code</span> <span class="doctag">@InitBinder</span>&#125;</span></span><br><span class="line"><span class="comment"> * methods including built-in and custom resolvers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; <span class="title">getDefaultInitBinderArgumentResolvers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;HandlerMethodArgumentResolver&gt; resolvers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Annotation-based argument resolution</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">false</span>));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> RequestParamMapMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> PathVariableMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> PathVariableMapMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> MatrixVariableMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> MatrixVariableMapMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> ExpressionValueMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> SessionAttributeMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> RequestAttributeMethodArgumentResolver());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Type-based argument resolution</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> ServletRequestMethodArgumentResolver());</span><br><span class="line">    resolvers.add(<span class="keyword">new</span> ServletResponseMethodArgumentResolver());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Custom arguments</span></span><br><span class="line">    <span class="keyword">if</span> (getCustomArgumentResolvers() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        resolvers.addAll(getCustomArgumentResolvers());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Catch-all</span></span><br><span class="line">    resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resolvers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the list of return value handlers to use including built-in and</span></span><br><span class="line"><span class="comment"> * custom handlers provided via &#123;<span class="doctag">@link</span> #setReturnValueHandlers&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;HandlerMethodReturnValueHandler&gt; <span class="title">getDefaultReturnValueHandlers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;HandlerMethodReturnValueHandler&gt; handlers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Single-purpose return value types</span></span><br><span class="line">    handlers.add(<span class="keyword">new</span> ModelAndViewMethodReturnValueHandler());</span><br><span class="line">    handlers.add(<span class="keyword">new</span> ModelMethodProcessor());</span><br><span class="line">    handlers.add(<span class="keyword">new</span> ViewMethodReturnValueHandler());</span><br><span class="line">    handlers.add(<span class="keyword">new</span> ResponseBodyEmitterReturnValueHandler(getMessageConverters(),</span><br><span class="line">            <span class="keyword">this</span>.reactiveAdapterRegistry, <span class="keyword">this</span>.taskExecutor, <span class="keyword">this</span>.contentNegotiationManager));</span><br><span class="line">    handlers.add(<span class="keyword">new</span> StreamingResponseBodyReturnValueHandler());</span><br><span class="line">    handlers.add(<span class="keyword">new</span> HttpEntityMethodProcessor(getMessageConverters(),</span><br><span class="line">            <span class="keyword">this</span>.contentNegotiationManager, <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">    handlers.add(<span class="keyword">new</span> HttpHeadersReturnValueHandler());</span><br><span class="line">    handlers.add(<span class="keyword">new</span> CallableMethodReturnValueHandler());</span><br><span class="line">    handlers.add(<span class="keyword">new</span> DeferredResultMethodReturnValueHandler());</span><br><span class="line">    handlers.add(<span class="keyword">new</span> AsyncTaskMethodReturnValueHandler(<span class="keyword">this</span>.beanFactory));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Annotation-based return value types</span></span><br><span class="line">    handlers.add(<span class="keyword">new</span> ModelAttributeMethodProcessor(<span class="keyword">false</span>));</span><br><span class="line">    handlers.add(<span class="keyword">new</span> RequestResponseBodyMethodProcessor(getMessageConverters(),</span><br><span class="line">            <span class="keyword">this</span>.contentNegotiationManager, <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Multi-purpose return value types</span></span><br><span class="line">    handlers.add(<span class="keyword">new</span> ViewNameMethodReturnValueHandler());</span><br><span class="line">    handlers.add(<span class="keyword">new</span> MapMethodProcessor());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Custom return value types</span></span><br><span class="line">    <span class="keyword">if</span> (getCustomReturnValueHandlers() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handlers.addAll(getCustomReturnValueHandlers());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Catch-all</span></span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(getModelAndViewResolvers())) &#123;</span><br><span class="line">        handlers.add(<span class="keyword">new</span> ModelAndViewResolverMethodReturnValueHandler(getModelAndViewResolvers()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        handlers.add(<span class="keyword">new</span> ModelAttributeMethodProcessor(<span class="keyword">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handlers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>查找到所有 @ControllerAdvice 修饰的类</li>
<li>在 @ControllerAdvice 修饰的类中找到 @ModelAttribute 修饰的方法，放入 modelAttributeAdviceCache 缓存中</li>
<li>在 @ControllerAdvice 修饰的类中找到 @InitBinder 修饰的方法，放入 initBinderAdviceCache 缓存中</li>
<li>将 RequestBodyAdvice 和 ResponseBodyAdvice 的子类实现放入 requestResponseBodyAdvice 缓存中</li>
<li>将默认的参数解析器放入 argumentResolvers 缓存中<ul>
<li>将解析注解修饰的参数的解析器放入 argumentResolvers 缓存中，如 @RequestParam，@RequestBody 等</li>
<li>将解析类型匹配的参数解析器放入 argumentResolvers 缓存中，处理指定类型的参数</li>
<li>将自定义参数解析器放入 argumentResolvers 缓存中</li>
<li>将兜底处理的参数解析器放入 argumentResolvers 缓存中</li>
</ul>
</li>
<li>将默认的用于解析 @InitBinder 修饰的方法的参数的参数解析器放入 initBinderArgumentResolvers 缓存中<ul>
<li>将解析注解修饰的参数的解析器放入 argumentResolvers 缓存中，如 @RequestParam，@RequestBody 等</li>
<li>将解析类型匹配的参数解析器放入 argumentResolvers 缓存中，处理指定类型的参数</li>
<li>将自定义参数解析器放入 argumentResolvers 缓存中</li>
<li>将兜底处理的参数解析器放入 argumentResolvers 缓存中</li>
</ul>
</li>
<li>将默认的用于处理返回结果的 HandlerMethodReturnValueHandler 缓存 returnValueHandlers 中<ul>
<li>将处理指定类型的返回结果的处理器加入 returnValueHandlers 缓存中</li>
<li>将处理注解修饰的返回结果的处理器加入 returnValueHandlers 缓存中，例如 @ModelAttribute、@ResponseBody</li>
<li>将处理 void 或者字符串或者 Map 类型的返回结果的处理器加入 returnValueHandlers 缓存中</li>
<li>将自定义的返回结果处理器放入 returnValueHandlers 缓存中</li>
<li>将兜底处理的返回结果处理器放入 returnValueHandlers 缓存中</li>
</ul>
</li>
</ul>
<h4 id="调用处理器之前的前置操作"><a href="#调用处理器之前的前置操作" class="headerlink" title="调用处理器之前的前置操作"></a>调用处理器之前的前置操作</h4><p>在调用处理器方法之前需要进行一些准备工作，具体如下：</p>
<ul>
<li><p>获取操作 <code>WebDataBinder</code> 的方法</p>
<ul>
<li>获取当前处理器中 @InitBinder 修饰的方法</li>
<li>从 initBinderAdviceCache 缓存中获取 @ControllerAdvice 修饰的类中的 @InitBinder 修饰的方法</li>
</ul>
</li>
<li><p>集合上述操作 <code>WebDataBinder</code> 的方法生成 <code>WebDataBinderFactory</code></p>
</li>
<li><p>获取操作 <code>Model</code> 的方法</p>
<ul>
<li>获取当前处理器方法参数中 @SessionAttribute 修复的方法</li>
<li>获取当前处理器中 @ModelAttribute 修饰的方法</li>
<li>获取 @ControllerAdvice 修饰的类中的 @ModelAttribute 修饰的方法</li>
</ul>
</li>
<li><p>集合上述操作 Model 的方法生成 <code>ModelFactory</code></p>
</li>
<li><p>封装 ServletInvocableHandlerMethod， 设置参数解析器、返回数据处理器、参数名称发现器</p>
</li>
<li><p>初始化 Model，在 session 中找到 @SessionAtrribute 修饰的方法参数提取出来合并放入 Model 中</p>
</li>
<li><p>调用 ModelFactory 中 @ModelAttribute 修饰的方法，提取出这些参数属性，放入 Model 中</p>
</li>
<li><p>最终调用处理器 ServletInvocableHandlerMethod#invokeAndHandle</p>
<pre><code>          在这些前置操作中，出现了 MVC 组件 WebDataBinder
          WebDataBinder 支持如下功能
          - 参数字段黑白名单控制
          - 必填参数字段校验
          - 字段加上特定前缀之后，请求中没有该字段时，实现设置字段默认值
              - 默认 ! 开头的字段为默认值取值字段，可以自定义；
              - 例如请求中没有 name 参数但是有 !name 字段时，用 !name 字段取值作为 name 属性的默认值
          - 字段加上特定前缀之后，请求中没有该字段时，实现设置字段值清空
              - 默认 _ 开头的字段为默认值取值字段，可以自定义
              - 例如请求中没有 name 参数但是有 _name 字段时，取 name 字段数据类型的默认值，如String 为null 赋值给 name</code></pre>
</li>
</ul>
<h4 id="处理器调用过程"><a href="#处理器调用过程" class="headerlink" title="处理器调用过程"></a>处理器调用过程</h4><p><code>RequestMappingHandlerAdapter</code> 的实际处理过程就是</p>
<ul>
<li>调用 <code>HandlerMethodArgumentResolver</code> 解析参数</li>
<li>反射调用处理器方法</li>
<li>调用 <code>HandlerMethodReturnValueHandler</code> 处理返回结果</li>
</ul>
<h5 id="处理器参数解析处理"><a href="#处理器参数解析处理" class="headerlink" title="处理器参数解析处理"></a>处理器参数解析处理</h5><p><img src="/assets/picture/servlet_invocable_handler_method_argument_resolver.png" alt="HandlerMethodArgumentResolver#resolveArgument" title="HandlerMethodArgumentResolver#resolveArgument"></p>
<p><code>RequestMappingHandlerAdapter</code> 会调用包含一组 <code>HandlerMethodArgumentResolver</code> 的 <code>HandlerMethodArgumentResolverComposite</code> 进行参数解析，下面下介绍一些常用的 <code>HandlerMethodArgumentResolver</code></p>
<h6 id="常用的-HandlerMethodArgumentResolver"><a href="#常用的-HandlerMethodArgumentResolver" class="headerlink" title="常用的 HandlerMethodArgumentResolver"></a>常用的 <code>HandlerMethodArgumentResolver</code></h6><table>
<thead>
<tr>
<th>HandlerMethodArgumentResolver 名称</th>
<th>如何判断是否支持参数解析</th>
<th>如何解析参数</th>
<th>对应的注解或者参数类型</th>
</tr>
</thead>
<tbody><tr>
<td>RequestParam<br/>MethodArgumentResolver</td>
<td>1. 解析 @RequestParam 修饰的参数<br/> 2.解析没有注解修饰的，包括基础数据类型、String、<br/>CharSequence、Number、Date、Enum、Date、URL、<br/>URI、Locale、Class 类型及上述类型的数组</td>
<td>1. 调用 javax.servlet.ServletRequest<br/>#getParameterValues 获取参数<br/> 2. 调用 DataBinder 进行参数类型转化</td>
<td>@RequestParam</td>
</tr>
<tr>
<td>RequestParamMap<br/>MethodArgumentResolver</td>
<td>1. 解析 @RequestParam 注解修饰的参数 2. 参数类型是 Map，但是 @RequestParam 没有指定 name属性</td>
<td>1. 针对 multipart 请求，提取 multipart 请求中的文件 Map <br/> 2. 针对其他请求，通过 javax.servlet.ServletRequest<br/>#getParameterMap 获取参数 Map</td>
<td>@RequestParam</td>
</tr>
<tr>
<td>RequestPart<br/>MethodArgumentResolver</td>
<td>1. @RequestPart 修饰的参数<br/> 2. 没有被 @RequestParam 修饰的 Spring multipart 请求</td>
<td>1. 通过 MessageConvert 进行参数转换<br/> 2. 调用 RequestResponseBodyAdvice 对参数进行切入处理<br/> 3. 创建 WebDataBinder，进行参数校验并处理校验结果<br/> 4. 为声明为 Optional 类型的可选参数用 Optional 进行封装</td>
<td>@RequestPart</td>
</tr>
<tr>
<td>PathVariable<br/>MethodArgumentResolver</td>
<td>1. @PathVaribale 注解修饰的非 Map 参数 <br/> 2. @PathVariable 注解修饰的, Optional 包装的 Map 参数，且 @PathVariable 没有 value 属性</td>
<td>HandlerMapping 将 Url 中的参数提取出来，存放到 Http Request 中去，在这里提取出参数Map， 从Map 中提取具体参数</td>
<td>@PathVariable</td>
</tr>
<tr>
<td>PathVariableMap<br/>MethodArgumentResolver</td>
<td>@PathVariable 注解修饰的Map 参数，且 @PathVariable 没有 value 属性</td>
<td>HandlerMapping 将 Url 中的参数提取出来，存放到 Http Request 中去，在这里提取出参数Map</td>
<td>@PathVariable</td>
</tr>
<tr>
<td>RequestHeader<br/>MethodArgumentResolver</td>
<td>@RequestHeader 修饰的，类型不是Map 的参数</td>
<td>从 Http 请求头中提取参数</td>
<td>@RequestHeader</td>
</tr>
<tr>
<td>RequestHeaderMap<br/>MethodArgumentResolver</td>
<td>@RequestHeader 修饰的，类型是Map 的参数</td>
<td>从 Http 请求头中提取参数，将返回的数组改装成 Map</td>
<td>@RequestHeader</td>
</tr>
<tr>
<td>SessionAttribute<br/>MethodArgumentResolver</td>
<td>@SessionAttribute 修饰的参数</td>
<td>从 HttpSession 中根据名称提取单个参数</td>
<td>@SessionAttribute</td>
</tr>
<tr>
<td>RequestAttribute<br/>MethodArgumentResolver</td>
<td>@RequestAttribute 修饰的参数</td>
<td>调用 ServletRequest#getAttribute 方法提取单个属性<br/> 服务端 filter 或者 HandlerInterceptor 设置的属性</td>
<td>@RequestAttribute</td>
</tr>
<tr>
<td>ServletCookieValue<br/>MethodArgumentResolver</td>
<td>@CookieValue 修饰的参数</td>
<td>从 Cookie 中按照名称获取参数</td>
<td>@CookieValue</td>
</tr>
<tr>
<td>RequestResponseBody<br/>MethodProcessor</td>
<td>@RequestBody 修饰的参数</td>
<td>1. 调用 MessageConverter 提取参数<br/> 2.创建 WebDataBinder 进行参数校验，对校验结果进行处理 <br/> 为声明为 Optional 类型的可选参数用 Optional 进行封装</td>
<td>@RequestBody</td>
</tr>
</tbody></table>
<h5 id="反射调用处理器方法"><a href="#反射调用处理器方法" class="headerlink" title="反射调用处理器方法"></a>反射调用处理器方法</h5><p><img src="/assets/picture/servlet_invocable_handler_method_reflect_invoke.png" alt="InvocableHandlerMethod#doInvoke" title="InvocableHandlerMethod#doInvoke"></p>
<h5 id="处理器返回结果处理"><a href="#处理器返回结果处理" class="headerlink" title="处理器返回结果处理"></a>处理器返回结果处理</h5><p><img src="/assets/picture/servlet_invocable_handler_method_invoke.png" alt="HandlerMethodReturnValueHandler#handleReturnValue" title="HandlerMethodReturnValueHandler#handleReturnValue"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Iterate over registered &#123;<span class="doctag">@link</span> HandlerMethodReturnValueHandler&#125;s and invoke the one that supports it.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if no suitable &#123;<span class="doctag">@link</span> HandlerMethodReturnValueHandler&#125; is found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">        ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unknown return value type: &quot;</span> + returnType.getParameterType().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> HandlerMethodReturnValueHandler <span class="title">selectHandler</span><span class="params">(<span class="meta">@Nullable</span> Object value, MethodParameter returnType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isAsyncValue = isAsyncReturnValue(value, returnType);</span><br><span class="line">    <span class="keyword">for</span> (HandlerMethodReturnValueHandler handler : <span class="keyword">this</span>.returnValueHandlers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isAsyncValue &amp;&amp; !(handler <span class="keyword">instanceof</span> AsyncHandlerMethodReturnValueHandler)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler.supportsReturnType(returnType)) &#123;</span><br><span class="line">            <span class="keyword">return</span> handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="常用的-HandlerMethodArgumentResolver-————-RequestResponseBodyMethodProcessor"><a href="#常用的-HandlerMethodArgumentResolver-————-RequestResponseBodyMethodProcessor" class="headerlink" title="常用的 HandlerMethodArgumentResolver ———— RequestResponseBodyMethodProcessor"></a>常用的 <code>HandlerMethodArgumentResolver</code> ———— <code>RequestResponseBodyMethodProcessor</code></h6><ul>
<li>如果判定是否支持 <code>RequestResponseBodyMethodProcessor</code> 处理<br>判断处理器或者处理器的方法是否被 <code>@ResponseBody</code> 修饰</li>
</ul>
<ul>
<li><p>具体返回值处理过程</p>
<pre><code>              1. 调用 ResponseBodyAdvice#beforeBodyWrite 进行插入处理
              2. 调用 HttpMessageConverter 处理返回结果</code></pre>
</li>
</ul>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>Http 请求处理流程的中的 <code>请求映射处理器</code>、<code>选取处理适配器</code>、<code>链式调用拦截器 HandlerInterceptor 中的 preHandle</code>、<code>调用处理器</code>、<code>链式调用拦截器中的postHandle</code> 过程被 <code>try-catch</code> 包括在内，处理过程中的异常被 <code>processDispatchResult</code> 方法处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 省略 ......</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 省略 ......</span></span><br><span class="line">            <span class="comment">// 通过请求映射处理执行链</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 省略 ......</span></span><br><span class="line">            <span class="comment">// 链式调用拦截器 HandlerInterceptor 中的 preHandle</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">            <span class="comment">// 省略 ......</span></span><br><span class="line">            <span class="comment">// 调用处理器</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">            <span class="comment">// 省略 ......</span></span><br><span class="line">            <span class="comment">// 链式调用拦截器中的 postHandle</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">                <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler processing failed&quot;</span>, err));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Nullable</span> HandlerExecutionChain mappedHandler, <span class="meta">@Nullable</span> ModelAndView mv,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Nullable</span> Exception exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> errorView = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;ModelAndViewDefiningException encountered&quot;</span>, exception);</span><br><span class="line">            mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object handler = (mappedHandler != <span class="keyword">null</span> ? mappedHandler.getHandler() : <span class="keyword">null</span>);</span><br><span class="line">            mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">            errorView = (mv != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略 ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">processHandlerException</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Nullable</span> Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    request.removeAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);</span><br><span class="line">    ModelAndView exMv = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlerExceptionResolvers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HandlerExceptionResolver resolver : <span class="keyword">this</span>.handlerExceptionResolvers) &#123;</span><br><span class="line">            <span class="comment">// 调用 HandlerExceptionResolver 将异常解析成 ModelAndView</span></span><br><span class="line">            exMv = resolver.resolveException(request, response, handler, ex);</span><br><span class="line">            <span class="keyword">if</span> (exMv != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exMv != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exMv.isEmpty()) &#123;</span><br><span class="line">            request.setAttribute(EXCEPTION_ATTRIBUTE, ex);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!exMv.hasView()) &#123;</span><br><span class="line">            String defaultViewName = getDefaultViewName(request);</span><br><span class="line">            <span class="keyword">if</span> (defaultViewName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                exMv.setViewName(defaultViewName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Using resolved error view: &quot;</span> + exMv, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Using resolved error view: &quot;</span> + exMv);</span><br><span class="line">        &#125;</span><br><span class="line">        WebUtils.exposeErrorRequestAttributes(request, ex, getServletName());</span><br><span class="line">        <span class="keyword">return</span> exMv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HandlerExceptionResolver"><a href="#HandlerExceptionResolver" class="headerlink" title="HandlerExceptionResolver"></a><code>HandlerExceptionResolver</code></h4><p><code>DispatcherServlet#processHandlerException</code> 的具体逻辑就是调用 <code>HandlerExceptionResolver</code> 进行异常处理</p>
<p><code>DispatcherSevlet.properties</code> 中配置的默认的 <code>HandlerExceptionResolver</code> 是</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">org.springframework.web.servlet.HandlerExceptionResolver</span>=<span class="string">org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver,\</span></span><br><span class="line">    org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\</span><br><span class="line">    <span class="attr">org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</span></span><br></pre></td></tr></table></figure>

<h5 id="ExceptionHandlerExceptionResolver-的异常处理流程"><a href="#ExceptionHandlerExceptionResolver-的异常处理流程" class="headerlink" title="ExceptionHandlerExceptionResolver 的异常处理流程"></a><code>ExceptionHandlerExceptionResolver</code> 的异常处理流程</h5><p>第一个被应用的 <code>HandlerExceptionResolver</code> 就是 <code>ExceptionHandlerExceptionResolver</code>, 它的核心逻辑是 <code>ExceptionHandlerExceptionResolver#doResolveHandlerMethodException</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">doResolveHandlerMethodException</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletResponse response, <span class="meta">@Nullable</span> HandlerMethod handlerMethod, Exception exception)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到处理器(Controller) 中，或者 @ControllerAdvice 修饰的类中， @ExceptionHandler 修饰的异常处理方法，封装成可触发调用的异常处理方法 </span></span><br><span class="line">    ServletInvocableHandlerMethod exceptionHandlerMethod = getExceptionHandlerMethod(handlerMethod, exception);</span><br><span class="line">    <span class="keyword">if</span> (exceptionHandlerMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为异常处理方法设置参数解析器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        exceptionHandlerMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为异常处理方法设置返回结果处理器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        exceptionHandlerMethod.setHandlerMethodReturnValueHandlers(<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line">    &#125;</span><br><span class="line">    ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line">    ModelAndViewContainer mavContainer = <span class="keyword">new</span> ModelAndViewContainer();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Using @ExceptionHandler &quot;</span> + exceptionHandlerMethod);</span><br><span class="line">        &#125;</span><br><span class="line">        Throwable cause = exception.getCause();</span><br><span class="line">        <span class="comment">// 调用异常方法处理器，处理过程和调用处理器中的处理方法的流程是一致的</span></span><br><span class="line">        <span class="comment">// 1. 调用参数解析器解析参数</span></span><br><span class="line">        <span class="comment">// 2. 反射调用异常处理方法</span></span><br><span class="line">        <span class="comment">// 3. 调用返回结果处理器，处理返回结果</span></span><br><span class="line">        <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Expose cause as provided argument as well</span></span><br><span class="line">            exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, exception, cause, handlerMethod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Otherwise, just the given exception as-is</span></span><br><span class="line">            exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, exception, handlerMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable invocationEx) &#123;</span><br><span class="line">        <span class="comment">// Any other than the original exception (or its cause) is unintended here,</span></span><br><span class="line">        <span class="comment">// probably an accident (e.g. failed assertion or the like).</span></span><br><span class="line">        <span class="keyword">if</span> (invocationEx != exception &amp;&amp; invocationEx != exception.getCause() &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Failure in @ExceptionHandler &quot;</span> + exceptionHandlerMethod, invocationEx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Continue with default processing of the original exception...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mavContainer.isRequestHandled()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ModelMap model = mavContainer.getModel();</span><br><span class="line">        HttpStatus status = mavContainer.getStatus();</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView(mavContainer.getViewName(), model, status);</span><br><span class="line">        mav.setViewName(mavContainer.getViewName());</span><br><span class="line">        <span class="keyword">if</span> (!mavContainer.isViewReference()) &#123;</span><br><span class="line">            mav.setView((View) mavContainer.getView());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (model <span class="keyword">instanceof</span> RedirectAttributes) &#123;</span><br><span class="line">            Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();</span><br><span class="line">            RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ServletInvocableHandlerMethod <span class="title">getExceptionHandlerMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Nullable</span> HandlerMethod handlerMethod, Exception exception)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; handlerType = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handlerMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handlerType = handlerMethod.getBeanType();</span><br><span class="line">        ExceptionHandlerMethodResolver resolver = <span class="keyword">this</span>.exceptionHandlerCache.get(handlerType);</span><br><span class="line">        <span class="keyword">if</span> (resolver == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// ExceptionHandlerMethodResolver 是查找 @ExceptionHandler 修饰的方法的一个解析器</span></span><br><span class="line">            <span class="comment">// 从处理器方法所在的类中，查找 @ExceptionHandler 修饰的方法，放入 ExceptionHandlerMethodResolver 的缓存中</span></span><br><span class="line">            resolver = <span class="keyword">new</span> ExceptionHandlerMethodResolver(handlerType);</span><br><span class="line">            <span class="comment">// 将异常处理方法解析器 ExceptionHandlerMethodResolver 放入缓存中</span></span><br><span class="line">            <span class="keyword">this</span>.exceptionHandlerCache.put(handlerType, resolver);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用 ExceptionHandlerMethodResolver 从它的缓存中获取处理器（@Controller）中的方法，直接返回</span></span><br><span class="line">        Method method = resolver.resolveMethod(exception);</span><br><span class="line">        <span class="keyword">if</span> (method != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ServletInvocableHandlerMethod(handlerMethod.getBean(), method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将代理类转化成它的目标类的示例</span></span><br><span class="line">        <span class="keyword">if</span> (Proxy.isProxyClass(handlerType)) &#123;</span><br><span class="line">            handlerType = AopUtils.getTargetClass(handlerMethod.getBean());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓存重获取 @ControllerAdvice 修饰的类中 @ExceptionHanlder 修饰的方法，包装成 ServletInvocableHandlerMethod 返回 </span></span><br><span class="line">    <span class="comment">// 这里引入在一个问题，@ControllerAdvice 对应 ExceptionHandlerMethodResolver 的缓存 Map 是什么时候被创建的</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;ControllerAdviceBean, ExceptionHandlerMethodResolver&gt; entry : <span class="keyword">this</span>.exceptionHandlerAdviceCache.entrySet()) &#123;</span><br><span class="line">        ControllerAdviceBean advice = entry.getKey();</span><br><span class="line">        <span class="keyword">if</span> (advice.isApplicableToBeanType(handlerType)) &#123;</span><br><span class="line">            ExceptionHandlerMethodResolver resolver = entry.getValue();</span><br><span class="line">            Method method = resolver.resolveMethod(exception);</span><br><span class="line">            <span class="keyword">if</span> (method != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ServletInvocableHandlerMethod(advice.resolveBean(), method);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以异常处理核心逻辑的概要流程如下</p>
<p><img src="/assets/picture/exception_handler_exception_resovler_flow.svg" alt="ExceptionHandlerExceptionResolver#doResolveHandlerMethodException" title="ExceptionHandlerExceptionResolver#doResolveHandlerMethodException"></p>
<h5 id="ExceptionHandlerExceptionResolver-的初始化流程"><a href="#ExceptionHandlerExceptionResolver-的初始化流程" class="headerlink" title="ExceptionHandlerExceptionResolver 的初始化流程"></a><code>ExceptionHandlerExceptionResolver</code> 的初始化流程</h5><p>在上面的流程中有几个问题：</p>
<ol>
<li><code>exceptionHandlerAdviceCache</code> 缓存是什么时候加载数据的？</li>
<li>提供给异常处理器的参数解析器 HandlerMethodArgumentResolver 和 HandlerMethodReturnValueHandler 的缓存列表是什么时候初始化的？</li>
</ol>
<p>下面来看看 <code>ExceptionHandlerExceptionResolver</code> 的初始化流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExceptionHandlerExceptionResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messageConverters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> ByteArrayHttpMessageConverter());</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> StringHttpMessageConverter());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> SourceHttpMessageConverter&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">        <span class="comment">// Ignore when no TransformerFactory implementation is available</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> AllEncompassingFormHttpMessageConverter());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExceptionHandlerExceptionResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messageConverters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> ByteArrayHttpMessageConverter());</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> StringHttpMessageConverter());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> SourceHttpMessageConverter&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">        <span class="comment">// Ignore when no TransformerFactory implementation is available</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> AllEncompassingFormHttpMessageConverter());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initExceptionHandlerAdviceCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getApplicationContext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;ControllerAdviceBean&gt; adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext());</span><br><span class="line">    <span class="keyword">for</span> (ControllerAdviceBean adviceBean : adviceBeans) &#123;</span><br><span class="line">        Class&lt;?&gt; beanType = adviceBean.getBeanType();</span><br><span class="line">        <span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unresolvable type for ControllerAdviceBean: &quot;</span> + adviceBean);</span><br><span class="line">        &#125;</span><br><span class="line">        ExceptionHandlerMethodResolver resolver = <span class="keyword">new</span> ExceptionHandlerMethodResolver(beanType);</span><br><span class="line">        <span class="keyword">if</span> (resolver.hasExceptionMappings()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.exceptionHandlerAdviceCache.put(adviceBean, resolver);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ResponseBodyAdvice.class.isAssignableFrom(beanType)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.responseBodyAdvice.add(adviceBean);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="keyword">int</span> handlerSize = <span class="keyword">this</span>.exceptionHandlerAdviceCache.size();</span><br><span class="line">        <span class="keyword">int</span> adviceSize = <span class="keyword">this</span>.responseBodyAdvice.size();</span><br><span class="line">        <span class="keyword">if</span> (handlerSize == <span class="number">0</span> &amp;&amp; adviceSize == <span class="number">0</span>) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;ControllerAdvice beans: none&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;ControllerAdvice beans: &quot;</span> +</span><br><span class="line">                    handlerSize + <span class="string">&quot; @ExceptionHandler, &quot;</span> + adviceSize + <span class="string">&quot; ResponseBodyAdvice&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看到上面问题中提到的缓存数据都是在初始化过程中赋值的，具体流程如下</p>
<ul>
<li>在构造方法初始化提供给 HandlerMethodReturnValueHandler 使用的 HttpMessageConverter<ul>
<li>默认的 HttpMessageConverter 有 ByteArrayHttpMessageConverter、StringHttpMessageConverter、SourceHttpMessageConverter、AllEncompassingFormHttpMessageConverter</li>
<li>ByteArrayHttpMessageConverter: 解析转化 byte[] 类型参数</li>
<li>StringHttpMessageConverter: 解析转化 String 类型参数</li>
<li>SourceHttpMessageConverter: 解析转化 SDOMSource、SAXSource、StAXSource、StreamSource、Source 类型参数</li>
</ul>
</li>
<li>在初始化方法中加载 @ControllerAdvice 中的 @ExceptionHandler 缓存数据<ul>
<li>在容器中查找 @ControllerAdvice </li>
<li>在 @ControllerAdvice 修饰的类中查找 @ExceptionHandler 修饰的方法</li>
<li>在 @ControllerAdvice 修饰的类中查找 ResponseBodyAdvice 的子类，放入缓存中，供 HandlerMethodReturnValueHandler 使用</li>
</ul>
</li>
<li>在初始化方法获取默认的参数解析器和自定义的参数解析器，放入 HandlerMethodArgumentResolverComposite 中<ul>
<li>新增基于注解的参数解析器 SessionAttributeMethodArgumentResolver 和 RequestAttributeMethodArgumentResolver</li>
<li>新增解析特定参数类型的参数解析器，ServletRequestMethodArgumentResolver、ServletResponseMethodArgumentResolver、RedirectAttributesMethodArgumentResolver、ModelMethodProcessor</li>
<li>新增自定义的参数解析器</li>
</ul>
</li>
<li>在初始化方法获取默认的返回值处理器和自定义的返回值处理器，放入 HandlerMethodReturnValueHandlerComposite 中<ul>
<li>新增单一用途的处理指定返回值类型的处理器<ul>
<li>ModelAndViewMethodReturnValueHandler: 处理返回 ModelAndView 的返回值</li>
<li>ModelMethodProcessor: 处理返回 Model 的返回值</li>
<li>ViewMethodReturnValueHandler: 处理返回 View 的返回值</li>
<li>HttpEntityMethodProcessor: 处理返回 ModelAndView 的返回值</li>
<li>ModelAndViewMethodReturnValueHandler: 处理返回 HttpEntity 类型，但是不是 RequestEntity 类型的返回值</li>
</ul>
</li>
<li>新增注解修饰的返回值处理器<ul>
<li>ModelAttributeMethodProcessor: 处理 @ModelAttribute 修饰的方法的返回值</li>
<li>RequestResponseBodyMethodProcessor: 处理 @ResponseBody 修饰的方法的返回值，并且触发 ResponseBodyAdvice 切入处理</li>
</ul>
</li>
<li>新增多用途的返回值处理器<ul>
<li>ViewNameMethodReturnValueHandler: 处理返回值为void 或者 字符串的方法的返回值</li>
<li>MapMethodProcessor: 处理返回 Map 类型方法的返回值</li>
</ul>
</li>
<li>新增自定义的返回值处理器</li>
<li>新增不需要 @ModelAttribute 注解修饰的，但是不是基础类型的返回值的处理器，ModelAttributeMethodProcessor(true)</li>
</ul>
</li>
</ul>
<p>这里我们能看出来，异常处理的过程中，@ExceptionHandler 修饰的方法的参数和返回值类型都有一定的限制，并且会触发 ResponseBodyAdvice 的插入操作</p>
<pre><code>            @ExceptionHandler 修饰的方法的参数限制
            1. 参数类型支持以下情况
                1.1 @SessionAttribute 修饰的参数
                1.2 @ModelAttribute 修饰的参数
                1.3 WebRequest、ServletRequest、MultipartRequest、HttpSession、PushBuilder、Principal、InputStream、Reader、HttpMethod、TimeZone、Locale、ZoneId 类型的参数
                1.4 ServletResponse、OutputStream、Writer 类型的参数
                1.5 RedirectAttributes 类型的参数
                1.6 Model 类型的参数
                1.7 自定义参数解析器可解析的参数
            2. 返回值类型支持以下情况
                2.1 ModelAndView 类型
                2.2 Model 类型
                2.3 View 类型
                2.4 HttpEntity 类型，但是不是它的子类 RequestEntity
                2.5 @ModelAttribute 修饰的方法的返回值
                2.6 @ResponseBody 修饰的方法的返回值
                2.7 void 或者 CharSequence 类型的返回值
                2.8 Map 类型的返回值
                2.9 自定义的返回值处理器支持的类型
                2.10 没有 @ModelAttribute 修饰的，非基础类型的返回值</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述就是 Spring MVC 处理 http 请求的流程概述，从代码简单分析了常用的 MVC 注解的工作原理，也留了一下待完善的部分，以上内容均属个人浅见，如果错漏，欢迎指正</p>
<p>待补充部分： HandlerMapping 如何匹配请求和处理器？</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
</search>
