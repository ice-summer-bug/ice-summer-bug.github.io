<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"summerbuger.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="重读 JDK 源码，回顾线程池">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 线程池">
<meta property="og:url" content="https://summerbuger.github.io/2020/06/26/%E6%8A%80%E6%9C%AF/java/%E9%87%8D%E8%AF%BBJava%20%E6%BA%90%E7%A0%81%20%E2%80%94%E2%80%94%20Java%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/index.html">
<meta property="og:site_name" content="夏虫低语">
<meta property="og:description" content="重读 JDK 源码，回顾线程池">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://summerbuger.github.io/assets/picture/thread.pool.executor.state.flow.png">
<meta property="og:image" content="https://summerbuger.github.io/assets/picture/thread.pool.executor.execute.flow.svg">
<meta property="og:image" content="https://summerbuger.github.io/assets/picture/thread.pool.executor.state.detail.flow.svg">
<meta property="og:image" content="https://summerbuger.github.io/assets/picture/thred.pool.get.task.reuturn.null.after.decrement.jpg">
<meta property="og:image" content="https://summerbuger.github.io/assets/picture/thread.pool.executor.process.worker.exit.jpg">
<meta property="og:image" content="https://summerbuger.github.io/assets/picture/why.not.use.executors.jpg">
<meta property="og:image" content="https://summerbuger.github.io/assets/picture/blocking.queue.method.list.jpg">
<meta property="og:image" content="https://summerbuger.github.io/assets/picture/blocking.queue.implements.class.diagram.png">
<meta property="article:published_time" content="2020-06-26T13:00:00.000Z">
<meta property="article:modified_time" content="2020-08-10T16:38:22.991Z">
<meta property="article:author" content="Liam Chen">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Thread">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://summerbuger.github.io/assets/picture/thread.pool.executor.state.flow.png">

<link rel="canonical" href="https://summerbuger.github.io/2020/06/26/%E6%8A%80%E6%9C%AF/java/%E9%87%8D%E8%AF%BBJava%20%E6%BA%90%E7%A0%81%20%E2%80%94%E2%80%94%20Java%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java 线程池 | 夏虫低语</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">夏虫低语</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://summerbuger.github.io/2020/06/26/%E6%8A%80%E6%9C%AF/java/%E9%87%8D%E8%AF%BBJava%20%E6%BA%90%E7%A0%81%20%E2%80%94%E2%80%94%20Java%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liam Chen">
      <meta itemprop="description" content="关于技术与生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏虫低语">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java 线程池
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-26 21:00:00" itemprop="dateCreated datePublished" datetime="2020-06-26T21:00:00+08:00">2020-06-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-11 00:38:22" itemprop="dateModified" datetime="2020-08-11T00:38:22+08:00">2020-08-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <div class="post-description">重读 JDK 源码，回顾线程池</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Java-线程池"><a href="#Java-线程池" class="headerlink" title="Java 线程池"></a>Java 线程池</h1><h2 id="线程池存在的意义"><a href="#线程池存在的意义" class="headerlink" title="线程池存在的意义"></a>线程池存在的意义</h2><p>在机器的 CPU 核数越来越多的发展趋势下，为了更好的利用机器资源，我们就会想到创建更多的线程，理想状态下对于每个任务都去创建一个线程；但是 CPU 的数量也是有限的，创建了过多的线程会导致多个线程去竞争 CPU 资源，导致线程上下文的频繁切换，浪费系统资源；而且每个线程都有自己的内存空间，系统创建了过多的线程也会浪费系统资源；线程的创建和销毁也会消耗系统资源；</p>
<p>总而言之，线程是很稀有的资源，通过线程池我们可以减少线程的创建和销毁所消耗的时间和系统资源的开销，也避免了为大量线程分配内存，以及线程上下文的 <code>过度切换</code>；<br>将线程这种稀有资源池化使用也是开发人员的惯用方法，同理还有 <code>数据库连接池</code>，可以在接受一个任务之后，直接在资源池中获取一个线程，用完之后再归还。</p>
<p>线程池的好处主要是</p>
<ul>
<li>线程资源的复用，降低资源消耗</li>
<li>提高响应速度，直接使用空闲线程，不用每个请求都要等待创建线程</li>
<li>提高线程的可管理性，对线程实现统一分配和实时监控</li>
</ul>
<h2 id="Executor-的重要实现-————-ThreadPoolExecutor"><a href="#Executor-的重要实现-————-ThreadPoolExecutor" class="headerlink" title="Executor 的重要实现 ———— ThreadPoolExecutor"></a><code>Executor</code> 的重要实现 ———— <code>ThreadPoolExecutor</code></h2><p>在 <code>J.U.C</code> 工具包中，线程池的实现主要是 <code>ThreadPoolExecutor</code>，下面个将对线程池进行更详细的介绍</p>
<h3 id="ThreadPoolExecutor-的参数"><a href="#ThreadPoolExecutor-的参数" class="headerlink" title="ThreadPoolExecutor 的参数"></a><code>ThreadPoolExecutor</code> 的参数</h3><p><code>ThreadPoolExecutor</code> 的构造方法的参数如下</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>corePoolSize</code></td>
<td>int</td>
<td>线程池核心线程数量，如果没有设置 <code>allowCoreThreadTimeOut</code> 参数，即使空间也会保留的线程数量</td>
</tr>
<tr>
<td><code>maximumPoolSize</code></td>
<td>int</td>
<td>线程池允许的最大线程数</td>
</tr>
<tr>
<td><code>keepAliveTime</code></td>
<td>long</td>
<td>空闲线程存活时间，空闲线程在终止之前等待新任务的最长时间；超出核心线程数的非核心线程会阻塞等待一段时间去获取任务等待队列中的任务，也就是说任务等待队列中的任务的等待时长最多为这个时间</td>
</tr>
<tr>
<td><code>unit</code></td>
<td>TimeUnit</td>
<td>空闲线程存活时间的单位</td>
</tr>
<tr>
<td><code>workQueue</code></td>
<td>BlockingQueue</td>
<td>用于缓存任务的阻塞等待队列</td>
</tr>
<tr>
<td><code>threadFactory</code></td>
<td>ThreadFactory</td>
<td>创建线程的工厂类</td>
</tr>
<tr>
<td><code>handler</code></td>
<td>RejectedExecutionHandler</td>
<td>线程池无法接受新任务时，拒绝新任务的策略，简称饱和策略</td>
</tr>
<tr>
<td><code>allowCoreThreadTimeOut</code></td>
<td>boolean</td>
<td>是否允许核心线程超过空闲存活时间后被销毁</td>
</tr>
</tbody></table>
<p><strong><em>注意：<code>allowCoreThreadTimeOut</code> 参数不是 <code>ThreadPoolExecutor</code> 构造方法的参数，默认为 <code>false</code></em></strong></p>
<h4 id="J-U-C-提供的-RejectExecutionHandler-的实现"><a href="#J-U-C-提供的-RejectExecutionHandler-的实现" class="headerlink" title="J.U.C 提供的 RejectExecutionHandler 的实现"></a><code>J.U.C</code> 提供的 <code>RejectExecutionHandler</code> 的实现</h4><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AbortPolicy</td>
<td>抛出一个 RejectedExecutionException 异常，中断任务提交</td>
</tr>
<tr>
<td>DiscardPolicy</td>
<td>忽略这个被拒绝的任务，什么都不做</td>
</tr>
<tr>
<td>DiscardOldestPolicy</td>
<td>将任务等待队列中最老的任务丢弃掉</td>
</tr>
<tr>
<td>CallerRunsPolicy</td>
<td>直接在主线程中调用被拒绝放入线程池的任务</td>
</tr>
</tbody></table>
<h3 id="ThreadPoolExecutor-的状态"><a href="#ThreadPoolExecutor-的状态" class="headerlink" title="ThreadPoolExecutor 的状态"></a><code>ThreadPoolExecutor</code> 的状态</h3><p>线程池的状态信息如下：</p>
<table>
<thead>
<tr>
<th>状态名称</th>
<th>状态特征描述</th>
</tr>
</thead>
<tbody><tr>
<td>RUNNING(运行中)</td>
<td>接受新任务而且处理缓存队列中的任务</td>
</tr>
<tr>
<td>SHUTDOWN(待关闭)</td>
<td>不接受新任务，但是处理缓存队列中的任务，</td>
</tr>
<tr>
<td>STOP(停止)</td>
<td>不接受新任务，现有缓存队列中的任务不会处理，正在运行的任务会被中断</td>
</tr>
<tr>
<td>TIDYING(整理)</td>
<td>所有任务都被终止了，并且准备去调用 terminal() 钩子方法</td>
</tr>
<tr>
<td>TERMINATED(终止)</td>
<td>terminal() 方法执行完毕，进入终态</td>
</tr>
</tbody></table>
<p>状态流转流程如下</p>
<p><img src="/assets/picture/thread.pool.executor.state.flow.png" alt="ThreadPoolExecutor 状态流转图" title="ThreadPoolExecutor 状态流转图"></p>
<h4 id="shutdown-方法"><a href="#shutdown-方法" class="headerlink" title="shutdown() 方法"></a><code>shutdown()</code> 方法</h4><p>在这个方案中，我们会将线程池状态置为 SHUTDOWN，中断闲置线程，但是还会继续处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 确认线程可访问</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//将状态设置为 SHUTOWN</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 中断线程池中的空闲的线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        <span class="comment">// 调用钩子方法</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="comment">// 确认线程没有中断，并且处于闲置状态之后再中断</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="shutdownNow-方法"><a href="#shutdownNow-方法" class="headerlink" title="shutdownNow() 方法"></a><code>shutdownNow()</code> 方法</h4><p><code>shutdownNow()</code> 方法中，除了将线程池状态置为 STOP 的之外，还会主动去中断工作线程，并且将任务阻塞等待队列清空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 确认线程可访问</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//将状态设置为 STOP</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 中断线程池中的所有工作线程，无论是否在运行</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 将任务阻塞等待队列清空</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终止线程池，因为当前线程池状态是 STOP，</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock; </span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">          w.interruptIfStarted();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Thread t;</span><br><span class="line">      <span class="comment">// 中断所有可以中断的线程</span></span><br><span class="line">      <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              t.interrupt();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ThreadPoolExecutor-的任务提交流程"><a href="#ThreadPoolExecutor-的任务提交流程" class="headerlink" title="ThreadPoolExecutor 的任务提交流程"></a><code>ThreadPoolExecutor</code> 的任务提交流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码的注释可以了解到，任务提交流程的逻辑如下：</p>
<ol>
<li>当线程池中线程数量小于核心线程数量时，直接创建创建新的线程</li>
<li>当线程池中线程数量大于核心线程数量时，如果线程缓存存队列没有满，则将任务加入缓存队列</li>
<li>当线程池中线程数量大于核心线程数量时，如果线程缓存队列满了，而且线程数量小于线程池最大容量的时候直接新建线程</li>
<li>当线程池中线程数量大于核心线程数量时，如果线程缓存队列满了，而且线程数量大于线程池最大容量的时候，调用拒绝处理器，拒绝新增任务</li>
</ol>
<p>具体的流程可以看下图：</p>
<p><img src="/assets/picture/thread.pool.executor.execute.flow.svg" alt="ThreadPoolExecutor 任务提交流程图" title="ThreadPoolExecutor 任务提交流程图"></p>
<p>上面这个图只是线程池任务提交流程的概要图，具体的为任务新建线程的逻辑在 <code>addWoker</code> 方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">// 线程状态为 SHUTDOWN，提交非空任务时， 直接退出</span></span><br><span class="line">        <span class="comment">// 线程状态为 SHUTDOWN，并且等待队列为空，此时提交空任务的时候直接退出</span></span><br><span class="line">        <span class="comment">// 线程状态为 STOP、TIDYING、TERMINATED 状态时，直接退出</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上面的代码分析一下就得到了下图</p>
<p><img src="/assets/picture/thread.pool.executor.state.detail.flow.svg" alt="ThreadPoolExecutor 任务提交详细流程图" title="ThreadPoolExecutor 任务提交详细流程图"></p>
<h3 id="ThreadPoolExecutor-是如何收缩的？"><a href="#ThreadPoolExecutor-是如何收缩的？" class="headerlink" title="ThreadPoolExecutor 是如何收缩的？"></a><code>ThreadPoolExecutor</code> 是如何收缩的？</h3><p>在任务执行过程中，线程池会根据状态去选择性的收缩大小，如下代码，<br>任务的线程在运行的时候，执行完了自身任务之后，会从线程池中取出等待的任务进行执行；在从任务等待队列中获取任务的过程中会根据情况对线程池进行收缩</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">  Thread wt = Thread.currentThread();</span><br><span class="line">  Runnable task = w.firstTask;</span><br><span class="line">  w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">  w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">  <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 当前需要执行的任务执行完毕之后，会从任务阻塞等待队列中提取待运行的任务并执行</span></span><br><span class="line">      <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 省略</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            task = <span class="keyword">null</span>;</span><br><span class="line">            w.completedTasks++;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      processWorkerExit(w, completedAbruptly);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">// 当线程池状态为 SHUTDOWN，并且等待队列为空时，线程池将被清空</span></span><br><span class="line">        <span class="comment">// 当线程池状态为 STOP 或者 TIDYING 或者 TERMINATED 时，忽略等待队列中的任务，线程池将被清空</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 1. 线程状态为 RUNNING</span></span><br><span class="line"><span class="comment">        *     1) 线程数量超过了线程池最大容量，线程池容量减一</span></span><br><span class="line"><span class="comment">        *     2) 线程数量超过了核心线程数，且上一循环中获取线程超时了，线程池容量减一</span></span><br><span class="line"><span class="comment">        *     3) 线程数量小于核心线程数且大于1，但是核心线程允许闲置超时销毁时，线程池容量减一</span></span><br><span class="line"><span class="comment">        *     4)线程数量小于等于1，但是核心线程允许闲置超时销毁时，且上一循环中获取线程超时了，且任务缓存队列为空，线程池容量减一</span></span><br><span class="line"><span class="comment">        * 2. 线程状态为 SHUTDOWN, 但是任务缓存队列不为空</span></span><br><span class="line"><span class="comment">        *     1) 线程数量超过了线程池最大容量，线程池容量减一</span></span><br><span class="line"><span class="comment">        *     2) 线程数量超过了核心线程数，且上一循环中获取线程超时了，线程池容量减一</span></span><br><span class="line"><span class="comment">        *     3) 线程数量小于核心线程数且大于1，但是核心线程允许闲置超时销毁时，线程池容量减一</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，线程池的线程在执行完当前任务之后会去从任务阻塞等待队列中提取待运行的任务，这个时候线程池会在不同的状态下，根据情况进行收缩</p>
<ul>
<li>线程池状态为RUNNIING<ul>
<li>线程数量超过了线程池最大容量，线程池容量减一</li>
<li>线程数量超过了核心线程数，且上一循环中获取线程超时了（等待队列可能为空），线程池容量减一</li>
<li>线程数量小于核心线程数且大于1，且上一循环中获取线程超时了（等待队列可能为空），但是核心线程允许闲置超时销毁时，线程池容量减一</li>
<li>线程数量小于核心线程数且大于1，但是核心线程不允许闲置超时销毁时，线程池会阻塞在从任务等待队列中提起任务的操作上，除非被中断</li>
<li>线程数量小于等于1，但是核心线程允许闲置超时销毁时，且上一循环中获取线程超时了（等待队列可能为空），且任务等待队列为空，线程池容量减一</li>
</ul>
</li>
<li>线程池状态为 SHUTDOWN，并且任务缓存队列为空的时候，CAS 自旋将线程池大小降到 0 为止</li>
<li>线程池状态为 SHUTDOWN，且任务缓存队列不为空<ul>
<li>线程数量超过了线程池最大容量，线程池容量减一</li>
<li>线程数量超过了核心线程数，且上一循环中获取线程超时了（等待队列可能为空），线程池容量减一</li>
<li>线程数量小于核心线程数且大于1，但是核心线程允许闲置超时销毁时，线程池容量减一</li>
</ul>
</li>
<li>线程池状态为 STOP 或者 TIDYING 或者 TERMINATED 时，CAS 自旋将线程池大小降到 0 为止</li>
</ul>
<p><strong><em>注意：上面说到的超时，就是超过了线程池的闲置超时时间</em></strong></p>
<pre><code>    总结一下：
    1. 线程池在运行中(RUNNING)状态时，
    1) 当线程数超过线程池最大容量时，线程池容量减一，确保线程池容量限制
    2) 当线程数超过了核心线程数，而且暂时没有等待运行的任务，线程池容量减一，让线程数逐步
    回归核心线程数；
    3) 当线程数小于核心线程数且大于1，而线程池允许核心线程闲置超时销毁，而且暂时没有等待
    运行的任务，线程池容量也会减一，让线程数逐步减少到 1；
    4) 当线程数小于核心线程数且大于1，但是运行中的线程池如果核心线程不允许闲置超时销毁，
    线程池会阻塞在从等待队列中提取待运行的任务，除非被中断；
    5) 当这个运行中的线程池中的线程数减少到 1 的时候，如果核心线程允许闲置超时销毁，而且
    暂时没有等待运行的任务，且当前任务等待队列为空，线程池容量减一，线程池为空了
    6) 当这个运行中的线程池中的线程数减少到 1 的时候，但是运行中的线程池如果核心线程不允
    许闲置超时销毁，线程池会阻塞在从等待队列中提取待运行的任务，除非被中断；
    2. 线程池在待关闭(SHUTDOWN)状态时，
    1) 如果任务等待队列为空，线程池将被清空；如果任务等待队列不为空，还是处理等待任务，当
    线程数超过线程池最大容量时，线程池容量减一，保证线程数不超过最大容量；
    2) 当线程数超过了核心线程数，而且暂时没有等待运行的任务，线程池容量减一，让线程数逐步
    回归核心线程数；
    3) 当线程数小于核心线程数且大于 1 的时候，如果核心线程允许闲置超时销毁，而且暂时没有
    等待运行的任务，线程池容量减一，让线程数逐步减少到 1；
    4) 当线程数减少到 1 时，因为线程池处于待关闭状态，且任务等待队列不为空，这个线程会被
    保留用于处理等待运行的任务
    3. 线程池在停止(STOP)、整理(TIDYING)、终止(TERMINATED) 状态下，不会接受新任务，
    也不会处理等待队列中的任务，直接将线程池容量逐步清空</code></pre>
<p>说了这么多我们直降到了线程池的数量被减少了，但是 <strong><em>闲置的线程是怎么被清除的呢？</em></strong></p>
<p>让我们再回看一下 <code>getTask()</code> 方法中在将线程池的容量收缩之后，马上返回了一个 <code>null</code><br><img src="/assets/picture/thred.pool.get.task.reuturn.null.after.decrement.jpg" title="getTask() 线程池容量收缩后返回 null"></p>
<p>获取到的待运行任务为 null 时，就要开始清除这个线程了<br><img src="/assets/picture/thread.pool.executor.process.worker.exit.jpg" title="待运行任务为 null 时处理退出线程"></p>
<p>下面就是 <code>processWorkerExit</code> 方法的逻辑了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        workers.remove(w); <span class="comment">// 将线程从线程池中删除</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试终止线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池状态时 RUNNING 或者 SHUTDOWN 且线程运行过程中没有抛出异常时</span></span><br><span class="line">    <span class="comment">// 当线程池不允许核心线程闲置超时被销毁时，确保线程池有核心线程数的线程</span></span><br><span class="line">    <span class="comment">// 当线程池允许核心线程闲置超时被销毁时，确保线程池至少有一个线程</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>      总结：
      当等待队列中暂时没有待执行任务时，将线程池数量收缩之后，这里会将当前工作线程从线程池中清除掉
      当线程池状态是 SHUTDOWN 且任务等待队列为空时，这里还会尝试去终止线程池
      当线程池状态是 RUNNING 或者状态是 SHUTDOWN 且任务队列不为空是，我们需要有一定的线程去处理任务；
      这个时候当线程池允许核心线程闲置超时被销毁时，如果线程池为空，向线程池新增一个不带任务的线程；
      当线程池不允许核心线程闲置超时被销毁时，如果线程数量小于核心线程数，也向线程池新增一个不带任务的线程；

      总之是当线程池还在运行中，或者待关闭需要处理等待队列中的待运行任务时，保证线程池有一定的线程去处理
      这些任务</code></pre>
<p><strong><em>注意：线程池中的闲置线程在达到超时时间之后不一定会立刻被清除掉，而是在超时时间之后的某个时刻被清除掉</em></strong></p>
<h3 id="ThreadPoolExecutor-执行任务过程中的扩展操作"><a href="#ThreadPoolExecutor-执行任务过程中的扩展操作" class="headerlink" title="ThreadPoolExecutor 执行任务过程中的扩展操作"></a><code>ThreadPoolExecutor</code> 执行任务过程中的扩展操作</h3><p><code>ThreadPoolExecutor</code> 线程池在执行任务的过程中，支持进行一些扩展的插入操作</p>
<ul>
<li><code>terminated()</code>: 线程池终止前的插入操作</li>
</ul>
<p>在上面的状态流转说明中，线程池从 <code>TIDYING</code> 流转到 <code>TERMINATED</code> 状态之前，就是去调用 <code>terminated()</code> 方法，下面的代码就是具体逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    terminated(); <span class="comment">// 扩展插入操作</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>beforeExecute()</code> 和 <code>afterExecute()</code>: 任务执行前后的插入操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 省略</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task); <span class="comment">// 执行任务之前的插入操作</span></span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown); <span class="comment">// 执行任务之后的插入操作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="通过-Executors-创建-ThreadPoolExecutor"><a href="#通过-Executors-创建-ThreadPoolExecutor" class="headerlink" title="通过 Executors 创建 ThreadPoolExecutor"></a>通过 <code>Executors</code> 创建 <code>ThreadPoolExecutor</code></h3><h4 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无界线程池，它的特性是</p>
<ul>
<li>corePoolSize 是 0</li>
<li>workQueue 任务等待队列是 <code>SynchronousQueue</code>，不存储任何元素，放入元素的时候直接返回 false</li>
<li>maximumPoolSize 是 INTEGER.MAX_VALUE</li>
</ul>
<p>上述特点意味着，向线程池提交任务之后，即超过了核心线程数，可以加入任务等待队列，但是 <code>SynchronousQueue</code> 不支持存储任何元素，线程池容量向 maximumPoolSize 发展，也就是 Integer.MAX_VALUE，线程池开始无限新建新线程</p>
<h4 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h4><p>固定大小的线程池的特性是</p>
<ul>
<li>任务阻塞等待队列的长度是无界的</li>
</ul>
<p>这意味着，线程池中线程数量达到核心线程数后，新提交的任务会进入无界等待队列(长度为 <code>Integer.MAX_VALUE</code>)，这意味 <code>线程池最大容量</code> 参数失去了意义，线程池中的线程数量不会超过核心线程数；</p>
<ul>
<li>闲置线程的存活时间是 0</li>
</ul>
<p>这表示，运行中的线程从任务等待队列中提取任务时，不会阻塞等待，</p>
<p>用户指定线程池和核心线程数和线程池最大容量，而且核心线程数和线程池容量一致，任务等待阻塞队列的长度是无界的，这意味着当线程数量超过核心线程数之后，新提交的任务被放入任务阻塞等待队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>注意：阿里巴巴 Java 开发规范要求我们不要使用 <code>Executors</code> 去创建上述两种 <code>ThreadPoolExecutor</code></em></strong></p>
<p><img src="/assets/picture/why.not.use.executors.jpg" title="Why can not use Executors to create ThreadPoolExecutor"></p>
<h4 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单线程线程池，它的特点是</p>
<ul>
<li>核心线程数和线程池容量都是 1</li>
<li>任务等待队列是无界的阻塞队列</li>
</ul>
<p>这意味着 ———— 向线程池提交任务之后，会创建唯一的线程，然后任务被放入阻塞等待队列，然后被唯一的线程一个个的处理</p>
<h3 id="关于线程池参数"><a href="#关于线程池参数" class="headerlink" title="关于线程池参数"></a>关于线程池参数</h3><h4 id="线程池大小"><a href="#线程池大小" class="headerlink" title="线程池大小"></a>线程池大小</h4><p>关于线程池的参数，所有所有资料都在告诉我们，线程池中的任务分为 IO 密集型和 CPU 密集型；在 《Java 并发编程实战》一书的 8.2 章节中我们可以学习到下面的结论：</p>
<p>CPU 密集型的任务特点是任务有大量计算，消耗 CPU 资源，CPU 占用率很高；执行这种任务的时候线程数过多，会发生很多线程抢占CPU 的情况，线程的上下文切换也比较浪费资源；所以对于 CPU 密集型的任务，我们需要的是 N<sub>cpu</sub> + 1 个线程，这里比 CPU 个数多一个的原因是，**<em>即使当计算密集型的线程偶尔由于页缺失故障或者其他原因而暂停时，这个额外的线程也能确保CPU的时钟周期不会被浪费。**</em></p>
<p>而对于其他任务，CPU 计算操作和 IO 操作是混合在一起的，对于这种CPU 使用率不会特别高的任务，线程池的容量可以大一点，对于这种任务多很多文章都说线程池容量可以设置成 2N，这个值没有什么准确的依据，只是个经验预估值，没什么参考价值；针对 IO密集型的任务，我们需要关注的是 CPU 计算时间和 CPU 等待时间的比例，以及 CPU  的目标使用率</p>
<hr>
<p>线程池容量 = N<sub>cpu</sub> * U<sub>cpu</sub> * (1 + W/C)<br>N<sub>cpu</sub>: CPU 个数<br>U<sub>cpu</sub>: 目标 CPU 使用率<br>W: CPU 等待时间<br>C: CPU 计算时间</p>
<hr>
<p>举例说明，现在有个任务，CPU 计算的时间是 10ms， IO 操作的时间是 90ms，理想情况下我们以 CPU 利用率 100% 为假定目标，这个时候对于一个 8 核的机器：<br>线程池容量 = 8 * 1 * (1 + 90/10) = 80；所以这里我们需要 80 个线程</p>
<p><strong><em>线程池的大小是根据目标 CPU 使用率计算出来的，所以这就是我们的能设置的最大的线程池容量了</em></strong></p>
<h4 id="任务等待队列"><a href="#任务等待队列" class="headerlink" title="任务等待队列"></a>任务等待队列</h4><h5 id="任务等待队列实现的选择"><a href="#任务等待队列实现的选择" class="headerlink" title="任务等待队列实现的选择"></a>任务等待队列实现的选择</h5><p>任务等待队列的类型是阻塞队列，下面先介绍一下阻塞队列，再说明如何选择任务等待队列的实现</p>
<h5 id="阻塞队列的特性"><a href="#阻塞队列的特性" class="headerlink" title="阻塞队列的特性"></a>阻塞队列的特性</h5><p>先看看 <code>BlockingQueue</code> 中的方法<br><img src="/assets/picture/blocking.queue.method.list.jpg" title="阻塞队列的方法列表"></p>
<p>下面是具体一点的方法列表</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>方法介绍</th>
<th>返回值</th>
<th>是否抛出异常</th>
<th>附加说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean add(E e)</td>
<td>向队列中添加元素</td>
<td>添加成功则返回 true</td>
<td>队列容量不足时，抛出 IllegalStateException</td>
<td>使用有界队列的时候，推荐使用 offer(E) 方法</td>
</tr>
<tr>
<td>boolean offer(E e)</td>
<td>向队列中添加元素</td>
<td>添加成功返回true， 否则返回 false</td>
<td>-</td>
<td>使用有界队列的时候，优先于 add(E) 方法被使用</td>
</tr>
<tr>
<td>boolean offer(E e, long timeout, TimeUnit)</td>
<td>向队列中添加元素</td>
<td>添加成功返回true， 否则返回 false，超时也返回 false</td>
<td>被中断时抛出 InterruptedException</td>
<td>使用有界队列的时候，优先于 add(E) 方法被使用</td>
</tr>
<tr>
<td>void put(E e)</td>
<td>向队列中添加元素</td>
<td>无</td>
<td>被中断的时候抛出 InterruptedException</td>
<td>一直阻塞，直至成功或失败</td>
</tr>
<tr>
<td>E remove()</td>
<td>删除队列头第一个元素</td>
<td>删除成功时，返回被删除的元素</td>
<td>队列头为空时抛出 NoSuchElementException</td>
<td>-</td>
</tr>
<tr>
<td>boolean remove(E e)</td>
<td>删除指定元素</td>
<td>删除成功时返回 true，反正返回 false</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>E poll()</td>
<td>删除并返回队列头元素或者null</td>
<td>返回队列头元素，队列为空时返回 null</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>E poll(long timeout, TimeUnit unit)</td>
<td>删除并返回队列头元素或者null</td>
<td>返回队列头元素，队列为空或者超时的时候返回 null</td>
<td>被中断时抛出 InterruptedException</td>
<td>没有命中元素时，阻塞直至超时</td>
</tr>
<tr>
<td>E take()</td>
<td>删除并返回队列头元素或者null</td>
<td>返回队列头元素</td>
<td>被中断时抛出 InterruptedException</td>
<td>一直阻塞，直至成功或失败</td>
</tr>
<tr>
<td>E element()</td>
<td>返回队列头元素，但是不删除</td>
<td>返回队列头元素</td>
<td>没有命中任何元素的时候抛出 NoSuchElementException</td>
<td>-</td>
</tr>
<tr>
<td>E peek()</td>
<td>返回队列头元素或者 null，但是不删除</td>
<td>返回队列头元素或者null</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p>阻塞队列的特性就会提供了上述方法，分类以下几类</p>
<ul>
<li>一直阻塞等待的方法，可以被中断，put(E e) 新增元素，take() 获取并删除头元素</li>
<li>阻塞超时的方法，可以被中断，offer(E e, long timeout, TimeUnit) 新增元素， poll(long timeout, TimeUnit unit) 获取并删除头元素</li>
<li>抛出异常，add(E e) 新增元素，remove() 删除元素，element() 获取头元素</li>
<li>返回特征值，offer(E e) 新增失败返回false；poll() 没有命中时返回 null；peek() 没有命中时返回 null</li>
</ul>
<table>
<thead>
<tr>
<th>方法\处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞(可中断)</th>
<th>超时退出(可中断)</th>
</tr>
</thead>
<tbody><tr>
<td>插入元素</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e, time, unit)</td>
</tr>
<tr>
<td>返回队列头元素，并从队列中移除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>返回队列头元素，但不删除</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<p>方法的选用取决于我们是否需要立即同步获取操作结果，可以等待一定时长，还是可以一直等待</p>
<h6 id="阻塞队列的实现"><a href="#阻塞队列的实现" class="headerlink" title="阻塞队列的实现"></a>阻塞队列的实现</h6><p>先看看类图</p>
<p><img src="/assets/picture/blocking.queue.implements.class.diagram.png" title="阻塞队列的主要实现的类图"></p>
<p>主要实现的简要说明：</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>特性</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>LinkedBlockingQueue</td>
<td>由单向链表实现的先进先出的阻塞队列</td>
<td>可阻塞，入出队列锁分离，效率高，支持容量限制，可以作为无界队列的实现</td>
<td>由于存在锁机制，同时链表需要遍历才能定位一个元素，因此效率有一定的影响</td>
</tr>
<tr>
<td>ArrayBlockingQueue</td>
<td>由数组实现的先进先出的阻塞队列</td>
<td>可阻塞，支持容量限制，遍历元素的效率更快，可以作为有界队列的实现</td>
<td>容量固定，不支持扩容，出入队列不能同时进行</td>
</tr>
<tr>
<td>SynchronousQueue</td>
<td>每一个插入操作都必须等待另一个线程的移除操作，反之亦然；这意味同步队列没有容量，或者说容量为 1，元素被生产者放入同步队列之后，期待消费者移除处理之后生产者才能继续放入元素</td>
<td>可阻塞，快速交换元素</td>
<td>内部没有容量</td>
</tr>
<tr>
<td>PriorityBlockingQueue</td>
<td>按照自然排序实现的阻塞队列，在元素需要排序的情况下是唯一的选择</td>
<td>可阻塞，元素有序，支持扩容</td>
<td>出入队列比较慢，效率比较低，基于数组的实现每次扩容都需要复制数组，同时容量不能减小，入队列不能被阻塞</td>
</tr>
<tr>
<td>DelayQueue</td>
<td>基于 PriorityBlockingQueue 实现的延时处理队列，每个元素都有一个延时时间，当且仅当延时时间过期才能出队列</td>
<td>可阻塞，可延时</td>
<td>效率低，入队列不能被阻塞</td>
</tr>
</tbody></table>
<h6 id="阻塞队列的使用场景"><a href="#阻塞队列的使用场景" class="headerlink" title="阻塞队列的使用场景"></a>阻塞队列的使用场景</h6><p>从阻塞队列的特性来看，<br><code>LinkedBlockingQueue</code> 是无界阻塞队列的首选，但是线程池不推荐使用无界队列；<br>为了更好的控制线程池，需要一个有界阻塞队列，<code>ArrayBlockingQueue</code> 是实现首选；<br><code>PriorityBlockingQueue</code> 支持队列中元素排序，对于需要处理不同优先级的任务的线程池，最优选择是优先级阻塞队列，最好设置上长度；<br><code>DelayQueue</code> 主要作用是元素需要延时被延时处理，只有线程池需要处理的任务需要等待一定时间才能处理时，才会选择这种阻塞队列的实现；</p>
<p><strong><em>结论：一般情况下，使用有界阻塞队列 <code>ArrayBlockingQueue</code> 作为线程池的任务等待队列</em></strong></p>
<h5 id="任务等待队列的长度和闲置线程存活时间"><a href="#任务等待队列的长度和闲置线程存活时间" class="headerlink" title="任务等待队列的长度和闲置线程存活时间"></a>任务等待队列的长度和闲置线程存活时间</h5><p>为了线程池的可控，我们给线程池的任务等待队列设置一个可接受的大小，否则像 CachedThreadPool 一样设置一个无界阻塞队列，很容易就会因为队列过程而 OOM；考虑等待队列长、闲置线程存活时间和线程池容量这三个参数的时候，我们需要综合考虑，因为线程数超过核心线程数之后再提交的任务，会先先尝试放入任务等待队列，队列空间不足就会去创建非核心线程，非核心线程从阻塞队列中提取任务的等待时长就是 <code>闲置线程的存活时间</code>，超过这个时间非核心线程就可能会被回收，也就是说 <strong><em>任务等待队列的核心功能就是将核心线程暂时无法忙碌无法处理的任务缓存起来；核心线程忙碌的情况下，如果等待队列没有空的情况下，队列中的任务都需要等待线程来处理</em></strong> ；</p>
<p>任务等待队列的长度，首先需要保证能够缓存所有的任务，其次缓存在队列中的任务的等待时长必须在业务可接受范围内；</p>
<ul>
<li>在核心线程忙碌，任务进入等待队列的阶段，任务处理的最大时长是 </li>
</ul>
<hr>
<p>T<sub>task</sub> = ceil(workQueue.length / coorPoolSize) * T<sub>process</sub> + T<sub>process</sub><br>T<sub>task</sub>: 核心线程忙碌时，任务处理总时长<br>workQueue.length: 任务等待队列的长度<br>coorPoolSize: 核心线程数<br>T<sub>process</sub>: 任务实际处理时长<br>ceil(): 向上取整的函数</p>
<hr>
<p>在这个情况下，任务队列的长度，取决于业务能接受的任务最大处理时长，假定业务能接受的任务处理时长</p>
<ul>
<li>在任务等待度列满了之后，创建了非核心线程之后，任务处理的最大时长是</li>
</ul>
<hr>
<p>T<sub>task</sub> = ceil(workQueue.length / poolSize) * keepAliveTime + T<sub>process</sub><br>T<sub>task</sub>: 核心线程忙碌时，任务处理总时长<br>workQueue.length: 任务等待队列的长度<br>poolSize: 线程池中工作线程数<br>keepAliveTime: 闲置线程存活时间<br>T<sub>process</sub>: 任务实际处理时长<br>ceil(): 向上取整的函数</p>
<hr>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/Thread/" rel="tag"># Thread</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/20/%E6%8A%80%E6%9C%AF/spring/Spring%20Bean%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" rel="prev" title="Spring Bean 生命周期">
      <i class="fa fa-chevron-left"></i> Spring Bean 生命周期
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/26/%E6%8A%80%E6%9C%AF/java/%E9%87%8D%E8%AF%BBJava%20%E6%BA%90%E7%A0%81%20%E2%80%94%E2%80%94%20J.U.C%20%E4%B8%AD%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/" rel="next" title="J.U.C 包中的工具类">
      J.U.C 包中的工具类 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.</span> <span class="nav-text">Java 线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%98%E5%9C%A8%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">1.1.</span> <span class="nav-text">线程池存在的意义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Executor-%E7%9A%84%E9%87%8D%E8%A6%81%E5%AE%9E%E7%8E%B0-%E2%80%94%E2%80%94%E2%80%94%E2%80%94-ThreadPoolExecutor"><span class="nav-number">1.2.</span> <span class="nav-text">Executor 的重要实现 ———— ThreadPoolExecutor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPoolExecutor-%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">1.2.1.</span> <span class="nav-text">ThreadPoolExecutor 的参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#J-U-C-%E6%8F%90%E4%BE%9B%E7%9A%84-RejectExecutionHandler-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">J.U.C 提供的 RejectExecutionHandler 的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPoolExecutor-%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">1.2.2.</span> <span class="nav-text">ThreadPoolExecutor 的状态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#shutdown-%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">shutdown() 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shutdownNow-%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">shutdownNow() 方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPoolExecutor-%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.3.</span> <span class="nav-text">ThreadPoolExecutor 的任务提交流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPoolExecutor-%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%B6%E7%BC%A9%E7%9A%84%EF%BC%9F"><span class="nav-number">1.2.4.</span> <span class="nav-text">ThreadPoolExecutor 是如何收缩的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPoolExecutor-%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.5.</span> <span class="nav-text">ThreadPoolExecutor 执行任务过程中的扩展操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-Executors-%E5%88%9B%E5%BB%BA-ThreadPoolExecutor"><span class="nav-number">1.2.6.</span> <span class="nav-text">通过 Executors 创建 ThreadPoolExecutor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CachedThreadPool"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">CachedThreadPool</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FixedThreadPool"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">FixedThreadPool</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SingleThreadExecutor"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">SingleThreadExecutor</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0"><span class="nav-number">1.2.7.</span> <span class="nav-text">关于线程池参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">线程池大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">任务等待队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">1.2.7.2.1.</span> <span class="nav-text">任务等待队列实现的选择</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">1.2.7.2.2.</span> <span class="nav-text">阻塞队列的特性</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.7.2.2.1.</span> <span class="nav-text">阻塞队列的实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.7.2.2.2.</span> <span class="nav-text">阻塞队列的使用场景</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6%E5%92%8C%E9%97%B2%E7%BD%AE%E7%BA%BF%E7%A8%8B%E5%AD%98%E6%B4%BB%E6%97%B6%E9%97%B4"><span class="nav-number">1.2.7.2.3.</span> <span class="nav-text">任务等待队列的长度和闲置线程存活时间</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Liam Chen</p>
  <div class="site-description" itemprop="description">关于技术与生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liam Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
